
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model Posts
 * 
 */
export type Posts = $Result.DefaultSelection<Prisma.$PostsPayload>
/**
 * Model Story
 * 
 */
export type Story = $Result.DefaultSelection<Prisma.$StoryPayload>
/**
 * Model Like
 * 
 */
export type Like = $Result.DefaultSelection<Prisma.$LikePayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model RePosts
 * 
 */
export type RePosts = $Result.DefaultSelection<Prisma.$RePostsPayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Messages
 * 
 */
export type Messages = $Result.DefaultSelection<Prisma.$MessagesPayload>
/**
 * Model Friends
 * 
 */
export type Friends = $Result.DefaultSelection<Prisma.$FriendsPayload>
/**
 * Model Followers
 * 
 */
export type Followers = $Result.DefaultSelection<Prisma.$FollowersPayload>
/**
 * Model StoryViewer
 * 
 */
export type StoryViewer = $Result.DefaultSelection<Prisma.$StoryViewerPayload>
/**
 * Model PostsViewer
 * 
 */
export type PostsViewer = $Result.DefaultSelection<Prisma.$PostsViewerPayload>
/**
 * Model CommentViewer
 * 
 */
export type CommentViewer = $Result.DefaultSelection<Prisma.$CommentViewerPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MediaType: {
  PHOTO: 'PHOTO',
  VIDEO: 'VIDEO',
  MUSIC: 'MUSIC',
  TEXT: 'TEXT'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const FileType: {
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO',
  DOCUMENT: 'DOCUMENT'
};

export type FileType = (typeof FileType)[keyof typeof FileType]


export const FriendStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED'
};

export type FriendStatus = (typeof FriendStatus)[keyof typeof FriendStatus]


export const NotificationType: {
  LIKE: 'LIKE',
  COMMENT: 'COMMENT',
  FOLLOW: 'FOLLOW',
  FRIEND_REQUEST: 'FRIEND_REQUEST',
  REPOST: 'REPOST',
  MENTION: 'MENTION'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type FileType = $Enums.FileType

export const FileType: typeof $Enums.FileType

export type FriendStatus = $Enums.FriendStatus

export const FriendStatus: typeof $Enums.FriendStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.posts`: Exposes CRUD operations for the **Posts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.posts.findMany()
    * ```
    */
  get posts(): Prisma.PostsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.story`: Exposes CRUD operations for the **Story** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stories
    * const stories = await prisma.story.findMany()
    * ```
    */
  get story(): Prisma.StoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.like`: Exposes CRUD operations for the **Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): Prisma.LikeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rePosts`: Exposes CRUD operations for the **RePosts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RePosts
    * const rePosts = await prisma.rePosts.findMany()
    * ```
    */
  get rePosts(): Prisma.RePostsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messages`: Exposes CRUD operations for the **Messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.messages.findMany()
    * ```
    */
  get messages(): Prisma.MessagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.friends`: Exposes CRUD operations for the **Friends** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friends
    * const friends = await prisma.friends.findMany()
    * ```
    */
  get friends(): Prisma.FriendsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.followers`: Exposes CRUD operations for the **Followers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Followers
    * const followers = await prisma.followers.findMany()
    * ```
    */
  get followers(): Prisma.FollowersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storyViewer`: Exposes CRUD operations for the **StoryViewer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoryViewers
    * const storyViewers = await prisma.storyViewer.findMany()
    * ```
    */
  get storyViewer(): Prisma.StoryViewerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postsViewer`: Exposes CRUD operations for the **PostsViewer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostsViewers
    * const postsViewers = await prisma.postsViewer.findMany()
    * ```
    */
  get postsViewer(): Prisma.PostsViewerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commentViewer`: Exposes CRUD operations for the **CommentViewer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentViewers
    * const commentViewers = await prisma.commentViewer.findMany()
    * ```
    */
  get commentViewer(): Prisma.CommentViewerDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Users: 'Users',
    Posts: 'Posts',
    Story: 'Story',
    Like: 'Like',
    Comment: 'Comment',
    RePosts: 'RePosts',
    Attachment: 'Attachment',
    Notification: 'Notification',
    Messages: 'Messages',
    Friends: 'Friends',
    Followers: 'Followers',
    StoryViewer: 'StoryViewer',
    PostsViewer: 'PostsViewer',
    CommentViewer: 'CommentViewer'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "users" | "posts" | "story" | "like" | "comment" | "rePosts" | "attachment" | "notification" | "messages" | "friends" | "followers" | "storyViewer" | "postsViewer" | "commentViewer"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Posts: {
        payload: Prisma.$PostsPayload<ExtArgs>
        fields: Prisma.PostsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          findFirst: {
            args: Prisma.PostsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          findMany: {
            args: Prisma.PostsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>[]
          }
          create: {
            args: Prisma.PostsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          createMany: {
            args: Prisma.PostsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>[]
          }
          delete: {
            args: Prisma.PostsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          update: {
            args: Prisma.PostsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          deleteMany: {
            args: Prisma.PostsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>[]
          }
          upsert: {
            args: Prisma.PostsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          aggregate: {
            args: Prisma.PostsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosts>
          }
          groupBy: {
            args: Prisma.PostsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostsCountArgs<ExtArgs>
            result: $Utils.Optional<PostsCountAggregateOutputType> | number
          }
        }
      }
      Story: {
        payload: Prisma.$StoryPayload<ExtArgs>
        fields: Prisma.StoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          findFirst: {
            args: Prisma.StoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          findMany: {
            args: Prisma.StoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>[]
          }
          create: {
            args: Prisma.StoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          createMany: {
            args: Prisma.StoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>[]
          }
          delete: {
            args: Prisma.StoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          update: {
            args: Prisma.StoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          deleteMany: {
            args: Prisma.StoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>[]
          }
          upsert: {
            args: Prisma.StoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryPayload>
          }
          aggregate: {
            args: Prisma.StoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStory>
          }
          groupBy: {
            args: Prisma.StoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryCountArgs<ExtArgs>
            result: $Utils.Optional<StoryCountAggregateOutputType> | number
          }
        }
      }
      Like: {
        payload: Prisma.$LikePayload<ExtArgs>
        fields: Prisma.LikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findFirst: {
            args: Prisma.LikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          findMany: {
            args: Prisma.LikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          create: {
            args: Prisma.LikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          createMany: {
            args: Prisma.LikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          delete: {
            args: Prisma.LikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          update: {
            args: Prisma.LikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          deleteMany: {
            args: Prisma.LikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LikeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>[]
          }
          upsert: {
            args: Prisma.LikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LikePayload>
          }
          aggregate: {
            args: Prisma.LikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLike>
          }
          groupBy: {
            args: Prisma.LikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LikeCountArgs<ExtArgs>
            result: $Utils.Optional<LikeCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      RePosts: {
        payload: Prisma.$RePostsPayload<ExtArgs>
        fields: Prisma.RePostsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RePostsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RePostsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RePostsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RePostsPayload>
          }
          findFirst: {
            args: Prisma.RePostsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RePostsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RePostsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RePostsPayload>
          }
          findMany: {
            args: Prisma.RePostsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RePostsPayload>[]
          }
          create: {
            args: Prisma.RePostsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RePostsPayload>
          }
          createMany: {
            args: Prisma.RePostsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RePostsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RePostsPayload>[]
          }
          delete: {
            args: Prisma.RePostsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RePostsPayload>
          }
          update: {
            args: Prisma.RePostsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RePostsPayload>
          }
          deleteMany: {
            args: Prisma.RePostsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RePostsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RePostsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RePostsPayload>[]
          }
          upsert: {
            args: Prisma.RePostsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RePostsPayload>
          }
          aggregate: {
            args: Prisma.RePostsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRePosts>
          }
          groupBy: {
            args: Prisma.RePostsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RePostsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RePostsCountArgs<ExtArgs>
            result: $Utils.Optional<RePostsCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Messages: {
        payload: Prisma.$MessagesPayload<ExtArgs>
        fields: Prisma.MessagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          findFirst: {
            args: Prisma.MessagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          findMany: {
            args: Prisma.MessagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>[]
          }
          create: {
            args: Prisma.MessagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          createMany: {
            args: Prisma.MessagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>[]
          }
          delete: {
            args: Prisma.MessagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          update: {
            args: Prisma.MessagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          deleteMany: {
            args: Prisma.MessagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>[]
          }
          upsert: {
            args: Prisma.MessagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagesPayload>
          }
          aggregate: {
            args: Prisma.MessagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessages>
          }
          groupBy: {
            args: Prisma.MessagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessagesCountArgs<ExtArgs>
            result: $Utils.Optional<MessagesCountAggregateOutputType> | number
          }
        }
      }
      Friends: {
        payload: Prisma.$FriendsPayload<ExtArgs>
        fields: Prisma.FriendsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          findFirst: {
            args: Prisma.FriendsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          findMany: {
            args: Prisma.FriendsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>[]
          }
          create: {
            args: Prisma.FriendsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          createMany: {
            args: Prisma.FriendsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FriendsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>[]
          }
          delete: {
            args: Prisma.FriendsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          update: {
            args: Prisma.FriendsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          deleteMany: {
            args: Prisma.FriendsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FriendsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>[]
          }
          upsert: {
            args: Prisma.FriendsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          aggregate: {
            args: Prisma.FriendsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriends>
          }
          groupBy: {
            args: Prisma.FriendsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendsCountArgs<ExtArgs>
            result: $Utils.Optional<FriendsCountAggregateOutputType> | number
          }
        }
      }
      Followers: {
        payload: Prisma.$FollowersPayload<ExtArgs>
        fields: Prisma.FollowersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowersPayload>
          }
          findFirst: {
            args: Prisma.FollowersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowersPayload>
          }
          findMany: {
            args: Prisma.FollowersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowersPayload>[]
          }
          create: {
            args: Prisma.FollowersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowersPayload>
          }
          createMany: {
            args: Prisma.FollowersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowersPayload>[]
          }
          delete: {
            args: Prisma.FollowersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowersPayload>
          }
          update: {
            args: Prisma.FollowersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowersPayload>
          }
          deleteMany: {
            args: Prisma.FollowersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FollowersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowersPayload>[]
          }
          upsert: {
            args: Prisma.FollowersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowersPayload>
          }
          aggregate: {
            args: Prisma.FollowersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollowers>
          }
          groupBy: {
            args: Prisma.FollowersGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowersGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowersCountArgs<ExtArgs>
            result: $Utils.Optional<FollowersCountAggregateOutputType> | number
          }
        }
      }
      StoryViewer: {
        payload: Prisma.$StoryViewerPayload<ExtArgs>
        fields: Prisma.StoryViewerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoryViewerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryViewerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoryViewerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryViewerPayload>
          }
          findFirst: {
            args: Prisma.StoryViewerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryViewerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoryViewerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryViewerPayload>
          }
          findMany: {
            args: Prisma.StoryViewerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryViewerPayload>[]
          }
          create: {
            args: Prisma.StoryViewerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryViewerPayload>
          }
          createMany: {
            args: Prisma.StoryViewerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoryViewerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryViewerPayload>[]
          }
          delete: {
            args: Prisma.StoryViewerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryViewerPayload>
          }
          update: {
            args: Prisma.StoryViewerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryViewerPayload>
          }
          deleteMany: {
            args: Prisma.StoryViewerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoryViewerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoryViewerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryViewerPayload>[]
          }
          upsert: {
            args: Prisma.StoryViewerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoryViewerPayload>
          }
          aggregate: {
            args: Prisma.StoryViewerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoryViewer>
          }
          groupBy: {
            args: Prisma.StoryViewerGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoryViewerGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoryViewerCountArgs<ExtArgs>
            result: $Utils.Optional<StoryViewerCountAggregateOutputType> | number
          }
        }
      }
      PostsViewer: {
        payload: Prisma.$PostsViewerPayload<ExtArgs>
        fields: Prisma.PostsViewerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostsViewerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsViewerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostsViewerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsViewerPayload>
          }
          findFirst: {
            args: Prisma.PostsViewerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsViewerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostsViewerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsViewerPayload>
          }
          findMany: {
            args: Prisma.PostsViewerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsViewerPayload>[]
          }
          create: {
            args: Prisma.PostsViewerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsViewerPayload>
          }
          createMany: {
            args: Prisma.PostsViewerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostsViewerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsViewerPayload>[]
          }
          delete: {
            args: Prisma.PostsViewerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsViewerPayload>
          }
          update: {
            args: Prisma.PostsViewerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsViewerPayload>
          }
          deleteMany: {
            args: Prisma.PostsViewerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostsViewerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostsViewerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsViewerPayload>[]
          }
          upsert: {
            args: Prisma.PostsViewerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsViewerPayload>
          }
          aggregate: {
            args: Prisma.PostsViewerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostsViewer>
          }
          groupBy: {
            args: Prisma.PostsViewerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostsViewerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostsViewerCountArgs<ExtArgs>
            result: $Utils.Optional<PostsViewerCountAggregateOutputType> | number
          }
        }
      }
      CommentViewer: {
        payload: Prisma.$CommentViewerPayload<ExtArgs>
        fields: Prisma.CommentViewerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentViewerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentViewerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentViewerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentViewerPayload>
          }
          findFirst: {
            args: Prisma.CommentViewerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentViewerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentViewerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentViewerPayload>
          }
          findMany: {
            args: Prisma.CommentViewerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentViewerPayload>[]
          }
          create: {
            args: Prisma.CommentViewerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentViewerPayload>
          }
          createMany: {
            args: Prisma.CommentViewerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentViewerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentViewerPayload>[]
          }
          delete: {
            args: Prisma.CommentViewerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentViewerPayload>
          }
          update: {
            args: Prisma.CommentViewerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentViewerPayload>
          }
          deleteMany: {
            args: Prisma.CommentViewerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentViewerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentViewerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentViewerPayload>[]
          }
          upsert: {
            args: Prisma.CommentViewerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentViewerPayload>
          }
          aggregate: {
            args: Prisma.CommentViewerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentViewer>
          }
          groupBy: {
            args: Prisma.CommentViewerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentViewerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentViewerCountArgs<ExtArgs>
            result: $Utils.Optional<CommentViewerCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    users?: UsersOmit
    posts?: PostsOmit
    story?: StoryOmit
    like?: LikeOmit
    comment?: CommentOmit
    rePosts?: RePostsOmit
    attachment?: AttachmentOmit
    notification?: NotificationOmit
    messages?: MessagesOmit
    friends?: FriendsOmit
    followers?: FollowersOmit
    storyViewer?: StoryViewerOmit
    postsViewer?: PostsViewerOmit
    commentViewer?: CommentViewerOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    posts: number
    stories: number
    likes: number
    comments: number
    reposts: number
    notifications: number
    relatedNotifications: number
    messagesSent: number
    messagesReceived: number
    friends: number
    friendOf: number
    followers: number
    following: number
    storyViewers: number
    postViewers: number
    commentViewers: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | UsersCountOutputTypeCountPostsArgs
    stories?: boolean | UsersCountOutputTypeCountStoriesArgs
    likes?: boolean | UsersCountOutputTypeCountLikesArgs
    comments?: boolean | UsersCountOutputTypeCountCommentsArgs
    reposts?: boolean | UsersCountOutputTypeCountRepostsArgs
    notifications?: boolean | UsersCountOutputTypeCountNotificationsArgs
    relatedNotifications?: boolean | UsersCountOutputTypeCountRelatedNotificationsArgs
    messagesSent?: boolean | UsersCountOutputTypeCountMessagesSentArgs
    messagesReceived?: boolean | UsersCountOutputTypeCountMessagesReceivedArgs
    friends?: boolean | UsersCountOutputTypeCountFriendsArgs
    friendOf?: boolean | UsersCountOutputTypeCountFriendOfArgs
    followers?: boolean | UsersCountOutputTypeCountFollowersArgs
    following?: boolean | UsersCountOutputTypeCountFollowingArgs
    storyViewers?: boolean | UsersCountOutputTypeCountStoryViewersArgs
    postViewers?: boolean | UsersCountOutputTypeCountPostViewersArgs
    commentViewers?: boolean | UsersCountOutputTypeCountCommentViewersArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRepostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RePostsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRelatedNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMessagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMessagesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFriendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFriendOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFollowingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountStoryViewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryViewerWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPostViewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostsViewerWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCommentViewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentViewerWhereInput
  }


  /**
   * Count Type PostsCountOutputType
   */

  export type PostsCountOutputType = {
    comments: number
    likes: number
    reposts: number
    attachments: number
    viewers: number
    notifications: number
  }

  export type PostsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PostsCountOutputTypeCountCommentsArgs
    likes?: boolean | PostsCountOutputTypeCountLikesArgs
    reposts?: boolean | PostsCountOutputTypeCountRepostsArgs
    attachments?: boolean | PostsCountOutputTypeCountAttachmentsArgs
    viewers?: boolean | PostsCountOutputTypeCountViewersArgs
    notifications?: boolean | PostsCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsCountOutputType
     */
    select?: PostsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountRepostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RePostsWhereInput
  }

  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountViewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostsViewerWhereInput
  }

  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type StoryCountOutputType
   */

  export type StoryCountOutputType = {
    viewers: number
    likes: number
    comments: number
    attachments: number
    notifications: number
  }

  export type StoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viewers?: boolean | StoryCountOutputTypeCountViewersArgs
    likes?: boolean | StoryCountOutputTypeCountLikesArgs
    comments?: boolean | StoryCountOutputTypeCountCommentsArgs
    attachments?: boolean | StoryCountOutputTypeCountAttachmentsArgs
    notifications?: boolean | StoryCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryCountOutputType
     */
    select?: StoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeCountViewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryViewerWhereInput
  }

  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }

  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * StoryCountOutputType without action
   */
  export type StoryCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    viewers: number
    attachments: number
    notifications: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viewers?: boolean | CommentCountOutputTypeCountViewersArgs
    attachments?: boolean | CommentCountOutputTypeCountAttachmentsArgs
    notifications?: boolean | CommentCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountViewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentViewerWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    username: string | null
    fullname: string | null
    email: string | null
    password: string | null
    profile_image: string | null
    banner: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    username: string | null
    fullname: string | null
    email: string | null
    password: string | null
    profile_image: string | null
    banner: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    username: number
    fullname: number
    email: number
    password: number
    profile_image: number
    banner: number
    bio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    username?: true
    fullname?: true
    email?: true
    password?: true
    profile_image?: true
    banner?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    username?: true
    fullname?: true
    email?: true
    password?: true
    profile_image?: true
    banner?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    username?: true
    fullname?: true
    email?: true
    password?: true
    profile_image?: true
    banner?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image: string | null
    banner: string | null
    bio: string | null
    createdAt: Date
    updatedAt: Date
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    fullname?: boolean
    email?: boolean
    password?: boolean
    profile_image?: boolean
    banner?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | Users$postsArgs<ExtArgs>
    stories?: boolean | Users$storiesArgs<ExtArgs>
    likes?: boolean | Users$likesArgs<ExtArgs>
    comments?: boolean | Users$commentsArgs<ExtArgs>
    reposts?: boolean | Users$repostsArgs<ExtArgs>
    notifications?: boolean | Users$notificationsArgs<ExtArgs>
    relatedNotifications?: boolean | Users$relatedNotificationsArgs<ExtArgs>
    messagesSent?: boolean | Users$messagesSentArgs<ExtArgs>
    messagesReceived?: boolean | Users$messagesReceivedArgs<ExtArgs>
    friends?: boolean | Users$friendsArgs<ExtArgs>
    friendOf?: boolean | Users$friendOfArgs<ExtArgs>
    followers?: boolean | Users$followersArgs<ExtArgs>
    following?: boolean | Users$followingArgs<ExtArgs>
    storyViewers?: boolean | Users$storyViewersArgs<ExtArgs>
    postViewers?: boolean | Users$postViewersArgs<ExtArgs>
    commentViewers?: boolean | Users$commentViewersArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    fullname?: boolean
    email?: boolean
    password?: boolean
    profile_image?: boolean
    banner?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["users"]>

  export type UsersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    fullname?: boolean
    email?: boolean
    password?: boolean
    profile_image?: boolean
    banner?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    id?: boolean
    username?: boolean
    fullname?: boolean
    email?: boolean
    password?: boolean
    profile_image?: boolean
    banner?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "fullname" | "email" | "password" | "profile_image" | "banner" | "bio" | "createdAt" | "updatedAt", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Users$postsArgs<ExtArgs>
    stories?: boolean | Users$storiesArgs<ExtArgs>
    likes?: boolean | Users$likesArgs<ExtArgs>
    comments?: boolean | Users$commentsArgs<ExtArgs>
    reposts?: boolean | Users$repostsArgs<ExtArgs>
    notifications?: boolean | Users$notificationsArgs<ExtArgs>
    relatedNotifications?: boolean | Users$relatedNotificationsArgs<ExtArgs>
    messagesSent?: boolean | Users$messagesSentArgs<ExtArgs>
    messagesReceived?: boolean | Users$messagesReceivedArgs<ExtArgs>
    friends?: boolean | Users$friendsArgs<ExtArgs>
    friendOf?: boolean | Users$friendOfArgs<ExtArgs>
    followers?: boolean | Users$followersArgs<ExtArgs>
    following?: boolean | Users$followingArgs<ExtArgs>
    storyViewers?: boolean | Users$storyViewersArgs<ExtArgs>
    postViewers?: boolean | Users$postViewersArgs<ExtArgs>
    commentViewers?: boolean | Users$commentViewersArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UsersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      posts: Prisma.$PostsPayload<ExtArgs>[]
      stories: Prisma.$StoryPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      reposts: Prisma.$RePostsPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      relatedNotifications: Prisma.$NotificationPayload<ExtArgs>[]
      messagesSent: Prisma.$MessagesPayload<ExtArgs>[]
      messagesReceived: Prisma.$MessagesPayload<ExtArgs>[]
      friends: Prisma.$FriendsPayload<ExtArgs>[]
      friendOf: Prisma.$FriendsPayload<ExtArgs>[]
      followers: Prisma.$FollowersPayload<ExtArgs>[]
      following: Prisma.$FollowersPayload<ExtArgs>[]
      storyViewers: Prisma.$StoryViewerPayload<ExtArgs>[]
      postViewers: Prisma.$PostsViewerPayload<ExtArgs>[]
      commentViewers: Prisma.$CommentViewerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      fullname: string
      email: string
      password: string
      profile_image: string | null
      banner: string | null
      bio: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UsersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UsersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsersUpdateManyAndReturnArgs>(args: SelectSubset<T, UsersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Users$postsArgs<ExtArgs> = {}>(args?: Subset<T, Users$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stories<T extends Users$storiesArgs<ExtArgs> = {}>(args?: Subset<T, Users$storiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends Users$likesArgs<ExtArgs> = {}>(args?: Subset<T, Users$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Users$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Users$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reposts<T extends Users$repostsArgs<ExtArgs> = {}>(args?: Subset<T, Users$repostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RePostsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Users$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Users$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    relatedNotifications<T extends Users$relatedNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, Users$relatedNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messagesSent<T extends Users$messagesSentArgs<ExtArgs> = {}>(args?: Subset<T, Users$messagesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messagesReceived<T extends Users$messagesReceivedArgs<ExtArgs> = {}>(args?: Subset<T, Users$messagesReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    friends<T extends Users$friendsArgs<ExtArgs> = {}>(args?: Subset<T, Users$friendsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    friendOf<T extends Users$friendOfArgs<ExtArgs> = {}>(args?: Subset<T, Users$friendOfArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followers<T extends Users$followersArgs<ExtArgs> = {}>(args?: Subset<T, Users$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    following<T extends Users$followingArgs<ExtArgs> = {}>(args?: Subset<T, Users$followingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    storyViewers<T extends Users$storyViewersArgs<ExtArgs> = {}>(args?: Subset<T, Users$storyViewersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryViewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postViewers<T extends Users$postViewersArgs<ExtArgs> = {}>(args?: Subset<T, Users$postViewersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsViewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commentViewers<T extends Users$commentViewersArgs<ExtArgs> = {}>(args?: Subset<T, Users$commentViewersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentViewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'String'>
    readonly username: FieldRef<"Users", 'String'>
    readonly fullname: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly password: FieldRef<"Users", 'String'>
    readonly profile_image: FieldRef<"Users", 'String'>
    readonly banner: FieldRef<"Users", 'String'>
    readonly bio: FieldRef<"Users", 'String'>
    readonly createdAt: FieldRef<"Users", 'DateTime'>
    readonly updatedAt: FieldRef<"Users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users createManyAndReturn
   */
  export type UsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users updateManyAndReturn
   */
  export type UsersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.posts
   */
  export type Users$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    where?: PostsWhereInput
    orderBy?: PostsOrderByWithRelationInput | PostsOrderByWithRelationInput[]
    cursor?: PostsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * Users.stories
   */
  export type Users$storiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    where?: StoryWhereInput
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    cursor?: StoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Users.likes
   */
  export type Users$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Users.comments
   */
  export type Users$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Users.reposts
   */
  export type Users$repostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RePosts
     */
    select?: RePostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RePosts
     */
    omit?: RePostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RePostsInclude<ExtArgs> | null
    where?: RePostsWhereInput
    orderBy?: RePostsOrderByWithRelationInput | RePostsOrderByWithRelationInput[]
    cursor?: RePostsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RePostsScalarFieldEnum | RePostsScalarFieldEnum[]
  }

  /**
   * Users.notifications
   */
  export type Users$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Users.relatedNotifications
   */
  export type Users$relatedNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Users.messagesSent
   */
  export type Users$messagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    where?: MessagesWhereInput
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    cursor?: MessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Users.messagesReceived
   */
  export type Users$messagesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    where?: MessagesWhereInput
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    cursor?: MessagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Users.friends
   */
  export type Users$friendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    where?: FriendsWhereInput
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    cursor?: FriendsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Users.friendOf
   */
  export type Users$friendOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    where?: FriendsWhereInput
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    cursor?: FriendsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Users.followers
   */
  export type Users$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followers
     */
    select?: FollowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followers
     */
    omit?: FollowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowersInclude<ExtArgs> | null
    where?: FollowersWhereInput
    orderBy?: FollowersOrderByWithRelationInput | FollowersOrderByWithRelationInput[]
    cursor?: FollowersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowersScalarFieldEnum | FollowersScalarFieldEnum[]
  }

  /**
   * Users.following
   */
  export type Users$followingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followers
     */
    select?: FollowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followers
     */
    omit?: FollowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowersInclude<ExtArgs> | null
    where?: FollowersWhereInput
    orderBy?: FollowersOrderByWithRelationInput | FollowersOrderByWithRelationInput[]
    cursor?: FollowersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowersScalarFieldEnum | FollowersScalarFieldEnum[]
  }

  /**
   * Users.storyViewers
   */
  export type Users$storyViewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryViewer
     */
    select?: StoryViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryViewer
     */
    omit?: StoryViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryViewerInclude<ExtArgs> | null
    where?: StoryViewerWhereInput
    orderBy?: StoryViewerOrderByWithRelationInput | StoryViewerOrderByWithRelationInput[]
    cursor?: StoryViewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryViewerScalarFieldEnum | StoryViewerScalarFieldEnum[]
  }

  /**
   * Users.postViewers
   */
  export type Users$postViewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsViewer
     */
    select?: PostsViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsViewer
     */
    omit?: PostsViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsViewerInclude<ExtArgs> | null
    where?: PostsViewerWhereInput
    orderBy?: PostsViewerOrderByWithRelationInput | PostsViewerOrderByWithRelationInput[]
    cursor?: PostsViewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostsViewerScalarFieldEnum | PostsViewerScalarFieldEnum[]
  }

  /**
   * Users.commentViewers
   */
  export type Users$commentViewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentViewer
     */
    select?: CommentViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentViewer
     */
    omit?: CommentViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentViewerInclude<ExtArgs> | null
    where?: CommentViewerWhereInput
    orderBy?: CommentViewerOrderByWithRelationInput | CommentViewerOrderByWithRelationInput[]
    cursor?: CommentViewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentViewerScalarFieldEnum | CommentViewerScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model Posts
   */

  export type AggregatePosts = {
    _count: PostsCountAggregateOutputType | null
    _min: PostsMinAggregateOutputType | null
    _max: PostsMaxAggregateOutputType | null
  }

  export type PostsMinAggregateOutputType = {
    id: string | null
    usersId: string | null
    contentText: string | null
    contentImage: string | null
    mediaType: $Enums.MediaType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostsMaxAggregateOutputType = {
    id: string | null
    usersId: string | null
    contentText: string | null
    contentImage: string | null
    mediaType: $Enums.MediaType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostsCountAggregateOutputType = {
    id: number
    usersId: number
    contentText: number
    contentImage: number
    mediaType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostsMinAggregateInputType = {
    id?: true
    usersId?: true
    contentText?: true
    contentImage?: true
    mediaType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostsMaxAggregateInputType = {
    id?: true
    usersId?: true
    contentText?: true
    contentImage?: true
    mediaType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostsCountAggregateInputType = {
    id?: true
    usersId?: true
    contentText?: true
    contentImage?: true
    mediaType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to aggregate.
     */
    where?: PostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostsOrderByWithRelationInput | PostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostsMaxAggregateInputType
  }

  export type GetPostsAggregateType<T extends PostsAggregateArgs> = {
        [P in keyof T & keyof AggregatePosts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosts[P]>
      : GetScalarType<T[P], AggregatePosts[P]>
  }




  export type PostsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostsWhereInput
    orderBy?: PostsOrderByWithAggregationInput | PostsOrderByWithAggregationInput[]
    by: PostsScalarFieldEnum[] | PostsScalarFieldEnum
    having?: PostsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostsCountAggregateInputType | true
    _min?: PostsMinAggregateInputType
    _max?: PostsMaxAggregateInputType
  }

  export type PostsGroupByOutputType = {
    id: string
    usersId: string
    contentText: string | null
    contentImage: string | null
    mediaType: $Enums.MediaType
    createdAt: Date
    updatedAt: Date
    _count: PostsCountAggregateOutputType | null
    _min: PostsMinAggregateOutputType | null
    _max: PostsMaxAggregateOutputType | null
  }

  type GetPostsGroupByPayload<T extends PostsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostsGroupByOutputType[P]>
            : GetScalarType<T[P], PostsGroupByOutputType[P]>
        }
      >
    >


  export type PostsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    contentText?: boolean
    contentImage?: boolean
    mediaType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    comments?: boolean | Posts$commentsArgs<ExtArgs>
    likes?: boolean | Posts$likesArgs<ExtArgs>
    reposts?: boolean | Posts$repostsArgs<ExtArgs>
    attachments?: boolean | Posts$attachmentsArgs<ExtArgs>
    viewers?: boolean | Posts$viewersArgs<ExtArgs>
    notifications?: boolean | Posts$notificationsArgs<ExtArgs>
    _count?: boolean | PostsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posts"]>

  export type PostsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    contentText?: boolean
    contentImage?: boolean
    mediaType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posts"]>

  export type PostsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    contentText?: boolean
    contentImage?: boolean
    mediaType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posts"]>

  export type PostsSelectScalar = {
    id?: boolean
    usersId?: boolean
    contentText?: boolean
    contentImage?: boolean
    mediaType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usersId" | "contentText" | "contentImage" | "mediaType" | "createdAt" | "updatedAt", ExtArgs["result"]["posts"]>
  export type PostsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    comments?: boolean | Posts$commentsArgs<ExtArgs>
    likes?: boolean | Posts$likesArgs<ExtArgs>
    reposts?: boolean | Posts$repostsArgs<ExtArgs>
    attachments?: boolean | Posts$attachmentsArgs<ExtArgs>
    viewers?: boolean | Posts$viewersArgs<ExtArgs>
    notifications?: boolean | Posts$notificationsArgs<ExtArgs>
    _count?: boolean | PostsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type PostsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $PostsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Posts"
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
      reposts: Prisma.$RePostsPayload<ExtArgs>[]
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      viewers: Prisma.$PostsViewerPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usersId: string
      contentText: string | null
      contentImage: string | null
      mediaType: $Enums.MediaType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["posts"]>
    composites: {}
  }

  type PostsGetPayload<S extends boolean | null | undefined | PostsDefaultArgs> = $Result.GetResult<Prisma.$PostsPayload, S>

  type PostsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostsCountAggregateInputType | true
    }

  export interface PostsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Posts'], meta: { name: 'Posts' } }
    /**
     * Find zero or one Posts that matches the filter.
     * @param {PostsFindUniqueArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostsFindUniqueArgs>(args: SelectSubset<T, PostsFindUniqueArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Posts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostsFindUniqueOrThrowArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostsFindUniqueOrThrowArgs>(args: SelectSubset<T, PostsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsFindFirstArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostsFindFirstArgs>(args?: SelectSubset<T, PostsFindFirstArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Posts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsFindFirstOrThrowArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostsFindFirstOrThrowArgs>(args?: SelectSubset<T, PostsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.posts.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.posts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postsWithIdOnly = await prisma.posts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostsFindManyArgs>(args?: SelectSubset<T, PostsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Posts.
     * @param {PostsCreateArgs} args - Arguments to create a Posts.
     * @example
     * // Create one Posts
     * const Posts = await prisma.posts.create({
     *   data: {
     *     // ... data to create a Posts
     *   }
     * })
     * 
     */
    create<T extends PostsCreateArgs>(args: SelectSubset<T, PostsCreateArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostsCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const posts = await prisma.posts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostsCreateManyArgs>(args?: SelectSubset<T, PostsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostsCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const posts = await prisma.posts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postsWithIdOnly = await prisma.posts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostsCreateManyAndReturnArgs>(args?: SelectSubset<T, PostsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Posts.
     * @param {PostsDeleteArgs} args - Arguments to delete one Posts.
     * @example
     * // Delete one Posts
     * const Posts = await prisma.posts.delete({
     *   where: {
     *     // ... filter to delete one Posts
     *   }
     * })
     * 
     */
    delete<T extends PostsDeleteArgs>(args: SelectSubset<T, PostsDeleteArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Posts.
     * @param {PostsUpdateArgs} args - Arguments to update one Posts.
     * @example
     * // Update one Posts
     * const posts = await prisma.posts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostsUpdateArgs>(args: SelectSubset<T, PostsUpdateArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostsDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.posts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostsDeleteManyArgs>(args?: SelectSubset<T, PostsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const posts = await prisma.posts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostsUpdateManyArgs>(args: SelectSubset<T, PostsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostsUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const posts = await prisma.posts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postsWithIdOnly = await prisma.posts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostsUpdateManyAndReturnArgs>(args: SelectSubset<T, PostsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Posts.
     * @param {PostsUpsertArgs} args - Arguments to update or create a Posts.
     * @example
     * // Update or create a Posts
     * const posts = await prisma.posts.upsert({
     *   create: {
     *     // ... data to create a Posts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Posts we want to update
     *   }
     * })
     */
    upsert<T extends PostsUpsertArgs>(args: SelectSubset<T, PostsUpsertArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.posts.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostsCountArgs>(
      args?: Subset<T, PostsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostsAggregateArgs>(args: Subset<T, PostsAggregateArgs>): Prisma.PrismaPromise<GetPostsAggregateType<T>>

    /**
     * Group by Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostsGroupByArgs['orderBy'] }
        : { orderBy?: PostsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Posts model
   */
  readonly fields: PostsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Posts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comments<T extends Posts$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Posts$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends Posts$likesArgs<ExtArgs> = {}>(args?: Subset<T, Posts$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reposts<T extends Posts$repostsArgs<ExtArgs> = {}>(args?: Subset<T, Posts$repostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RePostsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends Posts$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Posts$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    viewers<T extends Posts$viewersArgs<ExtArgs> = {}>(args?: Subset<T, Posts$viewersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsViewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Posts$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Posts$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Posts model
   */
  interface PostsFieldRefs {
    readonly id: FieldRef<"Posts", 'String'>
    readonly usersId: FieldRef<"Posts", 'String'>
    readonly contentText: FieldRef<"Posts", 'String'>
    readonly contentImage: FieldRef<"Posts", 'String'>
    readonly mediaType: FieldRef<"Posts", 'MediaType'>
    readonly createdAt: FieldRef<"Posts", 'DateTime'>
    readonly updatedAt: FieldRef<"Posts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Posts findUnique
   */
  export type PostsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where: PostsWhereUniqueInput
  }

  /**
   * Posts findUniqueOrThrow
   */
  export type PostsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where: PostsWhereUniqueInput
  }

  /**
   * Posts findFirst
   */
  export type PostsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostsOrderByWithRelationInput | PostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * Posts findFirstOrThrow
   */
  export type PostsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostsOrderByWithRelationInput | PostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * Posts findMany
   */
  export type PostsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostsOrderByWithRelationInput | PostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * Posts create
   */
  export type PostsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * The data needed to create a Posts.
     */
    data: XOR<PostsCreateInput, PostsUncheckedCreateInput>
  }

  /**
   * Posts createMany
   */
  export type PostsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostsCreateManyInput | PostsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Posts createManyAndReturn
   */
  export type PostsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostsCreateManyInput | PostsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Posts update
   */
  export type PostsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * The data needed to update a Posts.
     */
    data: XOR<PostsUpdateInput, PostsUncheckedUpdateInput>
    /**
     * Choose, which Posts to update.
     */
    where: PostsWhereUniqueInput
  }

  /**
   * Posts updateMany
   */
  export type PostsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostsUpdateManyMutationInput, PostsUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostsWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Posts updateManyAndReturn
   */
  export type PostsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostsUpdateManyMutationInput, PostsUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostsWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Posts upsert
   */
  export type PostsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * The filter to search for the Posts to update in case it exists.
     */
    where: PostsWhereUniqueInput
    /**
     * In case the Posts found by the `where` argument doesn't exist, create a new Posts with this data.
     */
    create: XOR<PostsCreateInput, PostsUncheckedCreateInput>
    /**
     * In case the Posts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostsUpdateInput, PostsUncheckedUpdateInput>
  }

  /**
   * Posts delete
   */
  export type PostsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter which Posts to delete.
     */
    where: PostsWhereUniqueInput
  }

  /**
   * Posts deleteMany
   */
  export type PostsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostsWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Posts.comments
   */
  export type Posts$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Posts.likes
   */
  export type Posts$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Posts.reposts
   */
  export type Posts$repostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RePosts
     */
    select?: RePostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RePosts
     */
    omit?: RePostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RePostsInclude<ExtArgs> | null
    where?: RePostsWhereInput
    orderBy?: RePostsOrderByWithRelationInput | RePostsOrderByWithRelationInput[]
    cursor?: RePostsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RePostsScalarFieldEnum | RePostsScalarFieldEnum[]
  }

  /**
   * Posts.attachments
   */
  export type Posts$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Posts.viewers
   */
  export type Posts$viewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsViewer
     */
    select?: PostsViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsViewer
     */
    omit?: PostsViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsViewerInclude<ExtArgs> | null
    where?: PostsViewerWhereInput
    orderBy?: PostsViewerOrderByWithRelationInput | PostsViewerOrderByWithRelationInput[]
    cursor?: PostsViewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostsViewerScalarFieldEnum | PostsViewerScalarFieldEnum[]
  }

  /**
   * Posts.notifications
   */
  export type Posts$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Posts without action
   */
  export type PostsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
  }


  /**
   * Model Story
   */

  export type AggregateStory = {
    _count: StoryCountAggregateOutputType | null
    _min: StoryMinAggregateOutputType | null
    _max: StoryMaxAggregateOutputType | null
  }

  export type StoryMinAggregateOutputType = {
    id: string | null
    usersId: string | null
    contentText: string | null
    contentMedia: string | null
    mediaType: $Enums.MediaType | null
    createdAt: Date | null
    expirationTime: Date | null
  }

  export type StoryMaxAggregateOutputType = {
    id: string | null
    usersId: string | null
    contentText: string | null
    contentMedia: string | null
    mediaType: $Enums.MediaType | null
    createdAt: Date | null
    expirationTime: Date | null
  }

  export type StoryCountAggregateOutputType = {
    id: number
    usersId: number
    contentText: number
    contentMedia: number
    mediaType: number
    createdAt: number
    expirationTime: number
    _all: number
  }


  export type StoryMinAggregateInputType = {
    id?: true
    usersId?: true
    contentText?: true
    contentMedia?: true
    mediaType?: true
    createdAt?: true
    expirationTime?: true
  }

  export type StoryMaxAggregateInputType = {
    id?: true
    usersId?: true
    contentText?: true
    contentMedia?: true
    mediaType?: true
    createdAt?: true
    expirationTime?: true
  }

  export type StoryCountAggregateInputType = {
    id?: true
    usersId?: true
    contentText?: true
    contentMedia?: true
    mediaType?: true
    createdAt?: true
    expirationTime?: true
    _all?: true
  }

  export type StoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Story to aggregate.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stories
    **/
    _count?: true | StoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryMaxAggregateInputType
  }

  export type GetStoryAggregateType<T extends StoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStory[P]>
      : GetScalarType<T[P], AggregateStory[P]>
  }




  export type StoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryWhereInput
    orderBy?: StoryOrderByWithAggregationInput | StoryOrderByWithAggregationInput[]
    by: StoryScalarFieldEnum[] | StoryScalarFieldEnum
    having?: StoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryCountAggregateInputType | true
    _min?: StoryMinAggregateInputType
    _max?: StoryMaxAggregateInputType
  }

  export type StoryGroupByOutputType = {
    id: string
    usersId: string
    contentText: string | null
    contentMedia: string | null
    mediaType: $Enums.MediaType
    createdAt: Date
    expirationTime: Date
    _count: StoryCountAggregateOutputType | null
    _min: StoryMinAggregateOutputType | null
    _max: StoryMaxAggregateOutputType | null
  }

  type GetStoryGroupByPayload<T extends StoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryGroupByOutputType[P]>
            : GetScalarType<T[P], StoryGroupByOutputType[P]>
        }
      >
    >


  export type StorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    contentText?: boolean
    contentMedia?: boolean
    mediaType?: boolean
    createdAt?: boolean
    expirationTime?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    viewers?: boolean | Story$viewersArgs<ExtArgs>
    likes?: boolean | Story$likesArgs<ExtArgs>
    comments?: boolean | Story$commentsArgs<ExtArgs>
    attachments?: boolean | Story$attachmentsArgs<ExtArgs>
    notifications?: boolean | Story$notificationsArgs<ExtArgs>
    _count?: boolean | StoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["story"]>

  export type StorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    contentText?: boolean
    contentMedia?: boolean
    mediaType?: boolean
    createdAt?: boolean
    expirationTime?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["story"]>

  export type StorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    contentText?: boolean
    contentMedia?: boolean
    mediaType?: boolean
    createdAt?: boolean
    expirationTime?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["story"]>

  export type StorySelectScalar = {
    id?: boolean
    usersId?: boolean
    contentText?: boolean
    contentMedia?: boolean
    mediaType?: boolean
    createdAt?: boolean
    expirationTime?: boolean
  }

  export type StoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usersId" | "contentText" | "contentMedia" | "mediaType" | "createdAt" | "expirationTime", ExtArgs["result"]["story"]>
  export type StoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    viewers?: boolean | Story$viewersArgs<ExtArgs>
    likes?: boolean | Story$likesArgs<ExtArgs>
    comments?: boolean | Story$commentsArgs<ExtArgs>
    attachments?: boolean | Story$attachmentsArgs<ExtArgs>
    notifications?: boolean | Story$notificationsArgs<ExtArgs>
    _count?: boolean | StoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type StoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $StoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Story"
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>
      viewers: Prisma.$StoryViewerPayload<ExtArgs>[]
      likes: Prisma.$LikePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usersId: string
      contentText: string | null
      contentMedia: string | null
      mediaType: $Enums.MediaType
      createdAt: Date
      expirationTime: Date
    }, ExtArgs["result"]["story"]>
    composites: {}
  }

  type StoryGetPayload<S extends boolean | null | undefined | StoryDefaultArgs> = $Result.GetResult<Prisma.$StoryPayload, S>

  type StoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoryCountAggregateInputType | true
    }

  export interface StoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Story'], meta: { name: 'Story' } }
    /**
     * Find zero or one Story that matches the filter.
     * @param {StoryFindUniqueArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryFindUniqueArgs>(args: SelectSubset<T, StoryFindUniqueArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Story that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoryFindUniqueOrThrowArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Story that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindFirstArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryFindFirstArgs>(args?: SelectSubset<T, StoryFindFirstArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Story that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindFirstOrThrowArgs} args - Arguments to find a Story
     * @example
     * // Get one Story
     * const story = await prisma.story.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stories
     * const stories = await prisma.story.findMany()
     * 
     * // Get first 10 Stories
     * const stories = await prisma.story.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyWithIdOnly = await prisma.story.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryFindManyArgs>(args?: SelectSubset<T, StoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Story.
     * @param {StoryCreateArgs} args - Arguments to create a Story.
     * @example
     * // Create one Story
     * const Story = await prisma.story.create({
     *   data: {
     *     // ... data to create a Story
     *   }
     * })
     * 
     */
    create<T extends StoryCreateArgs>(args: SelectSubset<T, StoryCreateArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stories.
     * @param {StoryCreateManyArgs} args - Arguments to create many Stories.
     * @example
     * // Create many Stories
     * const story = await prisma.story.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryCreateManyArgs>(args?: SelectSubset<T, StoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stories and returns the data saved in the database.
     * @param {StoryCreateManyAndReturnArgs} args - Arguments to create many Stories.
     * @example
     * // Create many Stories
     * const story = await prisma.story.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stories and only return the `id`
     * const storyWithIdOnly = await prisma.story.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Story.
     * @param {StoryDeleteArgs} args - Arguments to delete one Story.
     * @example
     * // Delete one Story
     * const Story = await prisma.story.delete({
     *   where: {
     *     // ... filter to delete one Story
     *   }
     * })
     * 
     */
    delete<T extends StoryDeleteArgs>(args: SelectSubset<T, StoryDeleteArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Story.
     * @param {StoryUpdateArgs} args - Arguments to update one Story.
     * @example
     * // Update one Story
     * const story = await prisma.story.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryUpdateArgs>(args: SelectSubset<T, StoryUpdateArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stories.
     * @param {StoryDeleteManyArgs} args - Arguments to filter Stories to delete.
     * @example
     * // Delete a few Stories
     * const { count } = await prisma.story.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryDeleteManyArgs>(args?: SelectSubset<T, StoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stories
     * const story = await prisma.story.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryUpdateManyArgs>(args: SelectSubset<T, StoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stories and returns the data updated in the database.
     * @param {StoryUpdateManyAndReturnArgs} args - Arguments to update many Stories.
     * @example
     * // Update many Stories
     * const story = await prisma.story.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stories and only return the `id`
     * const storyWithIdOnly = await prisma.story.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoryUpdateManyAndReturnArgs>(args: SelectSubset<T, StoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Story.
     * @param {StoryUpsertArgs} args - Arguments to update or create a Story.
     * @example
     * // Update or create a Story
     * const story = await prisma.story.upsert({
     *   create: {
     *     // ... data to create a Story
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Story we want to update
     *   }
     * })
     */
    upsert<T extends StoryUpsertArgs>(args: SelectSubset<T, StoryUpsertArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryCountArgs} args - Arguments to filter Stories to count.
     * @example
     * // Count the number of Stories
     * const count = await prisma.story.count({
     *   where: {
     *     // ... the filter for the Stories we want to count
     *   }
     * })
    **/
    count<T extends StoryCountArgs>(
      args?: Subset<T, StoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryAggregateArgs>(args: Subset<T, StoryAggregateArgs>): Prisma.PrismaPromise<GetStoryAggregateType<T>>

    /**
     * Group by Story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryGroupByArgs['orderBy'] }
        : { orderBy?: StoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Story model
   */
  readonly fields: StoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Story.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    viewers<T extends Story$viewersArgs<ExtArgs> = {}>(args?: Subset<T, Story$viewersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryViewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    likes<T extends Story$likesArgs<ExtArgs> = {}>(args?: Subset<T, Story$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Story$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Story$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends Story$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Story$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Story$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Story$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Story model
   */
  interface StoryFieldRefs {
    readonly id: FieldRef<"Story", 'String'>
    readonly usersId: FieldRef<"Story", 'String'>
    readonly contentText: FieldRef<"Story", 'String'>
    readonly contentMedia: FieldRef<"Story", 'String'>
    readonly mediaType: FieldRef<"Story", 'MediaType'>
    readonly createdAt: FieldRef<"Story", 'DateTime'>
    readonly expirationTime: FieldRef<"Story", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Story findUnique
   */
  export type StoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story findUniqueOrThrow
   */
  export type StoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story findFirst
   */
  export type StoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stories.
     */
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story findFirstOrThrow
   */
  export type StoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Story to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stories.
     */
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story findMany
   */
  export type StoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter, which Stories to fetch.
     */
    where?: StoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stories to fetch.
     */
    orderBy?: StoryOrderByWithRelationInput | StoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stories.
     */
    cursor?: StoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stories.
     */
    skip?: number
    distinct?: StoryScalarFieldEnum | StoryScalarFieldEnum[]
  }

  /**
   * Story create
   */
  export type StoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Story.
     */
    data: XOR<StoryCreateInput, StoryUncheckedCreateInput>
  }

  /**
   * Story createMany
   */
  export type StoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stories.
     */
    data: StoryCreateManyInput | StoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Story createManyAndReturn
   */
  export type StoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * The data used to create many Stories.
     */
    data: StoryCreateManyInput | StoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Story update
   */
  export type StoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Story.
     */
    data: XOR<StoryUpdateInput, StoryUncheckedUpdateInput>
    /**
     * Choose, which Story to update.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story updateMany
   */
  export type StoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stories.
     */
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyInput>
    /**
     * Filter which Stories to update
     */
    where?: StoryWhereInput
    /**
     * Limit how many Stories to update.
     */
    limit?: number
  }

  /**
   * Story updateManyAndReturn
   */
  export type StoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * The data used to update Stories.
     */
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyInput>
    /**
     * Filter which Stories to update
     */
    where?: StoryWhereInput
    /**
     * Limit how many Stories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Story upsert
   */
  export type StoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Story to update in case it exists.
     */
    where: StoryWhereUniqueInput
    /**
     * In case the Story found by the `where` argument doesn't exist, create a new Story with this data.
     */
    create: XOR<StoryCreateInput, StoryUncheckedCreateInput>
    /**
     * In case the Story was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryUpdateInput, StoryUncheckedUpdateInput>
  }

  /**
   * Story delete
   */
  export type StoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    /**
     * Filter which Story to delete.
     */
    where: StoryWhereUniqueInput
  }

  /**
   * Story deleteMany
   */
  export type StoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stories to delete
     */
    where?: StoryWhereInput
    /**
     * Limit how many Stories to delete.
     */
    limit?: number
  }

  /**
   * Story.viewers
   */
  export type Story$viewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryViewer
     */
    select?: StoryViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryViewer
     */
    omit?: StoryViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryViewerInclude<ExtArgs> | null
    where?: StoryViewerWhereInput
    orderBy?: StoryViewerOrderByWithRelationInput | StoryViewerOrderByWithRelationInput[]
    cursor?: StoryViewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoryViewerScalarFieldEnum | StoryViewerScalarFieldEnum[]
  }

  /**
   * Story.likes
   */
  export type Story$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Story.comments
   */
  export type Story$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Story.attachments
   */
  export type Story$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Story.notifications
   */
  export type Story$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Story without action
   */
  export type StoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
  }


  /**
   * Model Like
   */

  export type AggregateLike = {
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  export type LikeMinAggregateOutputType = {
    id: string | null
    usersId: string | null
    postsId: string | null
    storyId: string | null
    createdAt: Date | null
  }

  export type LikeMaxAggregateOutputType = {
    id: string | null
    usersId: string | null
    postsId: string | null
    storyId: string | null
    createdAt: Date | null
  }

  export type LikeCountAggregateOutputType = {
    id: number
    usersId: number
    postsId: number
    storyId: number
    createdAt: number
    _all: number
  }


  export type LikeMinAggregateInputType = {
    id?: true
    usersId?: true
    postsId?: true
    storyId?: true
    createdAt?: true
  }

  export type LikeMaxAggregateInputType = {
    id?: true
    usersId?: true
    postsId?: true
    storyId?: true
    createdAt?: true
  }

  export type LikeCountAggregateInputType = {
    id?: true
    usersId?: true
    postsId?: true
    storyId?: true
    createdAt?: true
    _all?: true
  }

  export type LikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Like to aggregate.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeMaxAggregateInputType
  }

  export type GetLikeAggregateType<T extends LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLike[P]>
      : GetScalarType<T[P], AggregateLike[P]>
  }




  export type LikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
    orderBy?: LikeOrderByWithAggregationInput | LikeOrderByWithAggregationInput[]
    by: LikeScalarFieldEnum[] | LikeScalarFieldEnum
    having?: LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCountAggregateInputType | true
    _min?: LikeMinAggregateInputType
    _max?: LikeMaxAggregateInputType
  }

  export type LikeGroupByOutputType = {
    id: string
    usersId: string
    postsId: string | null
    storyId: string | null
    createdAt: Date
    _count: LikeCountAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  type GetLikeGroupByPayload<T extends LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeGroupByOutputType[P]>
            : GetScalarType<T[P], LikeGroupByOutputType[P]>
        }
      >
    >


  export type LikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    postsId?: boolean
    storyId?: boolean
    createdAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    posts?: boolean | Like$postsArgs<ExtArgs>
    story?: boolean | Like$storyArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    postsId?: boolean
    storyId?: boolean
    createdAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    posts?: boolean | Like$postsArgs<ExtArgs>
    story?: boolean | Like$storyArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    postsId?: boolean
    storyId?: boolean
    createdAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    posts?: boolean | Like$postsArgs<ExtArgs>
    story?: boolean | Like$storyArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectScalar = {
    id?: boolean
    usersId?: boolean
    postsId?: boolean
    storyId?: boolean
    createdAt?: boolean
  }

  export type LikeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usersId" | "postsId" | "storyId" | "createdAt", ExtArgs["result"]["like"]>
  export type LikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    posts?: boolean | Like$postsArgs<ExtArgs>
    story?: boolean | Like$storyArgs<ExtArgs>
  }
  export type LikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    posts?: boolean | Like$postsArgs<ExtArgs>
    story?: boolean | Like$storyArgs<ExtArgs>
  }
  export type LikeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    posts?: boolean | Like$postsArgs<ExtArgs>
    story?: boolean | Like$storyArgs<ExtArgs>
  }

  export type $LikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Like"
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>
      posts: Prisma.$PostsPayload<ExtArgs> | null
      story: Prisma.$StoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usersId: string
      postsId: string | null
      storyId: string | null
      createdAt: Date
    }, ExtArgs["result"]["like"]>
    composites: {}
  }

  type LikeGetPayload<S extends boolean | null | undefined | LikeDefaultArgs> = $Result.GetResult<Prisma.$LikePayload, S>

  type LikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LikeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LikeCountAggregateInputType | true
    }

  export interface LikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Like'], meta: { name: 'Like' } }
    /**
     * Find zero or one Like that matches the filter.
     * @param {LikeFindUniqueArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LikeFindUniqueArgs>(args: SelectSubset<T, LikeFindUniqueArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Like that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LikeFindUniqueOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LikeFindUniqueOrThrowArgs>(args: SelectSubset<T, LikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LikeFindFirstArgs>(args?: SelectSubset<T, LikeFindFirstArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LikeFindFirstOrThrowArgs>(args?: SelectSubset<T, LikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.like.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeWithIdOnly = await prisma.like.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LikeFindManyArgs>(args?: SelectSubset<T, LikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Like.
     * @param {LikeCreateArgs} args - Arguments to create a Like.
     * @example
     * // Create one Like
     * const Like = await prisma.like.create({
     *   data: {
     *     // ... data to create a Like
     *   }
     * })
     * 
     */
    create<T extends LikeCreateArgs>(args: SelectSubset<T, LikeCreateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Likes.
     * @param {LikeCreateManyArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LikeCreateManyArgs>(args?: SelectSubset<T, LikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Likes and returns the data saved in the database.
     * @param {LikeCreateManyAndReturnArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const like = await prisma.like.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Likes and only return the `id`
     * const likeWithIdOnly = await prisma.like.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LikeCreateManyAndReturnArgs>(args?: SelectSubset<T, LikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Like.
     * @param {LikeDeleteArgs} args - Arguments to delete one Like.
     * @example
     * // Delete one Like
     * const Like = await prisma.like.delete({
     *   where: {
     *     // ... filter to delete one Like
     *   }
     * })
     * 
     */
    delete<T extends LikeDeleteArgs>(args: SelectSubset<T, LikeDeleteArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Like.
     * @param {LikeUpdateArgs} args - Arguments to update one Like.
     * @example
     * // Update one Like
     * const like = await prisma.like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LikeUpdateArgs>(args: SelectSubset<T, LikeUpdateArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Likes.
     * @param {LikeDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LikeDeleteManyArgs>(args?: SelectSubset<T, LikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LikeUpdateManyArgs>(args: SelectSubset<T, LikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes and returns the data updated in the database.
     * @param {LikeUpdateManyAndReturnArgs} args - Arguments to update many Likes.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Likes and only return the `id`
     * const likeWithIdOnly = await prisma.like.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LikeUpdateManyAndReturnArgs>(args: SelectSubset<T, LikeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Like.
     * @param {LikeUpsertArgs} args - Arguments to update or create a Like.
     * @example
     * // Update or create a Like
     * const like = await prisma.like.upsert({
     *   create: {
     *     // ... data to create a Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Like we want to update
     *   }
     * })
     */
    upsert<T extends LikeUpsertArgs>(args: SelectSubset<T, LikeUpsertArgs<ExtArgs>>): Prisma__LikeClient<$Result.GetResult<Prisma.$LikePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.like.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikeCountArgs>(
      args?: Subset<T, LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeAggregateArgs>(args: Subset<T, LikeAggregateArgs>): Prisma.PrismaPromise<GetLikeAggregateType<T>>

    /**
     * Group by Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeGroupByArgs['orderBy'] }
        : { orderBy?: LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Like model
   */
  readonly fields: LikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    posts<T extends Like$postsArgs<ExtArgs> = {}>(args?: Subset<T, Like$postsArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    story<T extends Like$storyArgs<ExtArgs> = {}>(args?: Subset<T, Like$storyArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Like model
   */
  interface LikeFieldRefs {
    readonly id: FieldRef<"Like", 'String'>
    readonly usersId: FieldRef<"Like", 'String'>
    readonly postsId: FieldRef<"Like", 'String'>
    readonly storyId: FieldRef<"Like", 'String'>
    readonly createdAt: FieldRef<"Like", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Like findUnique
   */
  export type LikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findUniqueOrThrow
   */
  export type LikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findFirst
   */
  export type LikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findFirstOrThrow
   */
  export type LikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like findMany
   */
  export type LikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: LikeOrderByWithRelationInput | LikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: LikeScalarFieldEnum | LikeScalarFieldEnum[]
  }

  /**
   * Like create
   */
  export type LikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to create a Like.
     */
    data: XOR<LikeCreateInput, LikeUncheckedCreateInput>
  }

  /**
   * Like createMany
   */
  export type LikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Like createManyAndReturn
   */
  export type LikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * The data used to create many Likes.
     */
    data: LikeCreateManyInput | LikeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Like update
   */
  export type LikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to update a Like.
     */
    data: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    /**
     * Choose, which Like to update.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like updateMany
   */
  export type LikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to update.
     */
    limit?: number
  }

  /**
   * Like updateManyAndReturn
   */
  export type LikeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Like upsert
   */
  export type LikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The filter to search for the Like to update in case it exists.
     */
    where: LikeWhereUniqueInput
    /**
     * In case the Like found by the `where` argument doesn't exist, create a new Like with this data.
     */
    create: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    /**
     * In case the Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
  }

  /**
   * Like delete
   */
  export type LikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter which Like to delete.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like deleteMany
   */
  export type LikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikeWhereInput
    /**
     * Limit how many Likes to delete.
     */
    limit?: number
  }

  /**
   * Like.posts
   */
  export type Like$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    where?: PostsWhereInput
  }

  /**
   * Like.story
   */
  export type Like$storyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    where?: StoryWhereInput
  }

  /**
   * Like without action
   */
  export type LikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Like
     */
    omit?: LikeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LikeInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    usersId: string | null
    postsId: string | null
    storyId: string | null
    content: string | null
    mediaUrl: string | null
    mediaType: $Enums.MediaType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    usersId: string | null
    postsId: string | null
    storyId: string | null
    content: string | null
    mediaUrl: string | null
    mediaType: $Enums.MediaType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    usersId: number
    postsId: number
    storyId: number
    content: number
    mediaUrl: number
    mediaType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    usersId?: true
    postsId?: true
    storyId?: true
    content?: true
    mediaUrl?: true
    mediaType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    usersId?: true
    postsId?: true
    storyId?: true
    content?: true
    mediaUrl?: true
    mediaType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    usersId?: true
    postsId?: true
    storyId?: true
    content?: true
    mediaUrl?: true
    mediaType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    usersId: string
    postsId: string | null
    storyId: string | null
    content: string
    mediaUrl: string | null
    mediaType: $Enums.MediaType
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    postsId?: boolean
    storyId?: boolean
    content?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    posts?: boolean | Comment$postsArgs<ExtArgs>
    story?: boolean | Comment$storyArgs<ExtArgs>
    viewers?: boolean | Comment$viewersArgs<ExtArgs>
    attachments?: boolean | Comment$attachmentsArgs<ExtArgs>
    notifications?: boolean | Comment$notificationsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    postsId?: boolean
    storyId?: boolean
    content?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    posts?: boolean | Comment$postsArgs<ExtArgs>
    story?: boolean | Comment$storyArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    postsId?: boolean
    storyId?: boolean
    content?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    posts?: boolean | Comment$postsArgs<ExtArgs>
    story?: boolean | Comment$storyArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    usersId?: boolean
    postsId?: boolean
    storyId?: boolean
    content?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usersId" | "postsId" | "storyId" | "content" | "mediaUrl" | "mediaType" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    posts?: boolean | Comment$postsArgs<ExtArgs>
    story?: boolean | Comment$storyArgs<ExtArgs>
    viewers?: boolean | Comment$viewersArgs<ExtArgs>
    attachments?: boolean | Comment$attachmentsArgs<ExtArgs>
    notifications?: boolean | Comment$notificationsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    posts?: boolean | Comment$postsArgs<ExtArgs>
    story?: boolean | Comment$storyArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    posts?: boolean | Comment$postsArgs<ExtArgs>
    story?: boolean | Comment$storyArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>
      posts: Prisma.$PostsPayload<ExtArgs> | null
      story: Prisma.$StoryPayload<ExtArgs> | null
      viewers: Prisma.$CommentViewerPayload<ExtArgs>[]
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usersId: string
      postsId: string | null
      storyId: string | null
      content: string
      mediaUrl: string | null
      mediaType: $Enums.MediaType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    posts<T extends Comment$postsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$postsArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    story<T extends Comment$storyArgs<ExtArgs> = {}>(args?: Subset<T, Comment$storyArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    viewers<T extends Comment$viewersArgs<ExtArgs> = {}>(args?: Subset<T, Comment$viewersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentViewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends Comment$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Comment$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly usersId: FieldRef<"Comment", 'String'>
    readonly postsId: FieldRef<"Comment", 'String'>
    readonly storyId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly mediaUrl: FieldRef<"Comment", 'String'>
    readonly mediaType: FieldRef<"Comment", 'MediaType'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.posts
   */
  export type Comment$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    where?: PostsWhereInput
  }

  /**
   * Comment.story
   */
  export type Comment$storyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    where?: StoryWhereInput
  }

  /**
   * Comment.viewers
   */
  export type Comment$viewersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentViewer
     */
    select?: CommentViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentViewer
     */
    omit?: CommentViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentViewerInclude<ExtArgs> | null
    where?: CommentViewerWhereInput
    orderBy?: CommentViewerOrderByWithRelationInput | CommentViewerOrderByWithRelationInput[]
    cursor?: CommentViewerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentViewerScalarFieldEnum | CommentViewerScalarFieldEnum[]
  }

  /**
   * Comment.attachments
   */
  export type Comment$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Comment.notifications
   */
  export type Comment$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model RePosts
   */

  export type AggregateRePosts = {
    _count: RePostsCountAggregateOutputType | null
    _min: RePostsMinAggregateOutputType | null
    _max: RePostsMaxAggregateOutputType | null
  }

  export type RePostsMinAggregateOutputType = {
    id: string | null
    usersId: string | null
    originalPostsId: string | null
    createdAt: Date | null
  }

  export type RePostsMaxAggregateOutputType = {
    id: string | null
    usersId: string | null
    originalPostsId: string | null
    createdAt: Date | null
  }

  export type RePostsCountAggregateOutputType = {
    id: number
    usersId: number
    originalPostsId: number
    createdAt: number
    _all: number
  }


  export type RePostsMinAggregateInputType = {
    id?: true
    usersId?: true
    originalPostsId?: true
    createdAt?: true
  }

  export type RePostsMaxAggregateInputType = {
    id?: true
    usersId?: true
    originalPostsId?: true
    createdAt?: true
  }

  export type RePostsCountAggregateInputType = {
    id?: true
    usersId?: true
    originalPostsId?: true
    createdAt?: true
    _all?: true
  }

  export type RePostsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RePosts to aggregate.
     */
    where?: RePostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RePosts to fetch.
     */
    orderBy?: RePostsOrderByWithRelationInput | RePostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RePostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RePosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RePosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RePosts
    **/
    _count?: true | RePostsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RePostsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RePostsMaxAggregateInputType
  }

  export type GetRePostsAggregateType<T extends RePostsAggregateArgs> = {
        [P in keyof T & keyof AggregateRePosts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRePosts[P]>
      : GetScalarType<T[P], AggregateRePosts[P]>
  }




  export type RePostsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RePostsWhereInput
    orderBy?: RePostsOrderByWithAggregationInput | RePostsOrderByWithAggregationInput[]
    by: RePostsScalarFieldEnum[] | RePostsScalarFieldEnum
    having?: RePostsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RePostsCountAggregateInputType | true
    _min?: RePostsMinAggregateInputType
    _max?: RePostsMaxAggregateInputType
  }

  export type RePostsGroupByOutputType = {
    id: string
    usersId: string
    originalPostsId: string
    createdAt: Date
    _count: RePostsCountAggregateOutputType | null
    _min: RePostsMinAggregateOutputType | null
    _max: RePostsMaxAggregateOutputType | null
  }

  type GetRePostsGroupByPayload<T extends RePostsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RePostsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RePostsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RePostsGroupByOutputType[P]>
            : GetScalarType<T[P], RePostsGroupByOutputType[P]>
        }
      >
    >


  export type RePostsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    originalPostsId?: boolean
    createdAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    originalPosts?: boolean | PostsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rePosts"]>

  export type RePostsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    originalPostsId?: boolean
    createdAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    originalPosts?: boolean | PostsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rePosts"]>

  export type RePostsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    originalPostsId?: boolean
    createdAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    originalPosts?: boolean | PostsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rePosts"]>

  export type RePostsSelectScalar = {
    id?: boolean
    usersId?: boolean
    originalPostsId?: boolean
    createdAt?: boolean
  }

  export type RePostsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usersId" | "originalPostsId" | "createdAt", ExtArgs["result"]["rePosts"]>
  export type RePostsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    originalPosts?: boolean | PostsDefaultArgs<ExtArgs>
  }
  export type RePostsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    originalPosts?: boolean | PostsDefaultArgs<ExtArgs>
  }
  export type RePostsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    originalPosts?: boolean | PostsDefaultArgs<ExtArgs>
  }

  export type $RePostsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RePosts"
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>
      originalPosts: Prisma.$PostsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usersId: string
      originalPostsId: string
      createdAt: Date
    }, ExtArgs["result"]["rePosts"]>
    composites: {}
  }

  type RePostsGetPayload<S extends boolean | null | undefined | RePostsDefaultArgs> = $Result.GetResult<Prisma.$RePostsPayload, S>

  type RePostsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RePostsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RePostsCountAggregateInputType | true
    }

  export interface RePostsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RePosts'], meta: { name: 'RePosts' } }
    /**
     * Find zero or one RePosts that matches the filter.
     * @param {RePostsFindUniqueArgs} args - Arguments to find a RePosts
     * @example
     * // Get one RePosts
     * const rePosts = await prisma.rePosts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RePostsFindUniqueArgs>(args: SelectSubset<T, RePostsFindUniqueArgs<ExtArgs>>): Prisma__RePostsClient<$Result.GetResult<Prisma.$RePostsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RePosts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RePostsFindUniqueOrThrowArgs} args - Arguments to find a RePosts
     * @example
     * // Get one RePosts
     * const rePosts = await prisma.rePosts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RePostsFindUniqueOrThrowArgs>(args: SelectSubset<T, RePostsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RePostsClient<$Result.GetResult<Prisma.$RePostsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RePosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RePostsFindFirstArgs} args - Arguments to find a RePosts
     * @example
     * // Get one RePosts
     * const rePosts = await prisma.rePosts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RePostsFindFirstArgs>(args?: SelectSubset<T, RePostsFindFirstArgs<ExtArgs>>): Prisma__RePostsClient<$Result.GetResult<Prisma.$RePostsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RePosts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RePostsFindFirstOrThrowArgs} args - Arguments to find a RePosts
     * @example
     * // Get one RePosts
     * const rePosts = await prisma.rePosts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RePostsFindFirstOrThrowArgs>(args?: SelectSubset<T, RePostsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RePostsClient<$Result.GetResult<Prisma.$RePostsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RePosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RePostsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RePosts
     * const rePosts = await prisma.rePosts.findMany()
     * 
     * // Get first 10 RePosts
     * const rePosts = await prisma.rePosts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rePostsWithIdOnly = await prisma.rePosts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RePostsFindManyArgs>(args?: SelectSubset<T, RePostsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RePostsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RePosts.
     * @param {RePostsCreateArgs} args - Arguments to create a RePosts.
     * @example
     * // Create one RePosts
     * const RePosts = await prisma.rePosts.create({
     *   data: {
     *     // ... data to create a RePosts
     *   }
     * })
     * 
     */
    create<T extends RePostsCreateArgs>(args: SelectSubset<T, RePostsCreateArgs<ExtArgs>>): Prisma__RePostsClient<$Result.GetResult<Prisma.$RePostsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RePosts.
     * @param {RePostsCreateManyArgs} args - Arguments to create many RePosts.
     * @example
     * // Create many RePosts
     * const rePosts = await prisma.rePosts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RePostsCreateManyArgs>(args?: SelectSubset<T, RePostsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RePosts and returns the data saved in the database.
     * @param {RePostsCreateManyAndReturnArgs} args - Arguments to create many RePosts.
     * @example
     * // Create many RePosts
     * const rePosts = await prisma.rePosts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RePosts and only return the `id`
     * const rePostsWithIdOnly = await prisma.rePosts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RePostsCreateManyAndReturnArgs>(args?: SelectSubset<T, RePostsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RePostsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RePosts.
     * @param {RePostsDeleteArgs} args - Arguments to delete one RePosts.
     * @example
     * // Delete one RePosts
     * const RePosts = await prisma.rePosts.delete({
     *   where: {
     *     // ... filter to delete one RePosts
     *   }
     * })
     * 
     */
    delete<T extends RePostsDeleteArgs>(args: SelectSubset<T, RePostsDeleteArgs<ExtArgs>>): Prisma__RePostsClient<$Result.GetResult<Prisma.$RePostsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RePosts.
     * @param {RePostsUpdateArgs} args - Arguments to update one RePosts.
     * @example
     * // Update one RePosts
     * const rePosts = await prisma.rePosts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RePostsUpdateArgs>(args: SelectSubset<T, RePostsUpdateArgs<ExtArgs>>): Prisma__RePostsClient<$Result.GetResult<Prisma.$RePostsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RePosts.
     * @param {RePostsDeleteManyArgs} args - Arguments to filter RePosts to delete.
     * @example
     * // Delete a few RePosts
     * const { count } = await prisma.rePosts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RePostsDeleteManyArgs>(args?: SelectSubset<T, RePostsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RePosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RePostsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RePosts
     * const rePosts = await prisma.rePosts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RePostsUpdateManyArgs>(args: SelectSubset<T, RePostsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RePosts and returns the data updated in the database.
     * @param {RePostsUpdateManyAndReturnArgs} args - Arguments to update many RePosts.
     * @example
     * // Update many RePosts
     * const rePosts = await prisma.rePosts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RePosts and only return the `id`
     * const rePostsWithIdOnly = await prisma.rePosts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RePostsUpdateManyAndReturnArgs>(args: SelectSubset<T, RePostsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RePostsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RePosts.
     * @param {RePostsUpsertArgs} args - Arguments to update or create a RePosts.
     * @example
     * // Update or create a RePosts
     * const rePosts = await prisma.rePosts.upsert({
     *   create: {
     *     // ... data to create a RePosts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RePosts we want to update
     *   }
     * })
     */
    upsert<T extends RePostsUpsertArgs>(args: SelectSubset<T, RePostsUpsertArgs<ExtArgs>>): Prisma__RePostsClient<$Result.GetResult<Prisma.$RePostsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RePosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RePostsCountArgs} args - Arguments to filter RePosts to count.
     * @example
     * // Count the number of RePosts
     * const count = await prisma.rePosts.count({
     *   where: {
     *     // ... the filter for the RePosts we want to count
     *   }
     * })
    **/
    count<T extends RePostsCountArgs>(
      args?: Subset<T, RePostsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RePostsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RePosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RePostsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RePostsAggregateArgs>(args: Subset<T, RePostsAggregateArgs>): Prisma.PrismaPromise<GetRePostsAggregateType<T>>

    /**
     * Group by RePosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RePostsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RePostsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RePostsGroupByArgs['orderBy'] }
        : { orderBy?: RePostsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RePostsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRePostsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RePosts model
   */
  readonly fields: RePostsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RePosts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RePostsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    originalPosts<T extends PostsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostsDefaultArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RePosts model
   */
  interface RePostsFieldRefs {
    readonly id: FieldRef<"RePosts", 'String'>
    readonly usersId: FieldRef<"RePosts", 'String'>
    readonly originalPostsId: FieldRef<"RePosts", 'String'>
    readonly createdAt: FieldRef<"RePosts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RePosts findUnique
   */
  export type RePostsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RePosts
     */
    select?: RePostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RePosts
     */
    omit?: RePostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RePostsInclude<ExtArgs> | null
    /**
     * Filter, which RePosts to fetch.
     */
    where: RePostsWhereUniqueInput
  }

  /**
   * RePosts findUniqueOrThrow
   */
  export type RePostsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RePosts
     */
    select?: RePostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RePosts
     */
    omit?: RePostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RePostsInclude<ExtArgs> | null
    /**
     * Filter, which RePosts to fetch.
     */
    where: RePostsWhereUniqueInput
  }

  /**
   * RePosts findFirst
   */
  export type RePostsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RePosts
     */
    select?: RePostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RePosts
     */
    omit?: RePostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RePostsInclude<ExtArgs> | null
    /**
     * Filter, which RePosts to fetch.
     */
    where?: RePostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RePosts to fetch.
     */
    orderBy?: RePostsOrderByWithRelationInput | RePostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RePosts.
     */
    cursor?: RePostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RePosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RePosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RePosts.
     */
    distinct?: RePostsScalarFieldEnum | RePostsScalarFieldEnum[]
  }

  /**
   * RePosts findFirstOrThrow
   */
  export type RePostsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RePosts
     */
    select?: RePostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RePosts
     */
    omit?: RePostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RePostsInclude<ExtArgs> | null
    /**
     * Filter, which RePosts to fetch.
     */
    where?: RePostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RePosts to fetch.
     */
    orderBy?: RePostsOrderByWithRelationInput | RePostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RePosts.
     */
    cursor?: RePostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RePosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RePosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RePosts.
     */
    distinct?: RePostsScalarFieldEnum | RePostsScalarFieldEnum[]
  }

  /**
   * RePosts findMany
   */
  export type RePostsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RePosts
     */
    select?: RePostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RePosts
     */
    omit?: RePostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RePostsInclude<ExtArgs> | null
    /**
     * Filter, which RePosts to fetch.
     */
    where?: RePostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RePosts to fetch.
     */
    orderBy?: RePostsOrderByWithRelationInput | RePostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RePosts.
     */
    cursor?: RePostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RePosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RePosts.
     */
    skip?: number
    distinct?: RePostsScalarFieldEnum | RePostsScalarFieldEnum[]
  }

  /**
   * RePosts create
   */
  export type RePostsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RePosts
     */
    select?: RePostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RePosts
     */
    omit?: RePostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RePostsInclude<ExtArgs> | null
    /**
     * The data needed to create a RePosts.
     */
    data: XOR<RePostsCreateInput, RePostsUncheckedCreateInput>
  }

  /**
   * RePosts createMany
   */
  export type RePostsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RePosts.
     */
    data: RePostsCreateManyInput | RePostsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RePosts createManyAndReturn
   */
  export type RePostsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RePosts
     */
    select?: RePostsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RePosts
     */
    omit?: RePostsOmit<ExtArgs> | null
    /**
     * The data used to create many RePosts.
     */
    data: RePostsCreateManyInput | RePostsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RePostsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RePosts update
   */
  export type RePostsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RePosts
     */
    select?: RePostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RePosts
     */
    omit?: RePostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RePostsInclude<ExtArgs> | null
    /**
     * The data needed to update a RePosts.
     */
    data: XOR<RePostsUpdateInput, RePostsUncheckedUpdateInput>
    /**
     * Choose, which RePosts to update.
     */
    where: RePostsWhereUniqueInput
  }

  /**
   * RePosts updateMany
   */
  export type RePostsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RePosts.
     */
    data: XOR<RePostsUpdateManyMutationInput, RePostsUncheckedUpdateManyInput>
    /**
     * Filter which RePosts to update
     */
    where?: RePostsWhereInput
    /**
     * Limit how many RePosts to update.
     */
    limit?: number
  }

  /**
   * RePosts updateManyAndReturn
   */
  export type RePostsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RePosts
     */
    select?: RePostsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RePosts
     */
    omit?: RePostsOmit<ExtArgs> | null
    /**
     * The data used to update RePosts.
     */
    data: XOR<RePostsUpdateManyMutationInput, RePostsUncheckedUpdateManyInput>
    /**
     * Filter which RePosts to update
     */
    where?: RePostsWhereInput
    /**
     * Limit how many RePosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RePostsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RePosts upsert
   */
  export type RePostsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RePosts
     */
    select?: RePostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RePosts
     */
    omit?: RePostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RePostsInclude<ExtArgs> | null
    /**
     * The filter to search for the RePosts to update in case it exists.
     */
    where: RePostsWhereUniqueInput
    /**
     * In case the RePosts found by the `where` argument doesn't exist, create a new RePosts with this data.
     */
    create: XOR<RePostsCreateInput, RePostsUncheckedCreateInput>
    /**
     * In case the RePosts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RePostsUpdateInput, RePostsUncheckedUpdateInput>
  }

  /**
   * RePosts delete
   */
  export type RePostsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RePosts
     */
    select?: RePostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RePosts
     */
    omit?: RePostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RePostsInclude<ExtArgs> | null
    /**
     * Filter which RePosts to delete.
     */
    where: RePostsWhereUniqueInput
  }

  /**
   * RePosts deleteMany
   */
  export type RePostsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RePosts to delete
     */
    where?: RePostsWhereInput
    /**
     * Limit how many RePosts to delete.
     */
    limit?: number
  }

  /**
   * RePosts without action
   */
  export type RePostsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RePosts
     */
    select?: RePostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RePosts
     */
    omit?: RePostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RePostsInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: string | null
    postsId: string | null
    commentId: string | null
    storyId: string | null
    filePath: string | null
    fileType: $Enums.FileType | null
    createdAt: Date | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: string | null
    postsId: string | null
    commentId: string | null
    storyId: string | null
    filePath: string | null
    fileType: $Enums.FileType | null
    createdAt: Date | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    postsId: number
    commentId: number
    storyId: number
    filePath: number
    fileType: number
    createdAt: number
    _all: number
  }


  export type AttachmentMinAggregateInputType = {
    id?: true
    postsId?: true
    commentId?: true
    storyId?: true
    filePath?: true
    fileType?: true
    createdAt?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    postsId?: true
    commentId?: true
    storyId?: true
    filePath?: true
    fileType?: true
    createdAt?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    postsId?: true
    commentId?: true
    storyId?: true
    filePath?: true
    fileType?: true
    createdAt?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: string
    postsId: string | null
    commentId: string | null
    storyId: string | null
    filePath: string
    fileType: $Enums.FileType
    createdAt: Date
    _count: AttachmentCountAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postsId?: boolean
    commentId?: boolean
    storyId?: boolean
    filePath?: boolean
    fileType?: boolean
    createdAt?: boolean
    posts?: boolean | Attachment$postsArgs<ExtArgs>
    comment?: boolean | Attachment$commentArgs<ExtArgs>
    story?: boolean | Attachment$storyArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postsId?: boolean
    commentId?: boolean
    storyId?: boolean
    filePath?: boolean
    fileType?: boolean
    createdAt?: boolean
    posts?: boolean | Attachment$postsArgs<ExtArgs>
    comment?: boolean | Attachment$commentArgs<ExtArgs>
    story?: boolean | Attachment$storyArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postsId?: boolean
    commentId?: boolean
    storyId?: boolean
    filePath?: boolean
    fileType?: boolean
    createdAt?: boolean
    posts?: boolean | Attachment$postsArgs<ExtArgs>
    comment?: boolean | Attachment$commentArgs<ExtArgs>
    story?: boolean | Attachment$storyArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectScalar = {
    id?: boolean
    postsId?: boolean
    commentId?: boolean
    storyId?: boolean
    filePath?: boolean
    fileType?: boolean
    createdAt?: boolean
  }

  export type AttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postsId" | "commentId" | "storyId" | "filePath" | "fileType" | "createdAt", ExtArgs["result"]["attachment"]>
  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Attachment$postsArgs<ExtArgs>
    comment?: boolean | Attachment$commentArgs<ExtArgs>
    story?: boolean | Attachment$storyArgs<ExtArgs>
  }
  export type AttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Attachment$postsArgs<ExtArgs>
    comment?: boolean | Attachment$commentArgs<ExtArgs>
    story?: boolean | Attachment$storyArgs<ExtArgs>
  }
  export type AttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Attachment$postsArgs<ExtArgs>
    comment?: boolean | Attachment$commentArgs<ExtArgs>
    story?: boolean | Attachment$storyArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      posts: Prisma.$PostsPayload<ExtArgs> | null
      comment: Prisma.$CommentPayload<ExtArgs> | null
      story: Prisma.$StoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postsId: string | null
      commentId: string | null
      storyId: string | null
      filePath: string
      fileType: $Enums.FileType
      createdAt: Date
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {AttachmentCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments and returns the data updated in the database.
     * @param {AttachmentUpdateManyAndReturnArgs} args - Arguments to update many Attachments.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Attachment$postsArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$postsArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comment<T extends Attachment$commentArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    story<T extends Attachment$storyArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$storyArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'String'>
    readonly postsId: FieldRef<"Attachment", 'String'>
    readonly commentId: FieldRef<"Attachment", 'String'>
    readonly storyId: FieldRef<"Attachment", 'String'>
    readonly filePath: FieldRef<"Attachment", 'String'>
    readonly fileType: FieldRef<"Attachment", 'FileType'>
    readonly createdAt: FieldRef<"Attachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment createManyAndReturn
   */
  export type AttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
  }

  /**
   * Attachment updateManyAndReturn
   */
  export type AttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to delete.
     */
    limit?: number
  }

  /**
   * Attachment.posts
   */
  export type Attachment$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    where?: PostsWhereInput
  }

  /**
   * Attachment.comment
   */
  export type Attachment$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Attachment.story
   */
  export type Attachment$storyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    where?: StoryWhereInput
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    usersId: string | null
    relatedUsersId: string | null
    postsId: string | null
    commentId: string | null
    storyId: string | null
    type: $Enums.NotificationType | null
    readStatus: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    usersId: string | null
    relatedUsersId: string | null
    postsId: string | null
    commentId: string | null
    storyId: string | null
    type: $Enums.NotificationType | null
    readStatus: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    usersId: number
    relatedUsersId: number
    postsId: number
    commentId: number
    storyId: number
    type: number
    readStatus: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    usersId?: true
    relatedUsersId?: true
    postsId?: true
    commentId?: true
    storyId?: true
    type?: true
    readStatus?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    usersId?: true
    relatedUsersId?: true
    postsId?: true
    commentId?: true
    storyId?: true
    type?: true
    readStatus?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    usersId?: true
    relatedUsersId?: true
    postsId?: true
    commentId?: true
    storyId?: true
    type?: true
    readStatus?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    usersId: string
    relatedUsersId: string | null
    postsId: string | null
    commentId: string | null
    storyId: string | null
    type: $Enums.NotificationType
    readStatus: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    relatedUsersId?: boolean
    postsId?: boolean
    commentId?: boolean
    storyId?: boolean
    type?: boolean
    readStatus?: boolean
    createdAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    relatedUsers?: boolean | Notification$relatedUsersArgs<ExtArgs>
    posts?: boolean | Notification$postsArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    story?: boolean | Notification$storyArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    relatedUsersId?: boolean
    postsId?: boolean
    commentId?: boolean
    storyId?: boolean
    type?: boolean
    readStatus?: boolean
    createdAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    relatedUsers?: boolean | Notification$relatedUsersArgs<ExtArgs>
    posts?: boolean | Notification$postsArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    story?: boolean | Notification$storyArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    relatedUsersId?: boolean
    postsId?: boolean
    commentId?: boolean
    storyId?: boolean
    type?: boolean
    readStatus?: boolean
    createdAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    relatedUsers?: boolean | Notification$relatedUsersArgs<ExtArgs>
    posts?: boolean | Notification$postsArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    story?: boolean | Notification$storyArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    usersId?: boolean
    relatedUsersId?: boolean
    postsId?: boolean
    commentId?: boolean
    storyId?: boolean
    type?: boolean
    readStatus?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usersId" | "relatedUsersId" | "postsId" | "commentId" | "storyId" | "type" | "readStatus" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    relatedUsers?: boolean | Notification$relatedUsersArgs<ExtArgs>
    posts?: boolean | Notification$postsArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    story?: boolean | Notification$storyArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    relatedUsers?: boolean | Notification$relatedUsersArgs<ExtArgs>
    posts?: boolean | Notification$postsArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    story?: boolean | Notification$storyArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    relatedUsers?: boolean | Notification$relatedUsersArgs<ExtArgs>
    posts?: boolean | Notification$postsArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    story?: boolean | Notification$storyArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>
      relatedUsers: Prisma.$UsersPayload<ExtArgs> | null
      posts: Prisma.$PostsPayload<ExtArgs> | null
      comment: Prisma.$CommentPayload<ExtArgs> | null
      story: Prisma.$StoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usersId: string
      relatedUsersId: string | null
      postsId: string | null
      commentId: string | null
      storyId: string | null
      type: $Enums.NotificationType
      readStatus: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    relatedUsers<T extends Notification$relatedUsersArgs<ExtArgs> = {}>(args?: Subset<T, Notification$relatedUsersArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    posts<T extends Notification$postsArgs<ExtArgs> = {}>(args?: Subset<T, Notification$postsArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comment<T extends Notification$commentArgs<ExtArgs> = {}>(args?: Subset<T, Notification$commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    story<T extends Notification$storyArgs<ExtArgs> = {}>(args?: Subset<T, Notification$storyArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly usersId: FieldRef<"Notification", 'String'>
    readonly relatedUsersId: FieldRef<"Notification", 'String'>
    readonly postsId: FieldRef<"Notification", 'String'>
    readonly commentId: FieldRef<"Notification", 'String'>
    readonly storyId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly readStatus: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.relatedUsers
   */
  export type Notification$relatedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * Notification.posts
   */
  export type Notification$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Posts
     */
    omit?: PostsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    where?: PostsWhereInput
  }

  /**
   * Notification.comment
   */
  export type Notification$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Notification.story
   */
  export type Notification$storyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Story
     */
    select?: StorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Story
     */
    omit?: StoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryInclude<ExtArgs> | null
    where?: StoryWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Messages
   */

  export type AggregateMessages = {
    _count: MessagesCountAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  export type MessagesMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    contentText: string | null
    mediaUrl: string | null
    mediaType: $Enums.MediaType | null
    readStatus: boolean | null
    createdAt: Date | null
  }

  export type MessagesMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    receiverId: string | null
    contentText: string | null
    mediaUrl: string | null
    mediaType: $Enums.MediaType | null
    readStatus: boolean | null
    createdAt: Date | null
  }

  export type MessagesCountAggregateOutputType = {
    id: number
    senderId: number
    receiverId: number
    contentText: number
    mediaUrl: number
    mediaType: number
    readStatus: number
    createdAt: number
    _all: number
  }


  export type MessagesMinAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    contentText?: true
    mediaUrl?: true
    mediaType?: true
    readStatus?: true
    createdAt?: true
  }

  export type MessagesMaxAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    contentText?: true
    mediaUrl?: true
    mediaType?: true
    readStatus?: true
    createdAt?: true
  }

  export type MessagesCountAggregateInputType = {
    id?: true
    senderId?: true
    receiverId?: true
    contentText?: true
    mediaUrl?: true
    mediaType?: true
    readStatus?: true
    createdAt?: true
    _all?: true
  }

  export type MessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to aggregate.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessagesMaxAggregateInputType
  }

  export type GetMessagesAggregateType<T extends MessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessages[P]>
      : GetScalarType<T[P], AggregateMessages[P]>
  }




  export type MessagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessagesWhereInput
    orderBy?: MessagesOrderByWithAggregationInput | MessagesOrderByWithAggregationInput[]
    by: MessagesScalarFieldEnum[] | MessagesScalarFieldEnum
    having?: MessagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessagesCountAggregateInputType | true
    _min?: MessagesMinAggregateInputType
    _max?: MessagesMaxAggregateInputType
  }

  export type MessagesGroupByOutputType = {
    id: string
    senderId: string
    receiverId: string
    contentText: string | null
    mediaUrl: string | null
    mediaType: $Enums.MediaType
    readStatus: boolean
    createdAt: Date
    _count: MessagesCountAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  type GetMessagesGroupByPayload<T extends MessagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessagesGroupByOutputType[P]>
            : GetScalarType<T[P], MessagesGroupByOutputType[P]>
        }
      >
    >


  export type MessagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    contentText?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    readStatus?: boolean
    createdAt?: boolean
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type MessagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    contentText?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    readStatus?: boolean
    createdAt?: boolean
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type MessagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    contentText?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    readStatus?: boolean
    createdAt?: boolean
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type MessagesSelectScalar = {
    id?: boolean
    senderId?: boolean
    receiverId?: boolean
    contentText?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    readStatus?: boolean
    createdAt?: boolean
  }

  export type MessagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderId" | "receiverId" | "contentText" | "mediaUrl" | "mediaType" | "readStatus" | "createdAt", ExtArgs["result"]["messages"]>
  export type MessagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type MessagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type MessagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UsersDefaultArgs<ExtArgs>
    receiver?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $MessagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Messages"
    objects: {
      sender: Prisma.$UsersPayload<ExtArgs>
      receiver: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      receiverId: string
      contentText: string | null
      mediaUrl: string | null
      mediaType: $Enums.MediaType
      readStatus: boolean
      createdAt: Date
    }, ExtArgs["result"]["messages"]>
    composites: {}
  }

  type MessagesGetPayload<S extends boolean | null | undefined | MessagesDefaultArgs> = $Result.GetResult<Prisma.$MessagesPayload, S>

  type MessagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessagesCountAggregateInputType | true
    }

  export interface MessagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Messages'], meta: { name: 'Messages' } }
    /**
     * Find zero or one Messages that matches the filter.
     * @param {MessagesFindUniqueArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessagesFindUniqueArgs>(args: SelectSubset<T, MessagesFindUniqueArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessagesFindUniqueOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessagesFindUniqueOrThrowArgs>(args: SelectSubset<T, MessagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesFindFirstArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessagesFindFirstArgs>(args?: SelectSubset<T, MessagesFindFirstArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesFindFirstOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessagesFindFirstOrThrowArgs>(args?: SelectSubset<T, MessagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.messages.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messagesWithIdOnly = await prisma.messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessagesFindManyArgs>(args?: SelectSubset<T, MessagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Messages.
     * @param {MessagesCreateArgs} args - Arguments to create a Messages.
     * @example
     * // Create one Messages
     * const Messages = await prisma.messages.create({
     *   data: {
     *     // ... data to create a Messages
     *   }
     * })
     * 
     */
    create<T extends MessagesCreateArgs>(args: SelectSubset<T, MessagesCreateArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessagesCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessagesCreateManyArgs>(args?: SelectSubset<T, MessagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessagesCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessagesCreateManyAndReturnArgs>(args?: SelectSubset<T, MessagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Messages.
     * @param {MessagesDeleteArgs} args - Arguments to delete one Messages.
     * @example
     * // Delete one Messages
     * const Messages = await prisma.messages.delete({
     *   where: {
     *     // ... filter to delete one Messages
     *   }
     * })
     * 
     */
    delete<T extends MessagesDeleteArgs>(args: SelectSubset<T, MessagesDeleteArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Messages.
     * @param {MessagesUpdateArgs} args - Arguments to update one Messages.
     * @example
     * // Update one Messages
     * const messages = await prisma.messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessagesUpdateArgs>(args: SelectSubset<T, MessagesUpdateArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessagesDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessagesDeleteManyArgs>(args?: SelectSubset<T, MessagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessagesUpdateManyArgs>(args: SelectSubset<T, MessagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessagesUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessagesUpdateManyAndReturnArgs>(args: SelectSubset<T, MessagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Messages.
     * @param {MessagesUpsertArgs} args - Arguments to update or create a Messages.
     * @example
     * // Update or create a Messages
     * const messages = await prisma.messages.upsert({
     *   create: {
     *     // ... data to create a Messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Messages we want to update
     *   }
     * })
     */
    upsert<T extends MessagesUpsertArgs>(args: SelectSubset<T, MessagesUpsertArgs<ExtArgs>>): Prisma__MessagesClient<$Result.GetResult<Prisma.$MessagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.messages.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessagesCountArgs>(
      args?: Subset<T, MessagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessagesAggregateArgs>(args: Subset<T, MessagesAggregateArgs>): Prisma.PrismaPromise<GetMessagesAggregateType<T>>

    /**
     * Group by Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessagesGroupByArgs['orderBy'] }
        : { orderBy?: MessagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Messages model
   */
  readonly fields: MessagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Messages model
   */
  interface MessagesFieldRefs {
    readonly id: FieldRef<"Messages", 'String'>
    readonly senderId: FieldRef<"Messages", 'String'>
    readonly receiverId: FieldRef<"Messages", 'String'>
    readonly contentText: FieldRef<"Messages", 'String'>
    readonly mediaUrl: FieldRef<"Messages", 'String'>
    readonly mediaType: FieldRef<"Messages", 'MediaType'>
    readonly readStatus: FieldRef<"Messages", 'Boolean'>
    readonly createdAt: FieldRef<"Messages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Messages findUnique
   */
  export type MessagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages findUniqueOrThrow
   */
  export type MessagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages findFirst
   */
  export type MessagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Messages findFirstOrThrow
   */
  export type MessagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Messages findMany
   */
  export type MessagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessagesOrderByWithRelationInput | MessagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * Messages create
   */
  export type MessagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * The data needed to create a Messages.
     */
    data: XOR<MessagesCreateInput, MessagesUncheckedCreateInput>
  }

  /**
   * Messages createMany
   */
  export type MessagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessagesCreateManyInput | MessagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Messages createManyAndReturn
   */
  export type MessagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessagesCreateManyInput | MessagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Messages update
   */
  export type MessagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * The data needed to update a Messages.
     */
    data: XOR<MessagesUpdateInput, MessagesUncheckedUpdateInput>
    /**
     * Choose, which Messages to update.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages updateMany
   */
  export type MessagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessagesWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Messages updateManyAndReturn
   */
  export type MessagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessagesWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Messages upsert
   */
  export type MessagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * The filter to search for the Messages to update in case it exists.
     */
    where: MessagesWhereUniqueInput
    /**
     * In case the Messages found by the `where` argument doesn't exist, create a new Messages with this data.
     */
    create: XOR<MessagesCreateInput, MessagesUncheckedCreateInput>
    /**
     * In case the Messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessagesUpdateInput, MessagesUncheckedUpdateInput>
  }

  /**
   * Messages delete
   */
  export type MessagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
    /**
     * Filter which Messages to delete.
     */
    where: MessagesWhereUniqueInput
  }

  /**
   * Messages deleteMany
   */
  export type MessagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessagesWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Messages without action
   */
  export type MessagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Messages
     */
    select?: MessagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Messages
     */
    omit?: MessagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessagesInclude<ExtArgs> | null
  }


  /**
   * Model Friends
   */

  export type AggregateFriends = {
    _count: FriendsCountAggregateOutputType | null
    _min: FriendsMinAggregateOutputType | null
    _max: FriendsMaxAggregateOutputType | null
  }

  export type FriendsMinAggregateOutputType = {
    id: string | null
    usersId: string | null
    friendId: string | null
    friendStatus: $Enums.FriendStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FriendsMaxAggregateOutputType = {
    id: string | null
    usersId: string | null
    friendId: string | null
    friendStatus: $Enums.FriendStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FriendsCountAggregateOutputType = {
    id: number
    usersId: number
    friendId: number
    friendStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FriendsMinAggregateInputType = {
    id?: true
    usersId?: true
    friendId?: true
    friendStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FriendsMaxAggregateInputType = {
    id?: true
    usersId?: true
    friendId?: true
    friendStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FriendsCountAggregateInputType = {
    id?: true
    usersId?: true
    friendId?: true
    friendStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FriendsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friends to aggregate.
     */
    where?: FriendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Friends
    **/
    _count?: true | FriendsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendsMaxAggregateInputType
  }

  export type GetFriendsAggregateType<T extends FriendsAggregateArgs> = {
        [P in keyof T & keyof AggregateFriends]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriends[P]>
      : GetScalarType<T[P], AggregateFriends[P]>
  }




  export type FriendsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendsWhereInput
    orderBy?: FriendsOrderByWithAggregationInput | FriendsOrderByWithAggregationInput[]
    by: FriendsScalarFieldEnum[] | FriendsScalarFieldEnum
    having?: FriendsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendsCountAggregateInputType | true
    _min?: FriendsMinAggregateInputType
    _max?: FriendsMaxAggregateInputType
  }

  export type FriendsGroupByOutputType = {
    id: string
    usersId: string
    friendId: string
    friendStatus: $Enums.FriendStatus
    createdAt: Date
    updatedAt: Date
    _count: FriendsCountAggregateOutputType | null
    _min: FriendsMinAggregateOutputType | null
    _max: FriendsMaxAggregateOutputType | null
  }

  type GetFriendsGroupByPayload<T extends FriendsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendsGroupByOutputType[P]>
            : GetScalarType<T[P], FriendsGroupByOutputType[P]>
        }
      >
    >


  export type FriendsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    friendId?: boolean
    friendStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    friend?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friends"]>

  export type FriendsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    friendId?: boolean
    friendStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    friend?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friends"]>

  export type FriendsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usersId?: boolean
    friendId?: boolean
    friendStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    friend?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friends"]>

  export type FriendsSelectScalar = {
    id?: boolean
    usersId?: boolean
    friendId?: boolean
    friendStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FriendsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usersId" | "friendId" | "friendStatus" | "createdAt" | "updatedAt", ExtArgs["result"]["friends"]>
  export type FriendsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    friend?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type FriendsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    friend?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type FriendsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    friend?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $FriendsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Friends"
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>
      friend: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usersId: string
      friendId: string
      friendStatus: $Enums.FriendStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["friends"]>
    composites: {}
  }

  type FriendsGetPayload<S extends boolean | null | undefined | FriendsDefaultArgs> = $Result.GetResult<Prisma.$FriendsPayload, S>

  type FriendsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FriendsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FriendsCountAggregateInputType | true
    }

  export interface FriendsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Friends'], meta: { name: 'Friends' } }
    /**
     * Find zero or one Friends that matches the filter.
     * @param {FriendsFindUniqueArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendsFindUniqueArgs>(args: SelectSubset<T, FriendsFindUniqueArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Friends that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FriendsFindUniqueOrThrowArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendsFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsFindFirstArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendsFindFirstArgs>(args?: SelectSubset<T, FriendsFindFirstArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friends that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsFindFirstOrThrowArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendsFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Friends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friends
     * const friends = await prisma.friends.findMany()
     * 
     * // Get first 10 Friends
     * const friends = await prisma.friends.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendsWithIdOnly = await prisma.friends.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FriendsFindManyArgs>(args?: SelectSubset<T, FriendsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Friends.
     * @param {FriendsCreateArgs} args - Arguments to create a Friends.
     * @example
     * // Create one Friends
     * const Friends = await prisma.friends.create({
     *   data: {
     *     // ... data to create a Friends
     *   }
     * })
     * 
     */
    create<T extends FriendsCreateArgs>(args: SelectSubset<T, FriendsCreateArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Friends.
     * @param {FriendsCreateManyArgs} args - Arguments to create many Friends.
     * @example
     * // Create many Friends
     * const friends = await prisma.friends.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendsCreateManyArgs>(args?: SelectSubset<T, FriendsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Friends and returns the data saved in the database.
     * @param {FriendsCreateManyAndReturnArgs} args - Arguments to create many Friends.
     * @example
     * // Create many Friends
     * const friends = await prisma.friends.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Friends and only return the `id`
     * const friendsWithIdOnly = await prisma.friends.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FriendsCreateManyAndReturnArgs>(args?: SelectSubset<T, FriendsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Friends.
     * @param {FriendsDeleteArgs} args - Arguments to delete one Friends.
     * @example
     * // Delete one Friends
     * const Friends = await prisma.friends.delete({
     *   where: {
     *     // ... filter to delete one Friends
     *   }
     * })
     * 
     */
    delete<T extends FriendsDeleteArgs>(args: SelectSubset<T, FriendsDeleteArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Friends.
     * @param {FriendsUpdateArgs} args - Arguments to update one Friends.
     * @example
     * // Update one Friends
     * const friends = await prisma.friends.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendsUpdateArgs>(args: SelectSubset<T, FriendsUpdateArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Friends.
     * @param {FriendsDeleteManyArgs} args - Arguments to filter Friends to delete.
     * @example
     * // Delete a few Friends
     * const { count } = await prisma.friends.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendsDeleteManyArgs>(args?: SelectSubset<T, FriendsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friends
     * const friends = await prisma.friends.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendsUpdateManyArgs>(args: SelectSubset<T, FriendsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friends and returns the data updated in the database.
     * @param {FriendsUpdateManyAndReturnArgs} args - Arguments to update many Friends.
     * @example
     * // Update many Friends
     * const friends = await prisma.friends.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Friends and only return the `id`
     * const friendsWithIdOnly = await prisma.friends.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FriendsUpdateManyAndReturnArgs>(args: SelectSubset<T, FriendsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Friends.
     * @param {FriendsUpsertArgs} args - Arguments to update or create a Friends.
     * @example
     * // Update or create a Friends
     * const friends = await prisma.friends.upsert({
     *   create: {
     *     // ... data to create a Friends
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friends we want to update
     *   }
     * })
     */
    upsert<T extends FriendsUpsertArgs>(args: SelectSubset<T, FriendsUpsertArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsCountArgs} args - Arguments to filter Friends to count.
     * @example
     * // Count the number of Friends
     * const count = await prisma.friends.count({
     *   where: {
     *     // ... the filter for the Friends we want to count
     *   }
     * })
    **/
    count<T extends FriendsCountArgs>(
      args?: Subset<T, FriendsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendsAggregateArgs>(args: Subset<T, FriendsAggregateArgs>): Prisma.PrismaPromise<GetFriendsAggregateType<T>>

    /**
     * Group by Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendsGroupByArgs['orderBy'] }
        : { orderBy?: FriendsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Friends model
   */
  readonly fields: FriendsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Friends.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    friend<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Friends model
   */
  interface FriendsFieldRefs {
    readonly id: FieldRef<"Friends", 'String'>
    readonly usersId: FieldRef<"Friends", 'String'>
    readonly friendId: FieldRef<"Friends", 'String'>
    readonly friendStatus: FieldRef<"Friends", 'FriendStatus'>
    readonly createdAt: FieldRef<"Friends", 'DateTime'>
    readonly updatedAt: FieldRef<"Friends", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Friends findUnique
   */
  export type FriendsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where: FriendsWhereUniqueInput
  }

  /**
   * Friends findUniqueOrThrow
   */
  export type FriendsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where: FriendsWhereUniqueInput
  }

  /**
   * Friends findFirst
   */
  export type FriendsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where?: FriendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friends.
     */
    cursor?: FriendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friends.
     */
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Friends findFirstOrThrow
   */
  export type FriendsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where?: FriendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friends.
     */
    cursor?: FriendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friends.
     */
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Friends findMany
   */
  export type FriendsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where?: FriendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Friends.
     */
    cursor?: FriendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Friends create
   */
  export type FriendsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * The data needed to create a Friends.
     */
    data: XOR<FriendsCreateInput, FriendsUncheckedCreateInput>
  }

  /**
   * Friends createMany
   */
  export type FriendsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Friends.
     */
    data: FriendsCreateManyInput | FriendsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Friends createManyAndReturn
   */
  export type FriendsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * The data used to create many Friends.
     */
    data: FriendsCreateManyInput | FriendsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friends update
   */
  export type FriendsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * The data needed to update a Friends.
     */
    data: XOR<FriendsUpdateInput, FriendsUncheckedUpdateInput>
    /**
     * Choose, which Friends to update.
     */
    where: FriendsWhereUniqueInput
  }

  /**
   * Friends updateMany
   */
  export type FriendsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Friends.
     */
    data: XOR<FriendsUpdateManyMutationInput, FriendsUncheckedUpdateManyInput>
    /**
     * Filter which Friends to update
     */
    where?: FriendsWhereInput
    /**
     * Limit how many Friends to update.
     */
    limit?: number
  }

  /**
   * Friends updateManyAndReturn
   */
  export type FriendsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * The data used to update Friends.
     */
    data: XOR<FriendsUpdateManyMutationInput, FriendsUncheckedUpdateManyInput>
    /**
     * Filter which Friends to update
     */
    where?: FriendsWhereInput
    /**
     * Limit how many Friends to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friends upsert
   */
  export type FriendsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * The filter to search for the Friends to update in case it exists.
     */
    where: FriendsWhereUniqueInput
    /**
     * In case the Friends found by the `where` argument doesn't exist, create a new Friends with this data.
     */
    create: XOR<FriendsCreateInput, FriendsUncheckedCreateInput>
    /**
     * In case the Friends was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendsUpdateInput, FriendsUncheckedUpdateInput>
  }

  /**
   * Friends delete
   */
  export type FriendsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter which Friends to delete.
     */
    where: FriendsWhereUniqueInput
  }

  /**
   * Friends deleteMany
   */
  export type FriendsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friends to delete
     */
    where?: FriendsWhereInput
    /**
     * Limit how many Friends to delete.
     */
    limit?: number
  }

  /**
   * Friends without action
   */
  export type FriendsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
  }


  /**
   * Model Followers
   */

  export type AggregateFollowers = {
    _count: FollowersCountAggregateOutputType | null
    _min: FollowersMinAggregateOutputType | null
    _max: FollowersMaxAggregateOutputType | null
  }

  export type FollowersMinAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
  }

  export type FollowersMaxAggregateOutputType = {
    id: string | null
    followerId: string | null
    followingId: string | null
    createdAt: Date | null
  }

  export type FollowersCountAggregateOutputType = {
    id: number
    followerId: number
    followingId: number
    createdAt: number
    _all: number
  }


  export type FollowersMinAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type FollowersMaxAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
  }

  export type FollowersCountAggregateInputType = {
    id?: true
    followerId?: true
    followingId?: true
    createdAt?: true
    _all?: true
  }

  export type FollowersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Followers to aggregate.
     */
    where?: FollowersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Followers to fetch.
     */
    orderBy?: FollowersOrderByWithRelationInput | FollowersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Followers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Followers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Followers
    **/
    _count?: true | FollowersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowersMaxAggregateInputType
  }

  export type GetFollowersAggregateType<T extends FollowersAggregateArgs> = {
        [P in keyof T & keyof AggregateFollowers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollowers[P]>
      : GetScalarType<T[P], AggregateFollowers[P]>
  }




  export type FollowersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowersWhereInput
    orderBy?: FollowersOrderByWithAggregationInput | FollowersOrderByWithAggregationInput[]
    by: FollowersScalarFieldEnum[] | FollowersScalarFieldEnum
    having?: FollowersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowersCountAggregateInputType | true
    _min?: FollowersMinAggregateInputType
    _max?: FollowersMaxAggregateInputType
  }

  export type FollowersGroupByOutputType = {
    id: string
    followerId: string
    followingId: string
    createdAt: Date
    _count: FollowersCountAggregateOutputType | null
    _min: FollowersMinAggregateOutputType | null
    _max: FollowersMaxAggregateOutputType | null
  }

  type GetFollowersGroupByPayload<T extends FollowersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowersGroupByOutputType[P]>
            : GetScalarType<T[P], FollowersGroupByOutputType[P]>
        }
      >
    >


  export type FollowersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UsersDefaultArgs<ExtArgs>
    following?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followers"]>

  export type FollowersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UsersDefaultArgs<ExtArgs>
    following?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followers"]>

  export type FollowersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
    follower?: boolean | UsersDefaultArgs<ExtArgs>
    following?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followers"]>

  export type FollowersSelectScalar = {
    id?: boolean
    followerId?: boolean
    followingId?: boolean
    createdAt?: boolean
  }

  export type FollowersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "followerId" | "followingId" | "createdAt", ExtArgs["result"]["followers"]>
  export type FollowersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UsersDefaultArgs<ExtArgs>
    following?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type FollowersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UsersDefaultArgs<ExtArgs>
    following?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type FollowersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | UsersDefaultArgs<ExtArgs>
    following?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $FollowersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Followers"
    objects: {
      follower: Prisma.$UsersPayload<ExtArgs>
      following: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      followerId: string
      followingId: string
      createdAt: Date
    }, ExtArgs["result"]["followers"]>
    composites: {}
  }

  type FollowersGetPayload<S extends boolean | null | undefined | FollowersDefaultArgs> = $Result.GetResult<Prisma.$FollowersPayload, S>

  type FollowersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowersCountAggregateInputType | true
    }

  export interface FollowersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Followers'], meta: { name: 'Followers' } }
    /**
     * Find zero or one Followers that matches the filter.
     * @param {FollowersFindUniqueArgs} args - Arguments to find a Followers
     * @example
     * // Get one Followers
     * const followers = await prisma.followers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowersFindUniqueArgs>(args: SelectSubset<T, FollowersFindUniqueArgs<ExtArgs>>): Prisma__FollowersClient<$Result.GetResult<Prisma.$FollowersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Followers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowersFindUniqueOrThrowArgs} args - Arguments to find a Followers
     * @example
     * // Get one Followers
     * const followers = await prisma.followers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowersFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowersClient<$Result.GetResult<Prisma.$FollowersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Followers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowersFindFirstArgs} args - Arguments to find a Followers
     * @example
     * // Get one Followers
     * const followers = await prisma.followers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowersFindFirstArgs>(args?: SelectSubset<T, FollowersFindFirstArgs<ExtArgs>>): Prisma__FollowersClient<$Result.GetResult<Prisma.$FollowersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Followers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowersFindFirstOrThrowArgs} args - Arguments to find a Followers
     * @example
     * // Get one Followers
     * const followers = await prisma.followers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowersFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowersFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowersClient<$Result.GetResult<Prisma.$FollowersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Followers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Followers
     * const followers = await prisma.followers.findMany()
     * 
     * // Get first 10 Followers
     * const followers = await prisma.followers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followersWithIdOnly = await prisma.followers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowersFindManyArgs>(args?: SelectSubset<T, FollowersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Followers.
     * @param {FollowersCreateArgs} args - Arguments to create a Followers.
     * @example
     * // Create one Followers
     * const Followers = await prisma.followers.create({
     *   data: {
     *     // ... data to create a Followers
     *   }
     * })
     * 
     */
    create<T extends FollowersCreateArgs>(args: SelectSubset<T, FollowersCreateArgs<ExtArgs>>): Prisma__FollowersClient<$Result.GetResult<Prisma.$FollowersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Followers.
     * @param {FollowersCreateManyArgs} args - Arguments to create many Followers.
     * @example
     * // Create many Followers
     * const followers = await prisma.followers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowersCreateManyArgs>(args?: SelectSubset<T, FollowersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Followers and returns the data saved in the database.
     * @param {FollowersCreateManyAndReturnArgs} args - Arguments to create many Followers.
     * @example
     * // Create many Followers
     * const followers = await prisma.followers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Followers and only return the `id`
     * const followersWithIdOnly = await prisma.followers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowersCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Followers.
     * @param {FollowersDeleteArgs} args - Arguments to delete one Followers.
     * @example
     * // Delete one Followers
     * const Followers = await prisma.followers.delete({
     *   where: {
     *     // ... filter to delete one Followers
     *   }
     * })
     * 
     */
    delete<T extends FollowersDeleteArgs>(args: SelectSubset<T, FollowersDeleteArgs<ExtArgs>>): Prisma__FollowersClient<$Result.GetResult<Prisma.$FollowersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Followers.
     * @param {FollowersUpdateArgs} args - Arguments to update one Followers.
     * @example
     * // Update one Followers
     * const followers = await prisma.followers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowersUpdateArgs>(args: SelectSubset<T, FollowersUpdateArgs<ExtArgs>>): Prisma__FollowersClient<$Result.GetResult<Prisma.$FollowersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Followers.
     * @param {FollowersDeleteManyArgs} args - Arguments to filter Followers to delete.
     * @example
     * // Delete a few Followers
     * const { count } = await prisma.followers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowersDeleteManyArgs>(args?: SelectSubset<T, FollowersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Followers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Followers
     * const followers = await prisma.followers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowersUpdateManyArgs>(args: SelectSubset<T, FollowersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Followers and returns the data updated in the database.
     * @param {FollowersUpdateManyAndReturnArgs} args - Arguments to update many Followers.
     * @example
     * // Update many Followers
     * const followers = await prisma.followers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Followers and only return the `id`
     * const followersWithIdOnly = await prisma.followers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FollowersUpdateManyAndReturnArgs>(args: SelectSubset<T, FollowersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Followers.
     * @param {FollowersUpsertArgs} args - Arguments to update or create a Followers.
     * @example
     * // Update or create a Followers
     * const followers = await prisma.followers.upsert({
     *   create: {
     *     // ... data to create a Followers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Followers we want to update
     *   }
     * })
     */
    upsert<T extends FollowersUpsertArgs>(args: SelectSubset<T, FollowersUpsertArgs<ExtArgs>>): Prisma__FollowersClient<$Result.GetResult<Prisma.$FollowersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Followers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowersCountArgs} args - Arguments to filter Followers to count.
     * @example
     * // Count the number of Followers
     * const count = await prisma.followers.count({
     *   where: {
     *     // ... the filter for the Followers we want to count
     *   }
     * })
    **/
    count<T extends FollowersCountArgs>(
      args?: Subset<T, FollowersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Followers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowersAggregateArgs>(args: Subset<T, FollowersAggregateArgs>): Prisma.PrismaPromise<GetFollowersAggregateType<T>>

    /**
     * Group by Followers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowersGroupByArgs['orderBy'] }
        : { orderBy?: FollowersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Followers model
   */
  readonly fields: FollowersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Followers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    follower<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    following<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Followers model
   */
  interface FollowersFieldRefs {
    readonly id: FieldRef<"Followers", 'String'>
    readonly followerId: FieldRef<"Followers", 'String'>
    readonly followingId: FieldRef<"Followers", 'String'>
    readonly createdAt: FieldRef<"Followers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Followers findUnique
   */
  export type FollowersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followers
     */
    select?: FollowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followers
     */
    omit?: FollowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowersInclude<ExtArgs> | null
    /**
     * Filter, which Followers to fetch.
     */
    where: FollowersWhereUniqueInput
  }

  /**
   * Followers findUniqueOrThrow
   */
  export type FollowersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followers
     */
    select?: FollowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followers
     */
    omit?: FollowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowersInclude<ExtArgs> | null
    /**
     * Filter, which Followers to fetch.
     */
    where: FollowersWhereUniqueInput
  }

  /**
   * Followers findFirst
   */
  export type FollowersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followers
     */
    select?: FollowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followers
     */
    omit?: FollowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowersInclude<ExtArgs> | null
    /**
     * Filter, which Followers to fetch.
     */
    where?: FollowersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Followers to fetch.
     */
    orderBy?: FollowersOrderByWithRelationInput | FollowersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Followers.
     */
    cursor?: FollowersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Followers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Followers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Followers.
     */
    distinct?: FollowersScalarFieldEnum | FollowersScalarFieldEnum[]
  }

  /**
   * Followers findFirstOrThrow
   */
  export type FollowersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followers
     */
    select?: FollowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followers
     */
    omit?: FollowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowersInclude<ExtArgs> | null
    /**
     * Filter, which Followers to fetch.
     */
    where?: FollowersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Followers to fetch.
     */
    orderBy?: FollowersOrderByWithRelationInput | FollowersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Followers.
     */
    cursor?: FollowersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Followers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Followers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Followers.
     */
    distinct?: FollowersScalarFieldEnum | FollowersScalarFieldEnum[]
  }

  /**
   * Followers findMany
   */
  export type FollowersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followers
     */
    select?: FollowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followers
     */
    omit?: FollowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowersInclude<ExtArgs> | null
    /**
     * Filter, which Followers to fetch.
     */
    where?: FollowersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Followers to fetch.
     */
    orderBy?: FollowersOrderByWithRelationInput | FollowersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Followers.
     */
    cursor?: FollowersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Followers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Followers.
     */
    skip?: number
    distinct?: FollowersScalarFieldEnum | FollowersScalarFieldEnum[]
  }

  /**
   * Followers create
   */
  export type FollowersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followers
     */
    select?: FollowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followers
     */
    omit?: FollowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowersInclude<ExtArgs> | null
    /**
     * The data needed to create a Followers.
     */
    data: XOR<FollowersCreateInput, FollowersUncheckedCreateInput>
  }

  /**
   * Followers createMany
   */
  export type FollowersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Followers.
     */
    data: FollowersCreateManyInput | FollowersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Followers createManyAndReturn
   */
  export type FollowersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followers
     */
    select?: FollowersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Followers
     */
    omit?: FollowersOmit<ExtArgs> | null
    /**
     * The data used to create many Followers.
     */
    data: FollowersCreateManyInput | FollowersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Followers update
   */
  export type FollowersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followers
     */
    select?: FollowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followers
     */
    omit?: FollowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowersInclude<ExtArgs> | null
    /**
     * The data needed to update a Followers.
     */
    data: XOR<FollowersUpdateInput, FollowersUncheckedUpdateInput>
    /**
     * Choose, which Followers to update.
     */
    where: FollowersWhereUniqueInput
  }

  /**
   * Followers updateMany
   */
  export type FollowersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Followers.
     */
    data: XOR<FollowersUpdateManyMutationInput, FollowersUncheckedUpdateManyInput>
    /**
     * Filter which Followers to update
     */
    where?: FollowersWhereInput
    /**
     * Limit how many Followers to update.
     */
    limit?: number
  }

  /**
   * Followers updateManyAndReturn
   */
  export type FollowersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followers
     */
    select?: FollowersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Followers
     */
    omit?: FollowersOmit<ExtArgs> | null
    /**
     * The data used to update Followers.
     */
    data: XOR<FollowersUpdateManyMutationInput, FollowersUncheckedUpdateManyInput>
    /**
     * Filter which Followers to update
     */
    where?: FollowersWhereInput
    /**
     * Limit how many Followers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Followers upsert
   */
  export type FollowersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followers
     */
    select?: FollowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followers
     */
    omit?: FollowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowersInclude<ExtArgs> | null
    /**
     * The filter to search for the Followers to update in case it exists.
     */
    where: FollowersWhereUniqueInput
    /**
     * In case the Followers found by the `where` argument doesn't exist, create a new Followers with this data.
     */
    create: XOR<FollowersCreateInput, FollowersUncheckedCreateInput>
    /**
     * In case the Followers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowersUpdateInput, FollowersUncheckedUpdateInput>
  }

  /**
   * Followers delete
   */
  export type FollowersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followers
     */
    select?: FollowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followers
     */
    omit?: FollowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowersInclude<ExtArgs> | null
    /**
     * Filter which Followers to delete.
     */
    where: FollowersWhereUniqueInput
  }

  /**
   * Followers deleteMany
   */
  export type FollowersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Followers to delete
     */
    where?: FollowersWhereInput
    /**
     * Limit how many Followers to delete.
     */
    limit?: number
  }

  /**
   * Followers without action
   */
  export type FollowersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followers
     */
    select?: FollowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followers
     */
    omit?: FollowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowersInclude<ExtArgs> | null
  }


  /**
   * Model StoryViewer
   */

  export type AggregateStoryViewer = {
    _count: StoryViewerCountAggregateOutputType | null
    _min: StoryViewerMinAggregateOutputType | null
    _max: StoryViewerMaxAggregateOutputType | null
  }

  export type StoryViewerMinAggregateOutputType = {
    id: string | null
    storyId: string | null
    usersId: string | null
    readAt: Date | null
  }

  export type StoryViewerMaxAggregateOutputType = {
    id: string | null
    storyId: string | null
    usersId: string | null
    readAt: Date | null
  }

  export type StoryViewerCountAggregateOutputType = {
    id: number
    storyId: number
    usersId: number
    readAt: number
    _all: number
  }


  export type StoryViewerMinAggregateInputType = {
    id?: true
    storyId?: true
    usersId?: true
    readAt?: true
  }

  export type StoryViewerMaxAggregateInputType = {
    id?: true
    storyId?: true
    usersId?: true
    readAt?: true
  }

  export type StoryViewerCountAggregateInputType = {
    id?: true
    storyId?: true
    usersId?: true
    readAt?: true
    _all?: true
  }

  export type StoryViewerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryViewer to aggregate.
     */
    where?: StoryViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryViewers to fetch.
     */
    orderBy?: StoryViewerOrderByWithRelationInput | StoryViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoryViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryViewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoryViewers
    **/
    _count?: true | StoryViewerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoryViewerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoryViewerMaxAggregateInputType
  }

  export type GetStoryViewerAggregateType<T extends StoryViewerAggregateArgs> = {
        [P in keyof T & keyof AggregateStoryViewer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoryViewer[P]>
      : GetScalarType<T[P], AggregateStoryViewer[P]>
  }




  export type StoryViewerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoryViewerWhereInput
    orderBy?: StoryViewerOrderByWithAggregationInput | StoryViewerOrderByWithAggregationInput[]
    by: StoryViewerScalarFieldEnum[] | StoryViewerScalarFieldEnum
    having?: StoryViewerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoryViewerCountAggregateInputType | true
    _min?: StoryViewerMinAggregateInputType
    _max?: StoryViewerMaxAggregateInputType
  }

  export type StoryViewerGroupByOutputType = {
    id: string
    storyId: string
    usersId: string
    readAt: Date
    _count: StoryViewerCountAggregateOutputType | null
    _min: StoryViewerMinAggregateOutputType | null
    _max: StoryViewerMaxAggregateOutputType | null
  }

  type GetStoryViewerGroupByPayload<T extends StoryViewerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoryViewerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoryViewerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoryViewerGroupByOutputType[P]>
            : GetScalarType<T[P], StoryViewerGroupByOutputType[P]>
        }
      >
    >


  export type StoryViewerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    usersId?: boolean
    readAt?: boolean
    story?: boolean | StoryDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyViewer"]>

  export type StoryViewerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    usersId?: boolean
    readAt?: boolean
    story?: boolean | StoryDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyViewer"]>

  export type StoryViewerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storyId?: boolean
    usersId?: boolean
    readAt?: boolean
    story?: boolean | StoryDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storyViewer"]>

  export type StoryViewerSelectScalar = {
    id?: boolean
    storyId?: boolean
    usersId?: boolean
    readAt?: boolean
  }

  export type StoryViewerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storyId" | "usersId" | "readAt", ExtArgs["result"]["storyViewer"]>
  export type StoryViewerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | StoryDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type StoryViewerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | StoryDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type StoryViewerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    story?: boolean | StoryDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $StoryViewerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoryViewer"
    objects: {
      story: Prisma.$StoryPayload<ExtArgs>
      users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storyId: string
      usersId: string
      readAt: Date
    }, ExtArgs["result"]["storyViewer"]>
    composites: {}
  }

  type StoryViewerGetPayload<S extends boolean | null | undefined | StoryViewerDefaultArgs> = $Result.GetResult<Prisma.$StoryViewerPayload, S>

  type StoryViewerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoryViewerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoryViewerCountAggregateInputType | true
    }

  export interface StoryViewerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoryViewer'], meta: { name: 'StoryViewer' } }
    /**
     * Find zero or one StoryViewer that matches the filter.
     * @param {StoryViewerFindUniqueArgs} args - Arguments to find a StoryViewer
     * @example
     * // Get one StoryViewer
     * const storyViewer = await prisma.storyViewer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoryViewerFindUniqueArgs>(args: SelectSubset<T, StoryViewerFindUniqueArgs<ExtArgs>>): Prisma__StoryViewerClient<$Result.GetResult<Prisma.$StoryViewerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StoryViewer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoryViewerFindUniqueOrThrowArgs} args - Arguments to find a StoryViewer
     * @example
     * // Get one StoryViewer
     * const storyViewer = await prisma.storyViewer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoryViewerFindUniqueOrThrowArgs>(args: SelectSubset<T, StoryViewerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoryViewerClient<$Result.GetResult<Prisma.$StoryViewerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryViewer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryViewerFindFirstArgs} args - Arguments to find a StoryViewer
     * @example
     * // Get one StoryViewer
     * const storyViewer = await prisma.storyViewer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoryViewerFindFirstArgs>(args?: SelectSubset<T, StoryViewerFindFirstArgs<ExtArgs>>): Prisma__StoryViewerClient<$Result.GetResult<Prisma.$StoryViewerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StoryViewer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryViewerFindFirstOrThrowArgs} args - Arguments to find a StoryViewer
     * @example
     * // Get one StoryViewer
     * const storyViewer = await prisma.storyViewer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoryViewerFindFirstOrThrowArgs>(args?: SelectSubset<T, StoryViewerFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoryViewerClient<$Result.GetResult<Prisma.$StoryViewerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StoryViewers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryViewerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoryViewers
     * const storyViewers = await prisma.storyViewer.findMany()
     * 
     * // Get first 10 StoryViewers
     * const storyViewers = await prisma.storyViewer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storyViewerWithIdOnly = await prisma.storyViewer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoryViewerFindManyArgs>(args?: SelectSubset<T, StoryViewerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryViewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StoryViewer.
     * @param {StoryViewerCreateArgs} args - Arguments to create a StoryViewer.
     * @example
     * // Create one StoryViewer
     * const StoryViewer = await prisma.storyViewer.create({
     *   data: {
     *     // ... data to create a StoryViewer
     *   }
     * })
     * 
     */
    create<T extends StoryViewerCreateArgs>(args: SelectSubset<T, StoryViewerCreateArgs<ExtArgs>>): Prisma__StoryViewerClient<$Result.GetResult<Prisma.$StoryViewerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StoryViewers.
     * @param {StoryViewerCreateManyArgs} args - Arguments to create many StoryViewers.
     * @example
     * // Create many StoryViewers
     * const storyViewer = await prisma.storyViewer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoryViewerCreateManyArgs>(args?: SelectSubset<T, StoryViewerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoryViewers and returns the data saved in the database.
     * @param {StoryViewerCreateManyAndReturnArgs} args - Arguments to create many StoryViewers.
     * @example
     * // Create many StoryViewers
     * const storyViewer = await prisma.storyViewer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoryViewers and only return the `id`
     * const storyViewerWithIdOnly = await prisma.storyViewer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoryViewerCreateManyAndReturnArgs>(args?: SelectSubset<T, StoryViewerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryViewerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StoryViewer.
     * @param {StoryViewerDeleteArgs} args - Arguments to delete one StoryViewer.
     * @example
     * // Delete one StoryViewer
     * const StoryViewer = await prisma.storyViewer.delete({
     *   where: {
     *     // ... filter to delete one StoryViewer
     *   }
     * })
     * 
     */
    delete<T extends StoryViewerDeleteArgs>(args: SelectSubset<T, StoryViewerDeleteArgs<ExtArgs>>): Prisma__StoryViewerClient<$Result.GetResult<Prisma.$StoryViewerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StoryViewer.
     * @param {StoryViewerUpdateArgs} args - Arguments to update one StoryViewer.
     * @example
     * // Update one StoryViewer
     * const storyViewer = await prisma.storyViewer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoryViewerUpdateArgs>(args: SelectSubset<T, StoryViewerUpdateArgs<ExtArgs>>): Prisma__StoryViewerClient<$Result.GetResult<Prisma.$StoryViewerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StoryViewers.
     * @param {StoryViewerDeleteManyArgs} args - Arguments to filter StoryViewers to delete.
     * @example
     * // Delete a few StoryViewers
     * const { count } = await prisma.storyViewer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoryViewerDeleteManyArgs>(args?: SelectSubset<T, StoryViewerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryViewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryViewerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoryViewers
     * const storyViewer = await prisma.storyViewer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoryViewerUpdateManyArgs>(args: SelectSubset<T, StoryViewerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoryViewers and returns the data updated in the database.
     * @param {StoryViewerUpdateManyAndReturnArgs} args - Arguments to update many StoryViewers.
     * @example
     * // Update many StoryViewers
     * const storyViewer = await prisma.storyViewer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StoryViewers and only return the `id`
     * const storyViewerWithIdOnly = await prisma.storyViewer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoryViewerUpdateManyAndReturnArgs>(args: SelectSubset<T, StoryViewerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoryViewerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StoryViewer.
     * @param {StoryViewerUpsertArgs} args - Arguments to update or create a StoryViewer.
     * @example
     * // Update or create a StoryViewer
     * const storyViewer = await prisma.storyViewer.upsert({
     *   create: {
     *     // ... data to create a StoryViewer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoryViewer we want to update
     *   }
     * })
     */
    upsert<T extends StoryViewerUpsertArgs>(args: SelectSubset<T, StoryViewerUpsertArgs<ExtArgs>>): Prisma__StoryViewerClient<$Result.GetResult<Prisma.$StoryViewerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StoryViewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryViewerCountArgs} args - Arguments to filter StoryViewers to count.
     * @example
     * // Count the number of StoryViewers
     * const count = await prisma.storyViewer.count({
     *   where: {
     *     // ... the filter for the StoryViewers we want to count
     *   }
     * })
    **/
    count<T extends StoryViewerCountArgs>(
      args?: Subset<T, StoryViewerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoryViewerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoryViewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryViewerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoryViewerAggregateArgs>(args: Subset<T, StoryViewerAggregateArgs>): Prisma.PrismaPromise<GetStoryViewerAggregateType<T>>

    /**
     * Group by StoryViewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoryViewerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoryViewerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoryViewerGroupByArgs['orderBy'] }
        : { orderBy?: StoryViewerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoryViewerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoryViewerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoryViewer model
   */
  readonly fields: StoryViewerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoryViewer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoryViewerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    story<T extends StoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoryDefaultArgs<ExtArgs>>): Prisma__StoryClient<$Result.GetResult<Prisma.$StoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoryViewer model
   */
  interface StoryViewerFieldRefs {
    readonly id: FieldRef<"StoryViewer", 'String'>
    readonly storyId: FieldRef<"StoryViewer", 'String'>
    readonly usersId: FieldRef<"StoryViewer", 'String'>
    readonly readAt: FieldRef<"StoryViewer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StoryViewer findUnique
   */
  export type StoryViewerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryViewer
     */
    select?: StoryViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryViewer
     */
    omit?: StoryViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryViewerInclude<ExtArgs> | null
    /**
     * Filter, which StoryViewer to fetch.
     */
    where: StoryViewerWhereUniqueInput
  }

  /**
   * StoryViewer findUniqueOrThrow
   */
  export type StoryViewerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryViewer
     */
    select?: StoryViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryViewer
     */
    omit?: StoryViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryViewerInclude<ExtArgs> | null
    /**
     * Filter, which StoryViewer to fetch.
     */
    where: StoryViewerWhereUniqueInput
  }

  /**
   * StoryViewer findFirst
   */
  export type StoryViewerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryViewer
     */
    select?: StoryViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryViewer
     */
    omit?: StoryViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryViewerInclude<ExtArgs> | null
    /**
     * Filter, which StoryViewer to fetch.
     */
    where?: StoryViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryViewers to fetch.
     */
    orderBy?: StoryViewerOrderByWithRelationInput | StoryViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryViewers.
     */
    cursor?: StoryViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryViewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryViewers.
     */
    distinct?: StoryViewerScalarFieldEnum | StoryViewerScalarFieldEnum[]
  }

  /**
   * StoryViewer findFirstOrThrow
   */
  export type StoryViewerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryViewer
     */
    select?: StoryViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryViewer
     */
    omit?: StoryViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryViewerInclude<ExtArgs> | null
    /**
     * Filter, which StoryViewer to fetch.
     */
    where?: StoryViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryViewers to fetch.
     */
    orderBy?: StoryViewerOrderByWithRelationInput | StoryViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoryViewers.
     */
    cursor?: StoryViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryViewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoryViewers.
     */
    distinct?: StoryViewerScalarFieldEnum | StoryViewerScalarFieldEnum[]
  }

  /**
   * StoryViewer findMany
   */
  export type StoryViewerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryViewer
     */
    select?: StoryViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryViewer
     */
    omit?: StoryViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryViewerInclude<ExtArgs> | null
    /**
     * Filter, which StoryViewers to fetch.
     */
    where?: StoryViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoryViewers to fetch.
     */
    orderBy?: StoryViewerOrderByWithRelationInput | StoryViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoryViewers.
     */
    cursor?: StoryViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoryViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoryViewers.
     */
    skip?: number
    distinct?: StoryViewerScalarFieldEnum | StoryViewerScalarFieldEnum[]
  }

  /**
   * StoryViewer create
   */
  export type StoryViewerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryViewer
     */
    select?: StoryViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryViewer
     */
    omit?: StoryViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryViewerInclude<ExtArgs> | null
    /**
     * The data needed to create a StoryViewer.
     */
    data: XOR<StoryViewerCreateInput, StoryViewerUncheckedCreateInput>
  }

  /**
   * StoryViewer createMany
   */
  export type StoryViewerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoryViewers.
     */
    data: StoryViewerCreateManyInput | StoryViewerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoryViewer createManyAndReturn
   */
  export type StoryViewerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryViewer
     */
    select?: StoryViewerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryViewer
     */
    omit?: StoryViewerOmit<ExtArgs> | null
    /**
     * The data used to create many StoryViewers.
     */
    data: StoryViewerCreateManyInput | StoryViewerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryViewerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryViewer update
   */
  export type StoryViewerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryViewer
     */
    select?: StoryViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryViewer
     */
    omit?: StoryViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryViewerInclude<ExtArgs> | null
    /**
     * The data needed to update a StoryViewer.
     */
    data: XOR<StoryViewerUpdateInput, StoryViewerUncheckedUpdateInput>
    /**
     * Choose, which StoryViewer to update.
     */
    where: StoryViewerWhereUniqueInput
  }

  /**
   * StoryViewer updateMany
   */
  export type StoryViewerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoryViewers.
     */
    data: XOR<StoryViewerUpdateManyMutationInput, StoryViewerUncheckedUpdateManyInput>
    /**
     * Filter which StoryViewers to update
     */
    where?: StoryViewerWhereInput
    /**
     * Limit how many StoryViewers to update.
     */
    limit?: number
  }

  /**
   * StoryViewer updateManyAndReturn
   */
  export type StoryViewerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryViewer
     */
    select?: StoryViewerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StoryViewer
     */
    omit?: StoryViewerOmit<ExtArgs> | null
    /**
     * The data used to update StoryViewers.
     */
    data: XOR<StoryViewerUpdateManyMutationInput, StoryViewerUncheckedUpdateManyInput>
    /**
     * Filter which StoryViewers to update
     */
    where?: StoryViewerWhereInput
    /**
     * Limit how many StoryViewers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryViewerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StoryViewer upsert
   */
  export type StoryViewerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryViewer
     */
    select?: StoryViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryViewer
     */
    omit?: StoryViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryViewerInclude<ExtArgs> | null
    /**
     * The filter to search for the StoryViewer to update in case it exists.
     */
    where: StoryViewerWhereUniqueInput
    /**
     * In case the StoryViewer found by the `where` argument doesn't exist, create a new StoryViewer with this data.
     */
    create: XOR<StoryViewerCreateInput, StoryViewerUncheckedCreateInput>
    /**
     * In case the StoryViewer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoryViewerUpdateInput, StoryViewerUncheckedUpdateInput>
  }

  /**
   * StoryViewer delete
   */
  export type StoryViewerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryViewer
     */
    select?: StoryViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryViewer
     */
    omit?: StoryViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryViewerInclude<ExtArgs> | null
    /**
     * Filter which StoryViewer to delete.
     */
    where: StoryViewerWhereUniqueInput
  }

  /**
   * StoryViewer deleteMany
   */
  export type StoryViewerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoryViewers to delete
     */
    where?: StoryViewerWhereInput
    /**
     * Limit how many StoryViewers to delete.
     */
    limit?: number
  }

  /**
   * StoryViewer without action
   */
  export type StoryViewerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoryViewer
     */
    select?: StoryViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StoryViewer
     */
    omit?: StoryViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoryViewerInclude<ExtArgs> | null
  }


  /**
   * Model PostsViewer
   */

  export type AggregatePostsViewer = {
    _count: PostsViewerCountAggregateOutputType | null
    _min: PostsViewerMinAggregateOutputType | null
    _max: PostsViewerMaxAggregateOutputType | null
  }

  export type PostsViewerMinAggregateOutputType = {
    id: string | null
    postsId: string | null
    usersId: string | null
    viewedAt: Date | null
  }

  export type PostsViewerMaxAggregateOutputType = {
    id: string | null
    postsId: string | null
    usersId: string | null
    viewedAt: Date | null
  }

  export type PostsViewerCountAggregateOutputType = {
    id: number
    postsId: number
    usersId: number
    viewedAt: number
    _all: number
  }


  export type PostsViewerMinAggregateInputType = {
    id?: true
    postsId?: true
    usersId?: true
    viewedAt?: true
  }

  export type PostsViewerMaxAggregateInputType = {
    id?: true
    postsId?: true
    usersId?: true
    viewedAt?: true
  }

  export type PostsViewerCountAggregateInputType = {
    id?: true
    postsId?: true
    usersId?: true
    viewedAt?: true
    _all?: true
  }

  export type PostsViewerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostsViewer to aggregate.
     */
    where?: PostsViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostsViewers to fetch.
     */
    orderBy?: PostsViewerOrderByWithRelationInput | PostsViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostsViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostsViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostsViewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostsViewers
    **/
    _count?: true | PostsViewerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostsViewerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostsViewerMaxAggregateInputType
  }

  export type GetPostsViewerAggregateType<T extends PostsViewerAggregateArgs> = {
        [P in keyof T & keyof AggregatePostsViewer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostsViewer[P]>
      : GetScalarType<T[P], AggregatePostsViewer[P]>
  }




  export type PostsViewerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostsViewerWhereInput
    orderBy?: PostsViewerOrderByWithAggregationInput | PostsViewerOrderByWithAggregationInput[]
    by: PostsViewerScalarFieldEnum[] | PostsViewerScalarFieldEnum
    having?: PostsViewerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostsViewerCountAggregateInputType | true
    _min?: PostsViewerMinAggregateInputType
    _max?: PostsViewerMaxAggregateInputType
  }

  export type PostsViewerGroupByOutputType = {
    id: string
    postsId: string
    usersId: string
    viewedAt: Date
    _count: PostsViewerCountAggregateOutputType | null
    _min: PostsViewerMinAggregateOutputType | null
    _max: PostsViewerMaxAggregateOutputType | null
  }

  type GetPostsViewerGroupByPayload<T extends PostsViewerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostsViewerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostsViewerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostsViewerGroupByOutputType[P]>
            : GetScalarType<T[P], PostsViewerGroupByOutputType[P]>
        }
      >
    >


  export type PostsViewerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postsId?: boolean
    usersId?: boolean
    viewedAt?: boolean
    posts?: boolean | PostsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postsViewer"]>

  export type PostsViewerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postsId?: boolean
    usersId?: boolean
    viewedAt?: boolean
    posts?: boolean | PostsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postsViewer"]>

  export type PostsViewerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postsId?: boolean
    usersId?: boolean
    viewedAt?: boolean
    posts?: boolean | PostsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postsViewer"]>

  export type PostsViewerSelectScalar = {
    id?: boolean
    postsId?: boolean
    usersId?: boolean
    viewedAt?: boolean
  }

  export type PostsViewerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postsId" | "usersId" | "viewedAt", ExtArgs["result"]["postsViewer"]>
  export type PostsViewerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | PostsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type PostsViewerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | PostsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type PostsViewerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | PostsDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $PostsViewerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostsViewer"
    objects: {
      posts: Prisma.$PostsPayload<ExtArgs>
      users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postsId: string
      usersId: string
      viewedAt: Date
    }, ExtArgs["result"]["postsViewer"]>
    composites: {}
  }

  type PostsViewerGetPayload<S extends boolean | null | undefined | PostsViewerDefaultArgs> = $Result.GetResult<Prisma.$PostsViewerPayload, S>

  type PostsViewerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostsViewerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostsViewerCountAggregateInputType | true
    }

  export interface PostsViewerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostsViewer'], meta: { name: 'PostsViewer' } }
    /**
     * Find zero or one PostsViewer that matches the filter.
     * @param {PostsViewerFindUniqueArgs} args - Arguments to find a PostsViewer
     * @example
     * // Get one PostsViewer
     * const postsViewer = await prisma.postsViewer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostsViewerFindUniqueArgs>(args: SelectSubset<T, PostsViewerFindUniqueArgs<ExtArgs>>): Prisma__PostsViewerClient<$Result.GetResult<Prisma.$PostsViewerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostsViewer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostsViewerFindUniqueOrThrowArgs} args - Arguments to find a PostsViewer
     * @example
     * // Get one PostsViewer
     * const postsViewer = await prisma.postsViewer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostsViewerFindUniqueOrThrowArgs>(args: SelectSubset<T, PostsViewerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostsViewerClient<$Result.GetResult<Prisma.$PostsViewerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostsViewer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsViewerFindFirstArgs} args - Arguments to find a PostsViewer
     * @example
     * // Get one PostsViewer
     * const postsViewer = await prisma.postsViewer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostsViewerFindFirstArgs>(args?: SelectSubset<T, PostsViewerFindFirstArgs<ExtArgs>>): Prisma__PostsViewerClient<$Result.GetResult<Prisma.$PostsViewerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostsViewer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsViewerFindFirstOrThrowArgs} args - Arguments to find a PostsViewer
     * @example
     * // Get one PostsViewer
     * const postsViewer = await prisma.postsViewer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostsViewerFindFirstOrThrowArgs>(args?: SelectSubset<T, PostsViewerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostsViewerClient<$Result.GetResult<Prisma.$PostsViewerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostsViewers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsViewerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostsViewers
     * const postsViewers = await prisma.postsViewer.findMany()
     * 
     * // Get first 10 PostsViewers
     * const postsViewers = await prisma.postsViewer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postsViewerWithIdOnly = await prisma.postsViewer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostsViewerFindManyArgs>(args?: SelectSubset<T, PostsViewerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsViewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostsViewer.
     * @param {PostsViewerCreateArgs} args - Arguments to create a PostsViewer.
     * @example
     * // Create one PostsViewer
     * const PostsViewer = await prisma.postsViewer.create({
     *   data: {
     *     // ... data to create a PostsViewer
     *   }
     * })
     * 
     */
    create<T extends PostsViewerCreateArgs>(args: SelectSubset<T, PostsViewerCreateArgs<ExtArgs>>): Prisma__PostsViewerClient<$Result.GetResult<Prisma.$PostsViewerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostsViewers.
     * @param {PostsViewerCreateManyArgs} args - Arguments to create many PostsViewers.
     * @example
     * // Create many PostsViewers
     * const postsViewer = await prisma.postsViewer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostsViewerCreateManyArgs>(args?: SelectSubset<T, PostsViewerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostsViewers and returns the data saved in the database.
     * @param {PostsViewerCreateManyAndReturnArgs} args - Arguments to create many PostsViewers.
     * @example
     * // Create many PostsViewers
     * const postsViewer = await prisma.postsViewer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostsViewers and only return the `id`
     * const postsViewerWithIdOnly = await prisma.postsViewer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostsViewerCreateManyAndReturnArgs>(args?: SelectSubset<T, PostsViewerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsViewerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostsViewer.
     * @param {PostsViewerDeleteArgs} args - Arguments to delete one PostsViewer.
     * @example
     * // Delete one PostsViewer
     * const PostsViewer = await prisma.postsViewer.delete({
     *   where: {
     *     // ... filter to delete one PostsViewer
     *   }
     * })
     * 
     */
    delete<T extends PostsViewerDeleteArgs>(args: SelectSubset<T, PostsViewerDeleteArgs<ExtArgs>>): Prisma__PostsViewerClient<$Result.GetResult<Prisma.$PostsViewerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostsViewer.
     * @param {PostsViewerUpdateArgs} args - Arguments to update one PostsViewer.
     * @example
     * // Update one PostsViewer
     * const postsViewer = await prisma.postsViewer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostsViewerUpdateArgs>(args: SelectSubset<T, PostsViewerUpdateArgs<ExtArgs>>): Prisma__PostsViewerClient<$Result.GetResult<Prisma.$PostsViewerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostsViewers.
     * @param {PostsViewerDeleteManyArgs} args - Arguments to filter PostsViewers to delete.
     * @example
     * // Delete a few PostsViewers
     * const { count } = await prisma.postsViewer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostsViewerDeleteManyArgs>(args?: SelectSubset<T, PostsViewerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostsViewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsViewerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostsViewers
     * const postsViewer = await prisma.postsViewer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostsViewerUpdateManyArgs>(args: SelectSubset<T, PostsViewerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostsViewers and returns the data updated in the database.
     * @param {PostsViewerUpdateManyAndReturnArgs} args - Arguments to update many PostsViewers.
     * @example
     * // Update many PostsViewers
     * const postsViewer = await prisma.postsViewer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostsViewers and only return the `id`
     * const postsViewerWithIdOnly = await prisma.postsViewer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostsViewerUpdateManyAndReturnArgs>(args: SelectSubset<T, PostsViewerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsViewerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostsViewer.
     * @param {PostsViewerUpsertArgs} args - Arguments to update or create a PostsViewer.
     * @example
     * // Update or create a PostsViewer
     * const postsViewer = await prisma.postsViewer.upsert({
     *   create: {
     *     // ... data to create a PostsViewer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostsViewer we want to update
     *   }
     * })
     */
    upsert<T extends PostsViewerUpsertArgs>(args: SelectSubset<T, PostsViewerUpsertArgs<ExtArgs>>): Prisma__PostsViewerClient<$Result.GetResult<Prisma.$PostsViewerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostsViewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsViewerCountArgs} args - Arguments to filter PostsViewers to count.
     * @example
     * // Count the number of PostsViewers
     * const count = await prisma.postsViewer.count({
     *   where: {
     *     // ... the filter for the PostsViewers we want to count
     *   }
     * })
    **/
    count<T extends PostsViewerCountArgs>(
      args?: Subset<T, PostsViewerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostsViewerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostsViewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsViewerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostsViewerAggregateArgs>(args: Subset<T, PostsViewerAggregateArgs>): Prisma.PrismaPromise<GetPostsViewerAggregateType<T>>

    /**
     * Group by PostsViewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsViewerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostsViewerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostsViewerGroupByArgs['orderBy'] }
        : { orderBy?: PostsViewerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostsViewerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostsViewerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostsViewer model
   */
  readonly fields: PostsViewerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostsViewer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostsViewerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends PostsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostsDefaultArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostsViewer model
   */
  interface PostsViewerFieldRefs {
    readonly id: FieldRef<"PostsViewer", 'String'>
    readonly postsId: FieldRef<"PostsViewer", 'String'>
    readonly usersId: FieldRef<"PostsViewer", 'String'>
    readonly viewedAt: FieldRef<"PostsViewer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostsViewer findUnique
   */
  export type PostsViewerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsViewer
     */
    select?: PostsViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsViewer
     */
    omit?: PostsViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsViewerInclude<ExtArgs> | null
    /**
     * Filter, which PostsViewer to fetch.
     */
    where: PostsViewerWhereUniqueInput
  }

  /**
   * PostsViewer findUniqueOrThrow
   */
  export type PostsViewerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsViewer
     */
    select?: PostsViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsViewer
     */
    omit?: PostsViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsViewerInclude<ExtArgs> | null
    /**
     * Filter, which PostsViewer to fetch.
     */
    where: PostsViewerWhereUniqueInput
  }

  /**
   * PostsViewer findFirst
   */
  export type PostsViewerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsViewer
     */
    select?: PostsViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsViewer
     */
    omit?: PostsViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsViewerInclude<ExtArgs> | null
    /**
     * Filter, which PostsViewer to fetch.
     */
    where?: PostsViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostsViewers to fetch.
     */
    orderBy?: PostsViewerOrderByWithRelationInput | PostsViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostsViewers.
     */
    cursor?: PostsViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostsViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostsViewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostsViewers.
     */
    distinct?: PostsViewerScalarFieldEnum | PostsViewerScalarFieldEnum[]
  }

  /**
   * PostsViewer findFirstOrThrow
   */
  export type PostsViewerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsViewer
     */
    select?: PostsViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsViewer
     */
    omit?: PostsViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsViewerInclude<ExtArgs> | null
    /**
     * Filter, which PostsViewer to fetch.
     */
    where?: PostsViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostsViewers to fetch.
     */
    orderBy?: PostsViewerOrderByWithRelationInput | PostsViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostsViewers.
     */
    cursor?: PostsViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostsViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostsViewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostsViewers.
     */
    distinct?: PostsViewerScalarFieldEnum | PostsViewerScalarFieldEnum[]
  }

  /**
   * PostsViewer findMany
   */
  export type PostsViewerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsViewer
     */
    select?: PostsViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsViewer
     */
    omit?: PostsViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsViewerInclude<ExtArgs> | null
    /**
     * Filter, which PostsViewers to fetch.
     */
    where?: PostsViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostsViewers to fetch.
     */
    orderBy?: PostsViewerOrderByWithRelationInput | PostsViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostsViewers.
     */
    cursor?: PostsViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostsViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostsViewers.
     */
    skip?: number
    distinct?: PostsViewerScalarFieldEnum | PostsViewerScalarFieldEnum[]
  }

  /**
   * PostsViewer create
   */
  export type PostsViewerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsViewer
     */
    select?: PostsViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsViewer
     */
    omit?: PostsViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsViewerInclude<ExtArgs> | null
    /**
     * The data needed to create a PostsViewer.
     */
    data: XOR<PostsViewerCreateInput, PostsViewerUncheckedCreateInput>
  }

  /**
   * PostsViewer createMany
   */
  export type PostsViewerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostsViewers.
     */
    data: PostsViewerCreateManyInput | PostsViewerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostsViewer createManyAndReturn
   */
  export type PostsViewerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsViewer
     */
    select?: PostsViewerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostsViewer
     */
    omit?: PostsViewerOmit<ExtArgs> | null
    /**
     * The data used to create many PostsViewers.
     */
    data: PostsViewerCreateManyInput | PostsViewerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsViewerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostsViewer update
   */
  export type PostsViewerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsViewer
     */
    select?: PostsViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsViewer
     */
    omit?: PostsViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsViewerInclude<ExtArgs> | null
    /**
     * The data needed to update a PostsViewer.
     */
    data: XOR<PostsViewerUpdateInput, PostsViewerUncheckedUpdateInput>
    /**
     * Choose, which PostsViewer to update.
     */
    where: PostsViewerWhereUniqueInput
  }

  /**
   * PostsViewer updateMany
   */
  export type PostsViewerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostsViewers.
     */
    data: XOR<PostsViewerUpdateManyMutationInput, PostsViewerUncheckedUpdateManyInput>
    /**
     * Filter which PostsViewers to update
     */
    where?: PostsViewerWhereInput
    /**
     * Limit how many PostsViewers to update.
     */
    limit?: number
  }

  /**
   * PostsViewer updateManyAndReturn
   */
  export type PostsViewerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsViewer
     */
    select?: PostsViewerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostsViewer
     */
    omit?: PostsViewerOmit<ExtArgs> | null
    /**
     * The data used to update PostsViewers.
     */
    data: XOR<PostsViewerUpdateManyMutationInput, PostsViewerUncheckedUpdateManyInput>
    /**
     * Filter which PostsViewers to update
     */
    where?: PostsViewerWhereInput
    /**
     * Limit how many PostsViewers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsViewerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostsViewer upsert
   */
  export type PostsViewerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsViewer
     */
    select?: PostsViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsViewer
     */
    omit?: PostsViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsViewerInclude<ExtArgs> | null
    /**
     * The filter to search for the PostsViewer to update in case it exists.
     */
    where: PostsViewerWhereUniqueInput
    /**
     * In case the PostsViewer found by the `where` argument doesn't exist, create a new PostsViewer with this data.
     */
    create: XOR<PostsViewerCreateInput, PostsViewerUncheckedCreateInput>
    /**
     * In case the PostsViewer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostsViewerUpdateInput, PostsViewerUncheckedUpdateInput>
  }

  /**
   * PostsViewer delete
   */
  export type PostsViewerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsViewer
     */
    select?: PostsViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsViewer
     */
    omit?: PostsViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsViewerInclude<ExtArgs> | null
    /**
     * Filter which PostsViewer to delete.
     */
    where: PostsViewerWhereUniqueInput
  }

  /**
   * PostsViewer deleteMany
   */
  export type PostsViewerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostsViewers to delete
     */
    where?: PostsViewerWhereInput
    /**
     * Limit how many PostsViewers to delete.
     */
    limit?: number
  }

  /**
   * PostsViewer without action
   */
  export type PostsViewerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsViewer
     */
    select?: PostsViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostsViewer
     */
    omit?: PostsViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsViewerInclude<ExtArgs> | null
  }


  /**
   * Model CommentViewer
   */

  export type AggregateCommentViewer = {
    _count: CommentViewerCountAggregateOutputType | null
    _min: CommentViewerMinAggregateOutputType | null
    _max: CommentViewerMaxAggregateOutputType | null
  }

  export type CommentViewerMinAggregateOutputType = {
    id: string | null
    commentId: string | null
    usersId: string | null
    readAt: Date | null
  }

  export type CommentViewerMaxAggregateOutputType = {
    id: string | null
    commentId: string | null
    usersId: string | null
    readAt: Date | null
  }

  export type CommentViewerCountAggregateOutputType = {
    id: number
    commentId: number
    usersId: number
    readAt: number
    _all: number
  }


  export type CommentViewerMinAggregateInputType = {
    id?: true
    commentId?: true
    usersId?: true
    readAt?: true
  }

  export type CommentViewerMaxAggregateInputType = {
    id?: true
    commentId?: true
    usersId?: true
    readAt?: true
  }

  export type CommentViewerCountAggregateInputType = {
    id?: true
    commentId?: true
    usersId?: true
    readAt?: true
    _all?: true
  }

  export type CommentViewerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentViewer to aggregate.
     */
    where?: CommentViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentViewers to fetch.
     */
    orderBy?: CommentViewerOrderByWithRelationInput | CommentViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentViewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentViewers
    **/
    _count?: true | CommentViewerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentViewerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentViewerMaxAggregateInputType
  }

  export type GetCommentViewerAggregateType<T extends CommentViewerAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentViewer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentViewer[P]>
      : GetScalarType<T[P], AggregateCommentViewer[P]>
  }




  export type CommentViewerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentViewerWhereInput
    orderBy?: CommentViewerOrderByWithAggregationInput | CommentViewerOrderByWithAggregationInput[]
    by: CommentViewerScalarFieldEnum[] | CommentViewerScalarFieldEnum
    having?: CommentViewerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentViewerCountAggregateInputType | true
    _min?: CommentViewerMinAggregateInputType
    _max?: CommentViewerMaxAggregateInputType
  }

  export type CommentViewerGroupByOutputType = {
    id: string
    commentId: string
    usersId: string
    readAt: Date
    _count: CommentViewerCountAggregateOutputType | null
    _min: CommentViewerMinAggregateOutputType | null
    _max: CommentViewerMaxAggregateOutputType | null
  }

  type GetCommentViewerGroupByPayload<T extends CommentViewerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentViewerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentViewerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentViewerGroupByOutputType[P]>
            : GetScalarType<T[P], CommentViewerGroupByOutputType[P]>
        }
      >
    >


  export type CommentViewerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    usersId?: boolean
    readAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentViewer"]>

  export type CommentViewerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    usersId?: boolean
    readAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentViewer"]>

  export type CommentViewerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    usersId?: boolean
    readAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentViewer"]>

  export type CommentViewerSelectScalar = {
    id?: boolean
    commentId?: boolean
    usersId?: boolean
    readAt?: boolean
  }

  export type CommentViewerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "commentId" | "usersId" | "readAt", ExtArgs["result"]["commentViewer"]>
  export type CommentViewerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type CommentViewerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type CommentViewerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $CommentViewerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommentViewer"
    objects: {
      comment: Prisma.$CommentPayload<ExtArgs>
      users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      commentId: string
      usersId: string
      readAt: Date
    }, ExtArgs["result"]["commentViewer"]>
    composites: {}
  }

  type CommentViewerGetPayload<S extends boolean | null | undefined | CommentViewerDefaultArgs> = $Result.GetResult<Prisma.$CommentViewerPayload, S>

  type CommentViewerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentViewerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentViewerCountAggregateInputType | true
    }

  export interface CommentViewerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentViewer'], meta: { name: 'CommentViewer' } }
    /**
     * Find zero or one CommentViewer that matches the filter.
     * @param {CommentViewerFindUniqueArgs} args - Arguments to find a CommentViewer
     * @example
     * // Get one CommentViewer
     * const commentViewer = await prisma.commentViewer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentViewerFindUniqueArgs>(args: SelectSubset<T, CommentViewerFindUniqueArgs<ExtArgs>>): Prisma__CommentViewerClient<$Result.GetResult<Prisma.$CommentViewerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommentViewer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentViewerFindUniqueOrThrowArgs} args - Arguments to find a CommentViewer
     * @example
     * // Get one CommentViewer
     * const commentViewer = await prisma.commentViewer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentViewerFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentViewerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentViewerClient<$Result.GetResult<Prisma.$CommentViewerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentViewer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentViewerFindFirstArgs} args - Arguments to find a CommentViewer
     * @example
     * // Get one CommentViewer
     * const commentViewer = await prisma.commentViewer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentViewerFindFirstArgs>(args?: SelectSubset<T, CommentViewerFindFirstArgs<ExtArgs>>): Prisma__CommentViewerClient<$Result.GetResult<Prisma.$CommentViewerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentViewer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentViewerFindFirstOrThrowArgs} args - Arguments to find a CommentViewer
     * @example
     * // Get one CommentViewer
     * const commentViewer = await prisma.commentViewer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentViewerFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentViewerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentViewerClient<$Result.GetResult<Prisma.$CommentViewerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommentViewers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentViewerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentViewers
     * const commentViewers = await prisma.commentViewer.findMany()
     * 
     * // Get first 10 CommentViewers
     * const commentViewers = await prisma.commentViewer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentViewerWithIdOnly = await prisma.commentViewer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentViewerFindManyArgs>(args?: SelectSubset<T, CommentViewerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentViewerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommentViewer.
     * @param {CommentViewerCreateArgs} args - Arguments to create a CommentViewer.
     * @example
     * // Create one CommentViewer
     * const CommentViewer = await prisma.commentViewer.create({
     *   data: {
     *     // ... data to create a CommentViewer
     *   }
     * })
     * 
     */
    create<T extends CommentViewerCreateArgs>(args: SelectSubset<T, CommentViewerCreateArgs<ExtArgs>>): Prisma__CommentViewerClient<$Result.GetResult<Prisma.$CommentViewerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommentViewers.
     * @param {CommentViewerCreateManyArgs} args - Arguments to create many CommentViewers.
     * @example
     * // Create many CommentViewers
     * const commentViewer = await prisma.commentViewer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentViewerCreateManyArgs>(args?: SelectSubset<T, CommentViewerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommentViewers and returns the data saved in the database.
     * @param {CommentViewerCreateManyAndReturnArgs} args - Arguments to create many CommentViewers.
     * @example
     * // Create many CommentViewers
     * const commentViewer = await prisma.commentViewer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommentViewers and only return the `id`
     * const commentViewerWithIdOnly = await prisma.commentViewer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentViewerCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentViewerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentViewerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommentViewer.
     * @param {CommentViewerDeleteArgs} args - Arguments to delete one CommentViewer.
     * @example
     * // Delete one CommentViewer
     * const CommentViewer = await prisma.commentViewer.delete({
     *   where: {
     *     // ... filter to delete one CommentViewer
     *   }
     * })
     * 
     */
    delete<T extends CommentViewerDeleteArgs>(args: SelectSubset<T, CommentViewerDeleteArgs<ExtArgs>>): Prisma__CommentViewerClient<$Result.GetResult<Prisma.$CommentViewerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommentViewer.
     * @param {CommentViewerUpdateArgs} args - Arguments to update one CommentViewer.
     * @example
     * // Update one CommentViewer
     * const commentViewer = await prisma.commentViewer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentViewerUpdateArgs>(args: SelectSubset<T, CommentViewerUpdateArgs<ExtArgs>>): Prisma__CommentViewerClient<$Result.GetResult<Prisma.$CommentViewerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommentViewers.
     * @param {CommentViewerDeleteManyArgs} args - Arguments to filter CommentViewers to delete.
     * @example
     * // Delete a few CommentViewers
     * const { count } = await prisma.commentViewer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentViewerDeleteManyArgs>(args?: SelectSubset<T, CommentViewerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentViewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentViewerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentViewers
     * const commentViewer = await prisma.commentViewer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentViewerUpdateManyArgs>(args: SelectSubset<T, CommentViewerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentViewers and returns the data updated in the database.
     * @param {CommentViewerUpdateManyAndReturnArgs} args - Arguments to update many CommentViewers.
     * @example
     * // Update many CommentViewers
     * const commentViewer = await prisma.commentViewer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommentViewers and only return the `id`
     * const commentViewerWithIdOnly = await prisma.commentViewer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentViewerUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentViewerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentViewerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommentViewer.
     * @param {CommentViewerUpsertArgs} args - Arguments to update or create a CommentViewer.
     * @example
     * // Update or create a CommentViewer
     * const commentViewer = await prisma.commentViewer.upsert({
     *   create: {
     *     // ... data to create a CommentViewer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentViewer we want to update
     *   }
     * })
     */
    upsert<T extends CommentViewerUpsertArgs>(args: SelectSubset<T, CommentViewerUpsertArgs<ExtArgs>>): Prisma__CommentViewerClient<$Result.GetResult<Prisma.$CommentViewerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommentViewers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentViewerCountArgs} args - Arguments to filter CommentViewers to count.
     * @example
     * // Count the number of CommentViewers
     * const count = await prisma.commentViewer.count({
     *   where: {
     *     // ... the filter for the CommentViewers we want to count
     *   }
     * })
    **/
    count<T extends CommentViewerCountArgs>(
      args?: Subset<T, CommentViewerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentViewerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentViewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentViewerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentViewerAggregateArgs>(args: Subset<T, CommentViewerAggregateArgs>): Prisma.PrismaPromise<GetCommentViewerAggregateType<T>>

    /**
     * Group by CommentViewer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentViewerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentViewerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentViewerGroupByArgs['orderBy'] }
        : { orderBy?: CommentViewerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentViewerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentViewerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommentViewer model
   */
  readonly fields: CommentViewerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentViewer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentViewerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommentViewer model
   */
  interface CommentViewerFieldRefs {
    readonly id: FieldRef<"CommentViewer", 'String'>
    readonly commentId: FieldRef<"CommentViewer", 'String'>
    readonly usersId: FieldRef<"CommentViewer", 'String'>
    readonly readAt: FieldRef<"CommentViewer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommentViewer findUnique
   */
  export type CommentViewerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentViewer
     */
    select?: CommentViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentViewer
     */
    omit?: CommentViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentViewerInclude<ExtArgs> | null
    /**
     * Filter, which CommentViewer to fetch.
     */
    where: CommentViewerWhereUniqueInput
  }

  /**
   * CommentViewer findUniqueOrThrow
   */
  export type CommentViewerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentViewer
     */
    select?: CommentViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentViewer
     */
    omit?: CommentViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentViewerInclude<ExtArgs> | null
    /**
     * Filter, which CommentViewer to fetch.
     */
    where: CommentViewerWhereUniqueInput
  }

  /**
   * CommentViewer findFirst
   */
  export type CommentViewerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentViewer
     */
    select?: CommentViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentViewer
     */
    omit?: CommentViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentViewerInclude<ExtArgs> | null
    /**
     * Filter, which CommentViewer to fetch.
     */
    where?: CommentViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentViewers to fetch.
     */
    orderBy?: CommentViewerOrderByWithRelationInput | CommentViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentViewers.
     */
    cursor?: CommentViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentViewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentViewers.
     */
    distinct?: CommentViewerScalarFieldEnum | CommentViewerScalarFieldEnum[]
  }

  /**
   * CommentViewer findFirstOrThrow
   */
  export type CommentViewerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentViewer
     */
    select?: CommentViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentViewer
     */
    omit?: CommentViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentViewerInclude<ExtArgs> | null
    /**
     * Filter, which CommentViewer to fetch.
     */
    where?: CommentViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentViewers to fetch.
     */
    orderBy?: CommentViewerOrderByWithRelationInput | CommentViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentViewers.
     */
    cursor?: CommentViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentViewers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentViewers.
     */
    distinct?: CommentViewerScalarFieldEnum | CommentViewerScalarFieldEnum[]
  }

  /**
   * CommentViewer findMany
   */
  export type CommentViewerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentViewer
     */
    select?: CommentViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentViewer
     */
    omit?: CommentViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentViewerInclude<ExtArgs> | null
    /**
     * Filter, which CommentViewers to fetch.
     */
    where?: CommentViewerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentViewers to fetch.
     */
    orderBy?: CommentViewerOrderByWithRelationInput | CommentViewerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentViewers.
     */
    cursor?: CommentViewerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentViewers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentViewers.
     */
    skip?: number
    distinct?: CommentViewerScalarFieldEnum | CommentViewerScalarFieldEnum[]
  }

  /**
   * CommentViewer create
   */
  export type CommentViewerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentViewer
     */
    select?: CommentViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentViewer
     */
    omit?: CommentViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentViewerInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentViewer.
     */
    data: XOR<CommentViewerCreateInput, CommentViewerUncheckedCreateInput>
  }

  /**
   * CommentViewer createMany
   */
  export type CommentViewerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommentViewers.
     */
    data: CommentViewerCreateManyInput | CommentViewerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommentViewer createManyAndReturn
   */
  export type CommentViewerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentViewer
     */
    select?: CommentViewerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentViewer
     */
    omit?: CommentViewerOmit<ExtArgs> | null
    /**
     * The data used to create many CommentViewers.
     */
    data: CommentViewerCreateManyInput | CommentViewerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentViewerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentViewer update
   */
  export type CommentViewerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentViewer
     */
    select?: CommentViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentViewer
     */
    omit?: CommentViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentViewerInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentViewer.
     */
    data: XOR<CommentViewerUpdateInput, CommentViewerUncheckedUpdateInput>
    /**
     * Choose, which CommentViewer to update.
     */
    where: CommentViewerWhereUniqueInput
  }

  /**
   * CommentViewer updateMany
   */
  export type CommentViewerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommentViewers.
     */
    data: XOR<CommentViewerUpdateManyMutationInput, CommentViewerUncheckedUpdateManyInput>
    /**
     * Filter which CommentViewers to update
     */
    where?: CommentViewerWhereInput
    /**
     * Limit how many CommentViewers to update.
     */
    limit?: number
  }

  /**
   * CommentViewer updateManyAndReturn
   */
  export type CommentViewerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentViewer
     */
    select?: CommentViewerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentViewer
     */
    omit?: CommentViewerOmit<ExtArgs> | null
    /**
     * The data used to update CommentViewers.
     */
    data: XOR<CommentViewerUpdateManyMutationInput, CommentViewerUncheckedUpdateManyInput>
    /**
     * Filter which CommentViewers to update
     */
    where?: CommentViewerWhereInput
    /**
     * Limit how many CommentViewers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentViewerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentViewer upsert
   */
  export type CommentViewerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentViewer
     */
    select?: CommentViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentViewer
     */
    omit?: CommentViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentViewerInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentViewer to update in case it exists.
     */
    where: CommentViewerWhereUniqueInput
    /**
     * In case the CommentViewer found by the `where` argument doesn't exist, create a new CommentViewer with this data.
     */
    create: XOR<CommentViewerCreateInput, CommentViewerUncheckedCreateInput>
    /**
     * In case the CommentViewer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentViewerUpdateInput, CommentViewerUncheckedUpdateInput>
  }

  /**
   * CommentViewer delete
   */
  export type CommentViewerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentViewer
     */
    select?: CommentViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentViewer
     */
    omit?: CommentViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentViewerInclude<ExtArgs> | null
    /**
     * Filter which CommentViewer to delete.
     */
    where: CommentViewerWhereUniqueInput
  }

  /**
   * CommentViewer deleteMany
   */
  export type CommentViewerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentViewers to delete
     */
    where?: CommentViewerWhereInput
    /**
     * Limit how many CommentViewers to delete.
     */
    limit?: number
  }

  /**
   * CommentViewer without action
   */
  export type CommentViewerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentViewer
     */
    select?: CommentViewerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentViewer
     */
    omit?: CommentViewerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentViewerInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    username: 'username',
    fullname: 'fullname',
    email: 'email',
    password: 'password',
    profile_image: 'profile_image',
    banner: 'banner',
    bio: 'bio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const PostsScalarFieldEnum: {
    id: 'id',
    usersId: 'usersId',
    contentText: 'contentText',
    contentImage: 'contentImage',
    mediaType: 'mediaType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostsScalarFieldEnum = (typeof PostsScalarFieldEnum)[keyof typeof PostsScalarFieldEnum]


  export const StoryScalarFieldEnum: {
    id: 'id',
    usersId: 'usersId',
    contentText: 'contentText',
    contentMedia: 'contentMedia',
    mediaType: 'mediaType',
    createdAt: 'createdAt',
    expirationTime: 'expirationTime'
  };

  export type StoryScalarFieldEnum = (typeof StoryScalarFieldEnum)[keyof typeof StoryScalarFieldEnum]


  export const LikeScalarFieldEnum: {
    id: 'id',
    usersId: 'usersId',
    postsId: 'postsId',
    storyId: 'storyId',
    createdAt: 'createdAt'
  };

  export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    usersId: 'usersId',
    postsId: 'postsId',
    storyId: 'storyId',
    content: 'content',
    mediaUrl: 'mediaUrl',
    mediaType: 'mediaType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const RePostsScalarFieldEnum: {
    id: 'id',
    usersId: 'usersId',
    originalPostsId: 'originalPostsId',
    createdAt: 'createdAt'
  };

  export type RePostsScalarFieldEnum = (typeof RePostsScalarFieldEnum)[keyof typeof RePostsScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    postsId: 'postsId',
    commentId: 'commentId',
    storyId: 'storyId',
    filePath: 'filePath',
    fileType: 'fileType',
    createdAt: 'createdAt'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    usersId: 'usersId',
    relatedUsersId: 'relatedUsersId',
    postsId: 'postsId',
    commentId: 'commentId',
    storyId: 'storyId',
    type: 'type',
    readStatus: 'readStatus',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const MessagesScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    receiverId: 'receiverId',
    contentText: 'contentText',
    mediaUrl: 'mediaUrl',
    mediaType: 'mediaType',
    readStatus: 'readStatus',
    createdAt: 'createdAt'
  };

  export type MessagesScalarFieldEnum = (typeof MessagesScalarFieldEnum)[keyof typeof MessagesScalarFieldEnum]


  export const FriendsScalarFieldEnum: {
    id: 'id',
    usersId: 'usersId',
    friendId: 'friendId',
    friendStatus: 'friendStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FriendsScalarFieldEnum = (typeof FriendsScalarFieldEnum)[keyof typeof FriendsScalarFieldEnum]


  export const FollowersScalarFieldEnum: {
    id: 'id',
    followerId: 'followerId',
    followingId: 'followingId',
    createdAt: 'createdAt'
  };

  export type FollowersScalarFieldEnum = (typeof FollowersScalarFieldEnum)[keyof typeof FollowersScalarFieldEnum]


  export const StoryViewerScalarFieldEnum: {
    id: 'id',
    storyId: 'storyId',
    usersId: 'usersId',
    readAt: 'readAt'
  };

  export type StoryViewerScalarFieldEnum = (typeof StoryViewerScalarFieldEnum)[keyof typeof StoryViewerScalarFieldEnum]


  export const PostsViewerScalarFieldEnum: {
    id: 'id',
    postsId: 'postsId',
    usersId: 'usersId',
    viewedAt: 'viewedAt'
  };

  export type PostsViewerScalarFieldEnum = (typeof PostsViewerScalarFieldEnum)[keyof typeof PostsViewerScalarFieldEnum]


  export const CommentViewerScalarFieldEnum: {
    id: 'id',
    commentId: 'commentId',
    usersId: 'usersId',
    readAt: 'readAt'
  };

  export type CommentViewerScalarFieldEnum = (typeof CommentViewerScalarFieldEnum)[keyof typeof CommentViewerScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'FileType'
   */
  export type EnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType'>
    


  /**
   * Reference to a field of type 'FileType[]'
   */
  export type ListEnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'FriendStatus'
   */
  export type EnumFriendStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendStatus'>
    


  /**
   * Reference to a field of type 'FriendStatus[]'
   */
  export type ListEnumFriendStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: StringFilter<"Users"> | string
    username?: StringFilter<"Users"> | string
    fullname?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    profile_image?: StringNullableFilter<"Users"> | string | null
    banner?: StringNullableFilter<"Users"> | string | null
    bio?: StringNullableFilter<"Users"> | string | null
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    posts?: PostsListRelationFilter
    stories?: StoryListRelationFilter
    likes?: LikeListRelationFilter
    comments?: CommentListRelationFilter
    reposts?: RePostsListRelationFilter
    notifications?: NotificationListRelationFilter
    relatedNotifications?: NotificationListRelationFilter
    messagesSent?: MessagesListRelationFilter
    messagesReceived?: MessagesListRelationFilter
    friends?: FriendsListRelationFilter
    friendOf?: FriendsListRelationFilter
    followers?: FollowersListRelationFilter
    following?: FollowersListRelationFilter
    storyViewers?: StoryViewerListRelationFilter
    postViewers?: PostsViewerListRelationFilter
    commentViewers?: CommentViewerListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profile_image?: SortOrderInput | SortOrder
    banner?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: PostsOrderByRelationAggregateInput
    stories?: StoryOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    reposts?: RePostsOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    relatedNotifications?: NotificationOrderByRelationAggregateInput
    messagesSent?: MessagesOrderByRelationAggregateInput
    messagesReceived?: MessagesOrderByRelationAggregateInput
    friends?: FriendsOrderByRelationAggregateInput
    friendOf?: FriendsOrderByRelationAggregateInput
    followers?: FollowersOrderByRelationAggregateInput
    following?: FollowersOrderByRelationAggregateInput
    storyViewers?: StoryViewerOrderByRelationAggregateInput
    postViewers?: PostsViewerOrderByRelationAggregateInput
    commentViewers?: CommentViewerOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    fullname?: StringFilter<"Users"> | string
    password?: StringFilter<"Users"> | string
    profile_image?: StringNullableFilter<"Users"> | string | null
    banner?: StringNullableFilter<"Users"> | string | null
    bio?: StringNullableFilter<"Users"> | string | null
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    posts?: PostsListRelationFilter
    stories?: StoryListRelationFilter
    likes?: LikeListRelationFilter
    comments?: CommentListRelationFilter
    reposts?: RePostsListRelationFilter
    notifications?: NotificationListRelationFilter
    relatedNotifications?: NotificationListRelationFilter
    messagesSent?: MessagesListRelationFilter
    messagesReceived?: MessagesListRelationFilter
    friends?: FriendsListRelationFilter
    friendOf?: FriendsListRelationFilter
    followers?: FollowersListRelationFilter
    following?: FollowersListRelationFilter
    storyViewers?: StoryViewerListRelationFilter
    postViewers?: PostsViewerListRelationFilter
    commentViewers?: CommentViewerListRelationFilter
  }, "id" | "username" | "email">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profile_image?: SortOrderInput | SortOrder
    banner?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Users"> | string
    username?: StringWithAggregatesFilter<"Users"> | string
    fullname?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    password?: StringWithAggregatesFilter<"Users"> | string
    profile_image?: StringNullableWithAggregatesFilter<"Users"> | string | null
    banner?: StringNullableWithAggregatesFilter<"Users"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Users"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
  }

  export type PostsWhereInput = {
    AND?: PostsWhereInput | PostsWhereInput[]
    OR?: PostsWhereInput[]
    NOT?: PostsWhereInput | PostsWhereInput[]
    id?: StringFilter<"Posts"> | string
    usersId?: StringFilter<"Posts"> | string
    contentText?: StringNullableFilter<"Posts"> | string | null
    contentImage?: StringNullableFilter<"Posts"> | string | null
    mediaType?: EnumMediaTypeFilter<"Posts"> | $Enums.MediaType
    createdAt?: DateTimeFilter<"Posts"> | Date | string
    updatedAt?: DateTimeFilter<"Posts"> | Date | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    reposts?: RePostsListRelationFilter
    attachments?: AttachmentListRelationFilter
    viewers?: PostsViewerListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type PostsOrderByWithRelationInput = {
    id?: SortOrder
    usersId?: SortOrder
    contentText?: SortOrderInput | SortOrder
    contentImage?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UsersOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
    reposts?: RePostsOrderByRelationAggregateInput
    attachments?: AttachmentOrderByRelationAggregateInput
    viewers?: PostsViewerOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type PostsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostsWhereInput | PostsWhereInput[]
    OR?: PostsWhereInput[]
    NOT?: PostsWhereInput | PostsWhereInput[]
    usersId?: StringFilter<"Posts"> | string
    contentText?: StringNullableFilter<"Posts"> | string | null
    contentImage?: StringNullableFilter<"Posts"> | string | null
    mediaType?: EnumMediaTypeFilter<"Posts"> | $Enums.MediaType
    createdAt?: DateTimeFilter<"Posts"> | Date | string
    updatedAt?: DateTimeFilter<"Posts"> | Date | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    comments?: CommentListRelationFilter
    likes?: LikeListRelationFilter
    reposts?: RePostsListRelationFilter
    attachments?: AttachmentListRelationFilter
    viewers?: PostsViewerListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type PostsOrderByWithAggregationInput = {
    id?: SortOrder
    usersId?: SortOrder
    contentText?: SortOrderInput | SortOrder
    contentImage?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostsCountOrderByAggregateInput
    _max?: PostsMaxOrderByAggregateInput
    _min?: PostsMinOrderByAggregateInput
  }

  export type PostsScalarWhereWithAggregatesInput = {
    AND?: PostsScalarWhereWithAggregatesInput | PostsScalarWhereWithAggregatesInput[]
    OR?: PostsScalarWhereWithAggregatesInput[]
    NOT?: PostsScalarWhereWithAggregatesInput | PostsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Posts"> | string
    usersId?: StringWithAggregatesFilter<"Posts"> | string
    contentText?: StringNullableWithAggregatesFilter<"Posts"> | string | null
    contentImage?: StringNullableWithAggregatesFilter<"Posts"> | string | null
    mediaType?: EnumMediaTypeWithAggregatesFilter<"Posts"> | $Enums.MediaType
    createdAt?: DateTimeWithAggregatesFilter<"Posts"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Posts"> | Date | string
  }

  export type StoryWhereInput = {
    AND?: StoryWhereInput | StoryWhereInput[]
    OR?: StoryWhereInput[]
    NOT?: StoryWhereInput | StoryWhereInput[]
    id?: StringFilter<"Story"> | string
    usersId?: StringFilter<"Story"> | string
    contentText?: StringNullableFilter<"Story"> | string | null
    contentMedia?: StringNullableFilter<"Story"> | string | null
    mediaType?: EnumMediaTypeFilter<"Story"> | $Enums.MediaType
    createdAt?: DateTimeFilter<"Story"> | Date | string
    expirationTime?: DateTimeFilter<"Story"> | Date | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    viewers?: StoryViewerListRelationFilter
    likes?: LikeListRelationFilter
    comments?: CommentListRelationFilter
    attachments?: AttachmentListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type StoryOrderByWithRelationInput = {
    id?: SortOrder
    usersId?: SortOrder
    contentText?: SortOrderInput | SortOrder
    contentMedia?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    expirationTime?: SortOrder
    users?: UsersOrderByWithRelationInput
    viewers?: StoryViewerOrderByRelationAggregateInput
    likes?: LikeOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    attachments?: AttachmentOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type StoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoryWhereInput | StoryWhereInput[]
    OR?: StoryWhereInput[]
    NOT?: StoryWhereInput | StoryWhereInput[]
    usersId?: StringFilter<"Story"> | string
    contentText?: StringNullableFilter<"Story"> | string | null
    contentMedia?: StringNullableFilter<"Story"> | string | null
    mediaType?: EnumMediaTypeFilter<"Story"> | $Enums.MediaType
    createdAt?: DateTimeFilter<"Story"> | Date | string
    expirationTime?: DateTimeFilter<"Story"> | Date | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    viewers?: StoryViewerListRelationFilter
    likes?: LikeListRelationFilter
    comments?: CommentListRelationFilter
    attachments?: AttachmentListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type StoryOrderByWithAggregationInput = {
    id?: SortOrder
    usersId?: SortOrder
    contentText?: SortOrderInput | SortOrder
    contentMedia?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    expirationTime?: SortOrder
    _count?: StoryCountOrderByAggregateInput
    _max?: StoryMaxOrderByAggregateInput
    _min?: StoryMinOrderByAggregateInput
  }

  export type StoryScalarWhereWithAggregatesInput = {
    AND?: StoryScalarWhereWithAggregatesInput | StoryScalarWhereWithAggregatesInput[]
    OR?: StoryScalarWhereWithAggregatesInput[]
    NOT?: StoryScalarWhereWithAggregatesInput | StoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Story"> | string
    usersId?: StringWithAggregatesFilter<"Story"> | string
    contentText?: StringNullableWithAggregatesFilter<"Story"> | string | null
    contentMedia?: StringNullableWithAggregatesFilter<"Story"> | string | null
    mediaType?: EnumMediaTypeWithAggregatesFilter<"Story"> | $Enums.MediaType
    createdAt?: DateTimeWithAggregatesFilter<"Story"> | Date | string
    expirationTime?: DateTimeWithAggregatesFilter<"Story"> | Date | string
  }

  export type LikeWhereInput = {
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    id?: StringFilter<"Like"> | string
    usersId?: StringFilter<"Like"> | string
    postsId?: StringNullableFilter<"Like"> | string | null
    storyId?: StringNullableFilter<"Like"> | string | null
    createdAt?: DateTimeFilter<"Like"> | Date | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
    story?: XOR<StoryNullableScalarRelationFilter, StoryWhereInput> | null
  }

  export type LikeOrderByWithRelationInput = {
    id?: SortOrder
    usersId?: SortOrder
    postsId?: SortOrderInput | SortOrder
    storyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    users?: UsersOrderByWithRelationInput
    posts?: PostsOrderByWithRelationInput
    story?: StoryOrderByWithRelationInput
  }

  export type LikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LikeWhereInput | LikeWhereInput[]
    OR?: LikeWhereInput[]
    NOT?: LikeWhereInput | LikeWhereInput[]
    usersId?: StringFilter<"Like"> | string
    postsId?: StringNullableFilter<"Like"> | string | null
    storyId?: StringNullableFilter<"Like"> | string | null
    createdAt?: DateTimeFilter<"Like"> | Date | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
    story?: XOR<StoryNullableScalarRelationFilter, StoryWhereInput> | null
  }, "id">

  export type LikeOrderByWithAggregationInput = {
    id?: SortOrder
    usersId?: SortOrder
    postsId?: SortOrderInput | SortOrder
    storyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LikeCountOrderByAggregateInput
    _max?: LikeMaxOrderByAggregateInput
    _min?: LikeMinOrderByAggregateInput
  }

  export type LikeScalarWhereWithAggregatesInput = {
    AND?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    OR?: LikeScalarWhereWithAggregatesInput[]
    NOT?: LikeScalarWhereWithAggregatesInput | LikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Like"> | string
    usersId?: StringWithAggregatesFilter<"Like"> | string
    postsId?: StringNullableWithAggregatesFilter<"Like"> | string | null
    storyId?: StringNullableWithAggregatesFilter<"Like"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Like"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    usersId?: StringFilter<"Comment"> | string
    postsId?: StringNullableFilter<"Comment"> | string | null
    storyId?: StringNullableFilter<"Comment"> | string | null
    content?: StringFilter<"Comment"> | string
    mediaUrl?: StringNullableFilter<"Comment"> | string | null
    mediaType?: EnumMediaTypeFilter<"Comment"> | $Enums.MediaType
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
    story?: XOR<StoryNullableScalarRelationFilter, StoryWhereInput> | null
    viewers?: CommentViewerListRelationFilter
    attachments?: AttachmentListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    usersId?: SortOrder
    postsId?: SortOrderInput | SortOrder
    storyId?: SortOrderInput | SortOrder
    content?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UsersOrderByWithRelationInput
    posts?: PostsOrderByWithRelationInput
    story?: StoryOrderByWithRelationInput
    viewers?: CommentViewerOrderByRelationAggregateInput
    attachments?: AttachmentOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    usersId?: StringFilter<"Comment"> | string
    postsId?: StringNullableFilter<"Comment"> | string | null
    storyId?: StringNullableFilter<"Comment"> | string | null
    content?: StringFilter<"Comment"> | string
    mediaUrl?: StringNullableFilter<"Comment"> | string | null
    mediaType?: EnumMediaTypeFilter<"Comment"> | $Enums.MediaType
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
    story?: XOR<StoryNullableScalarRelationFilter, StoryWhereInput> | null
    viewers?: CommentViewerListRelationFilter
    attachments?: AttachmentListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    usersId?: SortOrder
    postsId?: SortOrderInput | SortOrder
    storyId?: SortOrderInput | SortOrder
    content?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    usersId?: StringWithAggregatesFilter<"Comment"> | string
    postsId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    storyId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    content?: StringWithAggregatesFilter<"Comment"> | string
    mediaUrl?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    mediaType?: EnumMediaTypeWithAggregatesFilter<"Comment"> | $Enums.MediaType
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type RePostsWhereInput = {
    AND?: RePostsWhereInput | RePostsWhereInput[]
    OR?: RePostsWhereInput[]
    NOT?: RePostsWhereInput | RePostsWhereInput[]
    id?: StringFilter<"RePosts"> | string
    usersId?: StringFilter<"RePosts"> | string
    originalPostsId?: StringFilter<"RePosts"> | string
    createdAt?: DateTimeFilter<"RePosts"> | Date | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    originalPosts?: XOR<PostsScalarRelationFilter, PostsWhereInput>
  }

  export type RePostsOrderByWithRelationInput = {
    id?: SortOrder
    usersId?: SortOrder
    originalPostsId?: SortOrder
    createdAt?: SortOrder
    users?: UsersOrderByWithRelationInput
    originalPosts?: PostsOrderByWithRelationInput
  }

  export type RePostsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RePostsWhereInput | RePostsWhereInput[]
    OR?: RePostsWhereInput[]
    NOT?: RePostsWhereInput | RePostsWhereInput[]
    usersId?: StringFilter<"RePosts"> | string
    originalPostsId?: StringFilter<"RePosts"> | string
    createdAt?: DateTimeFilter<"RePosts"> | Date | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    originalPosts?: XOR<PostsScalarRelationFilter, PostsWhereInput>
  }, "id">

  export type RePostsOrderByWithAggregationInput = {
    id?: SortOrder
    usersId?: SortOrder
    originalPostsId?: SortOrder
    createdAt?: SortOrder
    _count?: RePostsCountOrderByAggregateInput
    _max?: RePostsMaxOrderByAggregateInput
    _min?: RePostsMinOrderByAggregateInput
  }

  export type RePostsScalarWhereWithAggregatesInput = {
    AND?: RePostsScalarWhereWithAggregatesInput | RePostsScalarWhereWithAggregatesInput[]
    OR?: RePostsScalarWhereWithAggregatesInput[]
    NOT?: RePostsScalarWhereWithAggregatesInput | RePostsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RePosts"> | string
    usersId?: StringWithAggregatesFilter<"RePosts"> | string
    originalPostsId?: StringWithAggregatesFilter<"RePosts"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RePosts"> | Date | string
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: StringFilter<"Attachment"> | string
    postsId?: StringNullableFilter<"Attachment"> | string | null
    commentId?: StringNullableFilter<"Attachment"> | string | null
    storyId?: StringNullableFilter<"Attachment"> | string | null
    filePath?: StringFilter<"Attachment"> | string
    fileType?: EnumFileTypeFilter<"Attachment"> | $Enums.FileType
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
    comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    story?: XOR<StoryNullableScalarRelationFilter, StoryWhereInput> | null
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    postsId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    storyId?: SortOrderInput | SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
    posts?: PostsOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
    story?: StoryOrderByWithRelationInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    postsId?: StringNullableFilter<"Attachment"> | string | null
    commentId?: StringNullableFilter<"Attachment"> | string | null
    storyId?: StringNullableFilter<"Attachment"> | string | null
    filePath?: StringFilter<"Attachment"> | string
    fileType?: EnumFileTypeFilter<"Attachment"> | $Enums.FileType
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
    comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    story?: XOR<StoryNullableScalarRelationFilter, StoryWhereInput> | null
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    postsId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    storyId?: SortOrderInput | SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attachment"> | string
    postsId?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    commentId?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    storyId?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    filePath?: StringWithAggregatesFilter<"Attachment"> | string
    fileType?: EnumFileTypeWithAggregatesFilter<"Attachment"> | $Enums.FileType
    createdAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    usersId?: StringFilter<"Notification"> | string
    relatedUsersId?: StringNullableFilter<"Notification"> | string | null
    postsId?: StringNullableFilter<"Notification"> | string | null
    commentId?: StringNullableFilter<"Notification"> | string | null
    storyId?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    readStatus?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    relatedUsers?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
    comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    story?: XOR<StoryNullableScalarRelationFilter, StoryWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    usersId?: SortOrder
    relatedUsersId?: SortOrderInput | SortOrder
    postsId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    storyId?: SortOrderInput | SortOrder
    type?: SortOrder
    readStatus?: SortOrder
    createdAt?: SortOrder
    users?: UsersOrderByWithRelationInput
    relatedUsers?: UsersOrderByWithRelationInput
    posts?: PostsOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
    story?: StoryOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    usersId?: StringFilter<"Notification"> | string
    relatedUsersId?: StringNullableFilter<"Notification"> | string | null
    postsId?: StringNullableFilter<"Notification"> | string | null
    commentId?: StringNullableFilter<"Notification"> | string | null
    storyId?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    readStatus?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    relatedUsers?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    posts?: XOR<PostsNullableScalarRelationFilter, PostsWhereInput> | null
    comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    story?: XOR<StoryNullableScalarRelationFilter, StoryWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    usersId?: SortOrder
    relatedUsersId?: SortOrderInput | SortOrder
    postsId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    storyId?: SortOrderInput | SortOrder
    type?: SortOrder
    readStatus?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    usersId?: StringWithAggregatesFilter<"Notification"> | string
    relatedUsersId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    postsId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    commentId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    storyId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    readStatus?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type MessagesWhereInput = {
    AND?: MessagesWhereInput | MessagesWhereInput[]
    OR?: MessagesWhereInput[]
    NOT?: MessagesWhereInput | MessagesWhereInput[]
    id?: StringFilter<"Messages"> | string
    senderId?: StringFilter<"Messages"> | string
    receiverId?: StringFilter<"Messages"> | string
    contentText?: StringNullableFilter<"Messages"> | string | null
    mediaUrl?: StringNullableFilter<"Messages"> | string | null
    mediaType?: EnumMediaTypeFilter<"Messages"> | $Enums.MediaType
    readStatus?: BoolFilter<"Messages"> | boolean
    createdAt?: DateTimeFilter<"Messages"> | Date | string
    sender?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    receiver?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type MessagesOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    contentText?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    readStatus?: SortOrder
    createdAt?: SortOrder
    sender?: UsersOrderByWithRelationInput
    receiver?: UsersOrderByWithRelationInput
  }

  export type MessagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessagesWhereInput | MessagesWhereInput[]
    OR?: MessagesWhereInput[]
    NOT?: MessagesWhereInput | MessagesWhereInput[]
    senderId?: StringFilter<"Messages"> | string
    receiverId?: StringFilter<"Messages"> | string
    contentText?: StringNullableFilter<"Messages"> | string | null
    mediaUrl?: StringNullableFilter<"Messages"> | string | null
    mediaType?: EnumMediaTypeFilter<"Messages"> | $Enums.MediaType
    readStatus?: BoolFilter<"Messages"> | boolean
    createdAt?: DateTimeFilter<"Messages"> | Date | string
    sender?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    receiver?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type MessagesOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    contentText?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrder
    readStatus?: SortOrder
    createdAt?: SortOrder
    _count?: MessagesCountOrderByAggregateInput
    _max?: MessagesMaxOrderByAggregateInput
    _min?: MessagesMinOrderByAggregateInput
  }

  export type MessagesScalarWhereWithAggregatesInput = {
    AND?: MessagesScalarWhereWithAggregatesInput | MessagesScalarWhereWithAggregatesInput[]
    OR?: MessagesScalarWhereWithAggregatesInput[]
    NOT?: MessagesScalarWhereWithAggregatesInput | MessagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Messages"> | string
    senderId?: StringWithAggregatesFilter<"Messages"> | string
    receiverId?: StringWithAggregatesFilter<"Messages"> | string
    contentText?: StringNullableWithAggregatesFilter<"Messages"> | string | null
    mediaUrl?: StringNullableWithAggregatesFilter<"Messages"> | string | null
    mediaType?: EnumMediaTypeWithAggregatesFilter<"Messages"> | $Enums.MediaType
    readStatus?: BoolWithAggregatesFilter<"Messages"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Messages"> | Date | string
  }

  export type FriendsWhereInput = {
    AND?: FriendsWhereInput | FriendsWhereInput[]
    OR?: FriendsWhereInput[]
    NOT?: FriendsWhereInput | FriendsWhereInput[]
    id?: StringFilter<"Friends"> | string
    usersId?: StringFilter<"Friends"> | string
    friendId?: StringFilter<"Friends"> | string
    friendStatus?: EnumFriendStatusFilter<"Friends"> | $Enums.FriendStatus
    createdAt?: DateTimeFilter<"Friends"> | Date | string
    updatedAt?: DateTimeFilter<"Friends"> | Date | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    friend?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type FriendsOrderByWithRelationInput = {
    id?: SortOrder
    usersId?: SortOrder
    friendId?: SortOrder
    friendStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UsersOrderByWithRelationInput
    friend?: UsersOrderByWithRelationInput
  }

  export type FriendsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    usersId_friendId?: FriendsUsersIdFriendIdCompoundUniqueInput
    AND?: FriendsWhereInput | FriendsWhereInput[]
    OR?: FriendsWhereInput[]
    NOT?: FriendsWhereInput | FriendsWhereInput[]
    usersId?: StringFilter<"Friends"> | string
    friendId?: StringFilter<"Friends"> | string
    friendStatus?: EnumFriendStatusFilter<"Friends"> | $Enums.FriendStatus
    createdAt?: DateTimeFilter<"Friends"> | Date | string
    updatedAt?: DateTimeFilter<"Friends"> | Date | string
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    friend?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "usersId_friendId">

  export type FriendsOrderByWithAggregationInput = {
    id?: SortOrder
    usersId?: SortOrder
    friendId?: SortOrder
    friendStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FriendsCountOrderByAggregateInput
    _max?: FriendsMaxOrderByAggregateInput
    _min?: FriendsMinOrderByAggregateInput
  }

  export type FriendsScalarWhereWithAggregatesInput = {
    AND?: FriendsScalarWhereWithAggregatesInput | FriendsScalarWhereWithAggregatesInput[]
    OR?: FriendsScalarWhereWithAggregatesInput[]
    NOT?: FriendsScalarWhereWithAggregatesInput | FriendsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Friends"> | string
    usersId?: StringWithAggregatesFilter<"Friends"> | string
    friendId?: StringWithAggregatesFilter<"Friends"> | string
    friendStatus?: EnumFriendStatusWithAggregatesFilter<"Friends"> | $Enums.FriendStatus
    createdAt?: DateTimeWithAggregatesFilter<"Friends"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Friends"> | Date | string
  }

  export type FollowersWhereInput = {
    AND?: FollowersWhereInput | FollowersWhereInput[]
    OR?: FollowersWhereInput[]
    NOT?: FollowersWhereInput | FollowersWhereInput[]
    id?: StringFilter<"Followers"> | string
    followerId?: StringFilter<"Followers"> | string
    followingId?: StringFilter<"Followers"> | string
    createdAt?: DateTimeFilter<"Followers"> | Date | string
    follower?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    following?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type FollowersOrderByWithRelationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    follower?: UsersOrderByWithRelationInput
    following?: UsersOrderByWithRelationInput
  }

  export type FollowersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    followerId_followingId?: FollowersFollowerIdFollowingIdCompoundUniqueInput
    AND?: FollowersWhereInput | FollowersWhereInput[]
    OR?: FollowersWhereInput[]
    NOT?: FollowersWhereInput | FollowersWhereInput[]
    followerId?: StringFilter<"Followers"> | string
    followingId?: StringFilter<"Followers"> | string
    createdAt?: DateTimeFilter<"Followers"> | Date | string
    follower?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    following?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id" | "followerId_followingId">

  export type FollowersOrderByWithAggregationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
    _count?: FollowersCountOrderByAggregateInput
    _max?: FollowersMaxOrderByAggregateInput
    _min?: FollowersMinOrderByAggregateInput
  }

  export type FollowersScalarWhereWithAggregatesInput = {
    AND?: FollowersScalarWhereWithAggregatesInput | FollowersScalarWhereWithAggregatesInput[]
    OR?: FollowersScalarWhereWithAggregatesInput[]
    NOT?: FollowersScalarWhereWithAggregatesInput | FollowersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Followers"> | string
    followerId?: StringWithAggregatesFilter<"Followers"> | string
    followingId?: StringWithAggregatesFilter<"Followers"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Followers"> | Date | string
  }

  export type StoryViewerWhereInput = {
    AND?: StoryViewerWhereInput | StoryViewerWhereInput[]
    OR?: StoryViewerWhereInput[]
    NOT?: StoryViewerWhereInput | StoryViewerWhereInput[]
    id?: StringFilter<"StoryViewer"> | string
    storyId?: StringFilter<"StoryViewer"> | string
    usersId?: StringFilter<"StoryViewer"> | string
    readAt?: DateTimeFilter<"StoryViewer"> | Date | string
    story?: XOR<StoryScalarRelationFilter, StoryWhereInput>
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type StoryViewerOrderByWithRelationInput = {
    id?: SortOrder
    storyId?: SortOrder
    usersId?: SortOrder
    readAt?: SortOrder
    story?: StoryOrderByWithRelationInput
    users?: UsersOrderByWithRelationInput
  }

  export type StoryViewerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoryViewerWhereInput | StoryViewerWhereInput[]
    OR?: StoryViewerWhereInput[]
    NOT?: StoryViewerWhereInput | StoryViewerWhereInput[]
    storyId?: StringFilter<"StoryViewer"> | string
    usersId?: StringFilter<"StoryViewer"> | string
    readAt?: DateTimeFilter<"StoryViewer"> | Date | string
    story?: XOR<StoryScalarRelationFilter, StoryWhereInput>
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type StoryViewerOrderByWithAggregationInput = {
    id?: SortOrder
    storyId?: SortOrder
    usersId?: SortOrder
    readAt?: SortOrder
    _count?: StoryViewerCountOrderByAggregateInput
    _max?: StoryViewerMaxOrderByAggregateInput
    _min?: StoryViewerMinOrderByAggregateInput
  }

  export type StoryViewerScalarWhereWithAggregatesInput = {
    AND?: StoryViewerScalarWhereWithAggregatesInput | StoryViewerScalarWhereWithAggregatesInput[]
    OR?: StoryViewerScalarWhereWithAggregatesInput[]
    NOT?: StoryViewerScalarWhereWithAggregatesInput | StoryViewerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoryViewer"> | string
    storyId?: StringWithAggregatesFilter<"StoryViewer"> | string
    usersId?: StringWithAggregatesFilter<"StoryViewer"> | string
    readAt?: DateTimeWithAggregatesFilter<"StoryViewer"> | Date | string
  }

  export type PostsViewerWhereInput = {
    AND?: PostsViewerWhereInput | PostsViewerWhereInput[]
    OR?: PostsViewerWhereInput[]
    NOT?: PostsViewerWhereInput | PostsViewerWhereInput[]
    id?: StringFilter<"PostsViewer"> | string
    postsId?: StringFilter<"PostsViewer"> | string
    usersId?: StringFilter<"PostsViewer"> | string
    viewedAt?: DateTimeFilter<"PostsViewer"> | Date | string
    posts?: XOR<PostsScalarRelationFilter, PostsWhereInput>
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type PostsViewerOrderByWithRelationInput = {
    id?: SortOrder
    postsId?: SortOrder
    usersId?: SortOrder
    viewedAt?: SortOrder
    posts?: PostsOrderByWithRelationInput
    users?: UsersOrderByWithRelationInput
  }

  export type PostsViewerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostsViewerWhereInput | PostsViewerWhereInput[]
    OR?: PostsViewerWhereInput[]
    NOT?: PostsViewerWhereInput | PostsViewerWhereInput[]
    postsId?: StringFilter<"PostsViewer"> | string
    usersId?: StringFilter<"PostsViewer"> | string
    viewedAt?: DateTimeFilter<"PostsViewer"> | Date | string
    posts?: XOR<PostsScalarRelationFilter, PostsWhereInput>
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type PostsViewerOrderByWithAggregationInput = {
    id?: SortOrder
    postsId?: SortOrder
    usersId?: SortOrder
    viewedAt?: SortOrder
    _count?: PostsViewerCountOrderByAggregateInput
    _max?: PostsViewerMaxOrderByAggregateInput
    _min?: PostsViewerMinOrderByAggregateInput
  }

  export type PostsViewerScalarWhereWithAggregatesInput = {
    AND?: PostsViewerScalarWhereWithAggregatesInput | PostsViewerScalarWhereWithAggregatesInput[]
    OR?: PostsViewerScalarWhereWithAggregatesInput[]
    NOT?: PostsViewerScalarWhereWithAggregatesInput | PostsViewerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostsViewer"> | string
    postsId?: StringWithAggregatesFilter<"PostsViewer"> | string
    usersId?: StringWithAggregatesFilter<"PostsViewer"> | string
    viewedAt?: DateTimeWithAggregatesFilter<"PostsViewer"> | Date | string
  }

  export type CommentViewerWhereInput = {
    AND?: CommentViewerWhereInput | CommentViewerWhereInput[]
    OR?: CommentViewerWhereInput[]
    NOT?: CommentViewerWhereInput | CommentViewerWhereInput[]
    id?: StringFilter<"CommentViewer"> | string
    commentId?: StringFilter<"CommentViewer"> | string
    usersId?: StringFilter<"CommentViewer"> | string
    readAt?: DateTimeFilter<"CommentViewer"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }

  export type CommentViewerOrderByWithRelationInput = {
    id?: SortOrder
    commentId?: SortOrder
    usersId?: SortOrder
    readAt?: SortOrder
    comment?: CommentOrderByWithRelationInput
    users?: UsersOrderByWithRelationInput
  }

  export type CommentViewerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentViewerWhereInput | CommentViewerWhereInput[]
    OR?: CommentViewerWhereInput[]
    NOT?: CommentViewerWhereInput | CommentViewerWhereInput[]
    commentId?: StringFilter<"CommentViewer"> | string
    usersId?: StringFilter<"CommentViewer"> | string
    readAt?: DateTimeFilter<"CommentViewer"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
  }, "id">

  export type CommentViewerOrderByWithAggregationInput = {
    id?: SortOrder
    commentId?: SortOrder
    usersId?: SortOrder
    readAt?: SortOrder
    _count?: CommentViewerCountOrderByAggregateInput
    _max?: CommentViewerMaxOrderByAggregateInput
    _min?: CommentViewerMinOrderByAggregateInput
  }

  export type CommentViewerScalarWhereWithAggregatesInput = {
    AND?: CommentViewerScalarWhereWithAggregatesInput | CommentViewerScalarWhereWithAggregatesInput[]
    OR?: CommentViewerScalarWhereWithAggregatesInput[]
    NOT?: CommentViewerScalarWhereWithAggregatesInput | CommentViewerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommentViewer"> | string
    commentId?: StringWithAggregatesFilter<"CommentViewer"> | string
    usersId?: StringWithAggregatesFilter<"CommentViewer"> | string
    readAt?: DateTimeWithAggregatesFilter<"CommentViewer"> | Date | string
  }

  export type UsersCreateInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedManyWithoutUsersInput
    stories?: StoryCreateNestedManyWithoutUsersInput
    likes?: LikeCreateNestedManyWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUsersInput
    reposts?: RePostsCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUsersInput
    friendOf?: FriendsCreateNestedManyWithoutFriendInput
    followers?: FollowersCreateNestedManyWithoutFollowerInput
    following?: FollowersCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUsersInput
    stories?: StoryUncheckedCreateNestedManyWithoutUsersInput
    likes?: LikeUncheckedCreateNestedManyWithoutUsersInput
    comments?: CommentUncheckedCreateNestedManyWithoutUsersInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUsersInput
    friendOf?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    followers?: FollowersUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowersUncheckedCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerUncheckedCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerUncheckedCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUsersNestedInput
    stories?: StoryUpdateManyWithoutUsersNestedInput
    likes?: LikeUpdateManyWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUpdateManyWithoutFriendNestedInput
    followers?: FollowersUpdateManyWithoutFollowerNestedInput
    following?: FollowersUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUsersNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUsersNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUsersNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    followers?: FollowersUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowersUncheckedUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUncheckedUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUncheckedUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateManyInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsCreateInput = {
    id?: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostsInput
    likes?: LikeCreateNestedManyWithoutPostsInput
    reposts?: RePostsCreateNestedManyWithoutOriginalPostsInput
    attachments?: AttachmentCreateNestedManyWithoutPostsInput
    viewers?: PostsViewerCreateNestedManyWithoutPostsInput
    notifications?: NotificationCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateInput = {
    id?: string
    usersId: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostsInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostsInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutOriginalPostsInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutPostsInput
    viewers?: PostsViewerUncheckedCreateNestedManyWithoutPostsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostsNestedInput
    likes?: LikeUpdateManyWithoutPostsNestedInput
    reposts?: RePostsUpdateManyWithoutOriginalPostsNestedInput
    attachments?: AttachmentUpdateManyWithoutPostsNestedInput
    viewers?: PostsViewerUpdateManyWithoutPostsNestedInput
    notifications?: NotificationUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostsNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostsNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutOriginalPostsNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutPostsNestedInput
    viewers?: PostsViewerUncheckedUpdateManyWithoutPostsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostsCreateManyInput = {
    id?: string
    usersId: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryCreateInput = {
    id?: string
    contentText?: string | null
    contentMedia?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    expirationTime: Date | string
    users: UsersCreateNestedOneWithoutStoriesInput
    viewers?: StoryViewerCreateNestedManyWithoutStoryInput
    likes?: LikeCreateNestedManyWithoutStoryInput
    comments?: CommentCreateNestedManyWithoutStoryInput
    attachments?: AttachmentCreateNestedManyWithoutStoryInput
    notifications?: NotificationCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateInput = {
    id?: string
    usersId: string
    contentText?: string | null
    contentMedia?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    expirationTime: Date | string
    viewers?: StoryViewerUncheckedCreateNestedManyWithoutStoryInput
    likes?: LikeUncheckedCreateNestedManyWithoutStoryInput
    comments?: CommentUncheckedCreateNestedManyWithoutStoryInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutStoryInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutStoriesNestedInput
    viewers?: StoryViewerUpdateManyWithoutStoryNestedInput
    likes?: LikeUpdateManyWithoutStoryNestedInput
    comments?: CommentUpdateManyWithoutStoryNestedInput
    attachments?: AttachmentUpdateManyWithoutStoryNestedInput
    notifications?: NotificationUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: StoryViewerUncheckedUpdateManyWithoutStoryNestedInput
    likes?: LikeUncheckedUpdateManyWithoutStoryNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStoryNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutStoryNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryCreateManyInput = {
    id?: string
    usersId: string
    contentText?: string | null
    contentMedia?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    expirationTime: Date | string
  }

  export type StoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateInput = {
    id?: string
    createdAt?: Date | string
    users: UsersCreateNestedOneWithoutLikesInput
    posts?: PostsCreateNestedOneWithoutLikesInput
    story?: StoryCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateInput = {
    id?: string
    usersId: string
    postsId?: string | null
    storyId?: string | null
    createdAt?: Date | string
  }

  export type LikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutLikesNestedInput
    posts?: PostsUpdateOneWithoutLikesNestedInput
    story?: StoryUpdateOneWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeCreateManyInput = {
    id?: string
    usersId: string
    postsId?: string | null
    storyId?: string | null
    createdAt?: Date | string
  }

  export type LikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutCommentsInput
    posts?: PostsCreateNestedOneWithoutCommentsInput
    story?: StoryCreateNestedOneWithoutCommentsInput
    viewers?: CommentViewerCreateNestedManyWithoutCommentInput
    attachments?: AttachmentCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    usersId: string
    postsId?: string | null
    storyId?: string | null
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    viewers?: CommentViewerUncheckedCreateNestedManyWithoutCommentInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutCommentsNestedInput
    posts?: PostsUpdateOneWithoutCommentsNestedInput
    story?: StoryUpdateOneWithoutCommentsNestedInput
    viewers?: CommentViewerUpdateManyWithoutCommentNestedInput
    attachments?: AttachmentUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: CommentViewerUncheckedUpdateManyWithoutCommentNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    usersId: string
    postsId?: string | null
    storyId?: string | null
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RePostsCreateInput = {
    id?: string
    createdAt?: Date | string
    users: UsersCreateNestedOneWithoutRepostsInput
    originalPosts: PostsCreateNestedOneWithoutRepostsInput
  }

  export type RePostsUncheckedCreateInput = {
    id?: string
    usersId: string
    originalPostsId: string
    createdAt?: Date | string
  }

  export type RePostsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutRepostsNestedInput
    originalPosts?: PostsUpdateOneRequiredWithoutRepostsNestedInput
  }

  export type RePostsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    originalPostsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RePostsCreateManyInput = {
    id?: string
    usersId: string
    originalPostsId: string
    createdAt?: Date | string
  }

  export type RePostsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RePostsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    originalPostsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateInput = {
    id?: string
    filePath: string
    fileType: $Enums.FileType
    createdAt?: Date | string
    posts?: PostsCreateNestedOneWithoutAttachmentsInput
    comment?: CommentCreateNestedOneWithoutAttachmentsInput
    story?: StoryCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateInput = {
    id?: string
    postsId?: string | null
    commentId?: string | null
    storyId?: string | null
    filePath: string
    fileType: $Enums.FileType
    createdAt?: Date | string
  }

  export type AttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateOneWithoutAttachmentsNestedInput
    comment?: CommentUpdateOneWithoutAttachmentsNestedInput
    story?: StoryUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateManyInput = {
    id?: string
    postsId?: string | null
    commentId?: string | null
    storyId?: string | null
    filePath: string
    fileType: $Enums.FileType
    createdAt?: Date | string
  }

  export type AttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
    users: UsersCreateNestedOneWithoutNotificationsInput
    relatedUsers?: UsersCreateNestedOneWithoutRelatedNotificationsInput
    posts?: PostsCreateNestedOneWithoutNotificationsInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    story?: StoryCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    usersId: string
    relatedUsersId?: string | null
    postsId?: string | null
    commentId?: string | null
    storyId?: string | null
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutNotificationsNestedInput
    relatedUsers?: UsersUpdateOneWithoutRelatedNotificationsNestedInput
    posts?: PostsUpdateOneWithoutNotificationsNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    story?: StoryUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    relatedUsersId?: NullableStringFieldUpdateOperationsInput | string | null
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    usersId: string
    relatedUsersId?: string | null
    postsId?: string | null
    commentId?: string | null
    storyId?: string | null
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    relatedUsersId?: NullableStringFieldUpdateOperationsInput | string | null
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessagesCreateInput = {
    id?: string
    contentText?: string | null
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    readStatus?: boolean
    createdAt?: Date | string
    sender: UsersCreateNestedOneWithoutMessagesSentInput
    receiver: UsersCreateNestedOneWithoutMessagesReceivedInput
  }

  export type MessagesUncheckedCreateInput = {
    id?: string
    senderId: string
    receiverId: string
    contentText?: string | null
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type MessagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UsersUpdateOneRequiredWithoutMessagesSentNestedInput
    receiver?: UsersUpdateOneRequiredWithoutMessagesReceivedNestedInput
  }

  export type MessagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessagesCreateManyInput = {
    id?: string
    senderId: string
    receiverId: string
    contentText?: string | null
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type MessagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendsCreateInput = {
    id?: string
    friendStatus: $Enums.FriendStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutFriendsInput
    friend: UsersCreateNestedOneWithoutFriendOfInput
  }

  export type FriendsUncheckedCreateInput = {
    id?: string
    usersId: string
    friendId: string
    friendStatus: $Enums.FriendStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FriendsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendStatus?: EnumFriendStatusFieldUpdateOperationsInput | $Enums.FriendStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutFriendsNestedInput
    friend?: UsersUpdateOneRequiredWithoutFriendOfNestedInput
  }

  export type FriendsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
    friendStatus?: EnumFriendStatusFieldUpdateOperationsInput | $Enums.FriendStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendsCreateManyInput = {
    id?: string
    usersId: string
    friendId: string
    friendStatus: $Enums.FriendStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FriendsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendStatus?: EnumFriendStatusFieldUpdateOperationsInput | $Enums.FriendStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
    friendStatus?: EnumFriendStatusFieldUpdateOperationsInput | $Enums.FriendStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowersCreateInput = {
    id?: string
    createdAt?: Date | string
    follower: UsersCreateNestedOneWithoutFollowersInput
    following: UsersCreateNestedOneWithoutFollowingInput
  }

  export type FollowersUncheckedCreateInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UsersUpdateOneRequiredWithoutFollowersNestedInput
    following?: UsersUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowersCreateManyInput = {
    id?: string
    followerId: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryViewerCreateInput = {
    id?: string
    readAt?: Date | string
    story: StoryCreateNestedOneWithoutViewersInput
    users: UsersCreateNestedOneWithoutStoryViewersInput
  }

  export type StoryViewerUncheckedCreateInput = {
    id?: string
    storyId: string
    usersId: string
    readAt?: Date | string
  }

  export type StoryViewerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: StoryUpdateOneRequiredWithoutViewersNestedInput
    users?: UsersUpdateOneRequiredWithoutStoryViewersNestedInput
  }

  export type StoryViewerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryViewerCreateManyInput = {
    id?: string
    storyId: string
    usersId: string
    readAt?: Date | string
  }

  export type StoryViewerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryViewerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsViewerCreateInput = {
    id?: string
    viewedAt?: Date | string
    posts: PostsCreateNestedOneWithoutViewersInput
    users: UsersCreateNestedOneWithoutPostViewersInput
  }

  export type PostsViewerUncheckedCreateInput = {
    id?: string
    postsId: string
    usersId: string
    viewedAt?: Date | string
  }

  export type PostsViewerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateOneRequiredWithoutViewersNestedInput
    users?: UsersUpdateOneRequiredWithoutPostViewersNestedInput
  }

  export type PostsViewerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postsId?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsViewerCreateManyInput = {
    id?: string
    postsId: string
    usersId: string
    viewedAt?: Date | string
  }

  export type PostsViewerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsViewerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postsId?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentViewerCreateInput = {
    id?: string
    readAt?: Date | string
    comment: CommentCreateNestedOneWithoutViewersInput
    users: UsersCreateNestedOneWithoutCommentViewersInput
  }

  export type CommentViewerUncheckedCreateInput = {
    id?: string
    commentId: string
    usersId: string
    readAt?: Date | string
  }

  export type CommentViewerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutViewersNestedInput
    users?: UsersUpdateOneRequiredWithoutCommentViewersNestedInput
  }

  export type CommentViewerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentViewerCreateManyInput = {
    id?: string
    commentId: string
    usersId: string
    readAt?: Date | string
  }

  export type CommentViewerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentViewerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PostsListRelationFilter = {
    every?: PostsWhereInput
    some?: PostsWhereInput
    none?: PostsWhereInput
  }

  export type StoryListRelationFilter = {
    every?: StoryWhereInput
    some?: StoryWhereInput
    none?: StoryWhereInput
  }

  export type LikeListRelationFilter = {
    every?: LikeWhereInput
    some?: LikeWhereInput
    none?: LikeWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type RePostsListRelationFilter = {
    every?: RePostsWhereInput
    some?: RePostsWhereInput
    none?: RePostsWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type MessagesListRelationFilter = {
    every?: MessagesWhereInput
    some?: MessagesWhereInput
    none?: MessagesWhereInput
  }

  export type FriendsListRelationFilter = {
    every?: FriendsWhereInput
    some?: FriendsWhereInput
    none?: FriendsWhereInput
  }

  export type FollowersListRelationFilter = {
    every?: FollowersWhereInput
    some?: FollowersWhereInput
    none?: FollowersWhereInput
  }

  export type StoryViewerListRelationFilter = {
    every?: StoryViewerWhereInput
    some?: StoryViewerWhereInput
    none?: StoryViewerWhereInput
  }

  export type PostsViewerListRelationFilter = {
    every?: PostsViewerWhereInput
    some?: PostsViewerWhereInput
    none?: PostsViewerWhereInput
  }

  export type CommentViewerListRelationFilter = {
    every?: CommentViewerWhereInput
    some?: CommentViewerWhereInput
    none?: CommentViewerWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PostsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RePostsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoryViewerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostsViewerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentViewerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profile_image?: SortOrder
    banner?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profile_image?: SortOrder
    banner?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    profile_image?: SortOrder
    banner?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostsCountOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    contentText?: SortOrder
    contentImage?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostsMaxOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    contentText?: SortOrder
    contentImage?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostsMinOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    contentText?: SortOrder
    contentImage?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type StoryCountOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    contentText?: SortOrder
    contentMedia?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    expirationTime?: SortOrder
  }

  export type StoryMaxOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    contentText?: SortOrder
    contentMedia?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    expirationTime?: SortOrder
  }

  export type StoryMinOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    contentText?: SortOrder
    contentMedia?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    expirationTime?: SortOrder
  }

  export type PostsNullableScalarRelationFilter = {
    is?: PostsWhereInput | null
    isNot?: PostsWhereInput | null
  }

  export type StoryNullableScalarRelationFilter = {
    is?: StoryWhereInput | null
    isNot?: StoryWhereInput | null
  }

  export type LikeCountOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    postsId?: SortOrder
    storyId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMaxOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    postsId?: SortOrder
    storyId?: SortOrder
    createdAt?: SortOrder
  }

  export type LikeMinOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    postsId?: SortOrder
    storyId?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    postsId?: SortOrder
    storyId?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    postsId?: SortOrder
    storyId?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    postsId?: SortOrder
    storyId?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostsScalarRelationFilter = {
    is?: PostsWhereInput
    isNot?: PostsWhereInput
  }

  export type RePostsCountOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    originalPostsId?: SortOrder
    createdAt?: SortOrder
  }

  export type RePostsMaxOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    originalPostsId?: SortOrder
    createdAt?: SortOrder
  }

  export type RePostsMinOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    originalPostsId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    commentId?: SortOrder
    storyId?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    commentId?: SortOrder
    storyId?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    commentId?: SortOrder
    storyId?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UsersNullableScalarRelationFilter = {
    is?: UsersWhereInput | null
    isNot?: UsersWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    relatedUsersId?: SortOrder
    postsId?: SortOrder
    commentId?: SortOrder
    storyId?: SortOrder
    type?: SortOrder
    readStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    relatedUsersId?: SortOrder
    postsId?: SortOrder
    commentId?: SortOrder
    storyId?: SortOrder
    type?: SortOrder
    readStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    relatedUsersId?: SortOrder
    postsId?: SortOrder
    commentId?: SortOrder
    storyId?: SortOrder
    type?: SortOrder
    readStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MessagesCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    contentText?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    readStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type MessagesMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    contentText?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    readStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type MessagesMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    contentText?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    readStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFriendStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendStatus | EnumFriendStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendStatus[] | ListEnumFriendStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendStatus[] | ListEnumFriendStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendStatusFilter<$PrismaModel> | $Enums.FriendStatus
  }

  export type FriendsUsersIdFriendIdCompoundUniqueInput = {
    usersId: string
    friendId: string
  }

  export type FriendsCountOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    friendId?: SortOrder
    friendStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FriendsMaxOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    friendId?: SortOrder
    friendStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FriendsMinOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
    friendId?: SortOrder
    friendStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFriendStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendStatus | EnumFriendStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendStatus[] | ListEnumFriendStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendStatus[] | ListEnumFriendStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendStatusFilter<$PrismaModel>
  }

  export type FollowersFollowerIdFollowingIdCompoundUniqueInput = {
    followerId: string
    followingId: string
  }

  export type FollowersCountOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowersMaxOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowersMinOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followingId?: SortOrder
    createdAt?: SortOrder
  }

  export type StoryScalarRelationFilter = {
    is?: StoryWhereInput
    isNot?: StoryWhereInput
  }

  export type StoryViewerCountOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    usersId?: SortOrder
    readAt?: SortOrder
  }

  export type StoryViewerMaxOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    usersId?: SortOrder
    readAt?: SortOrder
  }

  export type StoryViewerMinOrderByAggregateInput = {
    id?: SortOrder
    storyId?: SortOrder
    usersId?: SortOrder
    readAt?: SortOrder
  }

  export type PostsViewerCountOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    usersId?: SortOrder
    viewedAt?: SortOrder
  }

  export type PostsViewerMaxOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    usersId?: SortOrder
    viewedAt?: SortOrder
  }

  export type PostsViewerMinOrderByAggregateInput = {
    id?: SortOrder
    postsId?: SortOrder
    usersId?: SortOrder
    viewedAt?: SortOrder
  }

  export type CommentScalarRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type CommentViewerCountOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    usersId?: SortOrder
    readAt?: SortOrder
  }

  export type CommentViewerMaxOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    usersId?: SortOrder
    readAt?: SortOrder
  }

  export type CommentViewerMinOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    usersId?: SortOrder
    readAt?: SortOrder
  }

  export type PostsCreateNestedManyWithoutUsersInput = {
    create?: XOR<PostsCreateWithoutUsersInput, PostsUncheckedCreateWithoutUsersInput> | PostsCreateWithoutUsersInput[] | PostsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PostsCreateOrConnectWithoutUsersInput | PostsCreateOrConnectWithoutUsersInput[]
    createMany?: PostsCreateManyUsersInputEnvelope
    connect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
  }

  export type StoryCreateNestedManyWithoutUsersInput = {
    create?: XOR<StoryCreateWithoutUsersInput, StoryUncheckedCreateWithoutUsersInput> | StoryCreateWithoutUsersInput[] | StoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutUsersInput | StoryCreateOrConnectWithoutUsersInput[]
    createMany?: StoryCreateManyUsersInputEnvelope
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutUsersInput = {
    create?: XOR<LikeCreateWithoutUsersInput, LikeUncheckedCreateWithoutUsersInput> | LikeCreateWithoutUsersInput[] | LikeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUsersInput | LikeCreateOrConnectWithoutUsersInput[]
    createMany?: LikeCreateManyUsersInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUsersInput = {
    create?: XOR<CommentCreateWithoutUsersInput, CommentUncheckedCreateWithoutUsersInput> | CommentCreateWithoutUsersInput[] | CommentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUsersInput | CommentCreateOrConnectWithoutUsersInput[]
    createMany?: CommentCreateManyUsersInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type RePostsCreateNestedManyWithoutUsersInput = {
    create?: XOR<RePostsCreateWithoutUsersInput, RePostsUncheckedCreateWithoutUsersInput> | RePostsCreateWithoutUsersInput[] | RePostsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RePostsCreateOrConnectWithoutUsersInput | RePostsCreateOrConnectWithoutUsersInput[]
    createMany?: RePostsCreateManyUsersInputEnvelope
    connect?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUsersInput = {
    create?: XOR<NotificationCreateWithoutUsersInput, NotificationUncheckedCreateWithoutUsersInput> | NotificationCreateWithoutUsersInput[] | NotificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUsersInput | NotificationCreateOrConnectWithoutUsersInput[]
    createMany?: NotificationCreateManyUsersInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutRelatedUsersInput = {
    create?: XOR<NotificationCreateWithoutRelatedUsersInput, NotificationUncheckedCreateWithoutRelatedUsersInput> | NotificationCreateWithoutRelatedUsersInput[] | NotificationUncheckedCreateWithoutRelatedUsersInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRelatedUsersInput | NotificationCreateOrConnectWithoutRelatedUsersInput[]
    createMany?: NotificationCreateManyRelatedUsersInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type MessagesCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessagesCreateWithoutSenderInput, MessagesUncheckedCreateWithoutSenderInput> | MessagesCreateWithoutSenderInput[] | MessagesUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutSenderInput | MessagesCreateOrConnectWithoutSenderInput[]
    createMany?: MessagesCreateManySenderInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type MessagesCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessagesCreateWithoutReceiverInput, MessagesUncheckedCreateWithoutReceiverInput> | MessagesCreateWithoutReceiverInput[] | MessagesUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutReceiverInput | MessagesCreateOrConnectWithoutReceiverInput[]
    createMany?: MessagesCreateManyReceiverInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type FriendsCreateNestedManyWithoutUsersInput = {
    create?: XOR<FriendsCreateWithoutUsersInput, FriendsUncheckedCreateWithoutUsersInput> | FriendsCreateWithoutUsersInput[] | FriendsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutUsersInput | FriendsCreateOrConnectWithoutUsersInput[]
    createMany?: FriendsCreateManyUsersInputEnvelope
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
  }

  export type FriendsCreateNestedManyWithoutFriendInput = {
    create?: XOR<FriendsCreateWithoutFriendInput, FriendsUncheckedCreateWithoutFriendInput> | FriendsCreateWithoutFriendInput[] | FriendsUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutFriendInput | FriendsCreateOrConnectWithoutFriendInput[]
    createMany?: FriendsCreateManyFriendInputEnvelope
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
  }

  export type FollowersCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowersCreateWithoutFollowerInput, FollowersUncheckedCreateWithoutFollowerInput> | FollowersCreateWithoutFollowerInput[] | FollowersUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowersCreateOrConnectWithoutFollowerInput | FollowersCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowersCreateManyFollowerInputEnvelope
    connect?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
  }

  export type FollowersCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowersCreateWithoutFollowingInput, FollowersUncheckedCreateWithoutFollowingInput> | FollowersCreateWithoutFollowingInput[] | FollowersUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowersCreateOrConnectWithoutFollowingInput | FollowersCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowersCreateManyFollowingInputEnvelope
    connect?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
  }

  export type StoryViewerCreateNestedManyWithoutUsersInput = {
    create?: XOR<StoryViewerCreateWithoutUsersInput, StoryViewerUncheckedCreateWithoutUsersInput> | StoryViewerCreateWithoutUsersInput[] | StoryViewerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: StoryViewerCreateOrConnectWithoutUsersInput | StoryViewerCreateOrConnectWithoutUsersInput[]
    createMany?: StoryViewerCreateManyUsersInputEnvelope
    connect?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
  }

  export type PostsViewerCreateNestedManyWithoutUsersInput = {
    create?: XOR<PostsViewerCreateWithoutUsersInput, PostsViewerUncheckedCreateWithoutUsersInput> | PostsViewerCreateWithoutUsersInput[] | PostsViewerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PostsViewerCreateOrConnectWithoutUsersInput | PostsViewerCreateOrConnectWithoutUsersInput[]
    createMany?: PostsViewerCreateManyUsersInputEnvelope
    connect?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
  }

  export type CommentViewerCreateNestedManyWithoutUsersInput = {
    create?: XOR<CommentViewerCreateWithoutUsersInput, CommentViewerUncheckedCreateWithoutUsersInput> | CommentViewerCreateWithoutUsersInput[] | CommentViewerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CommentViewerCreateOrConnectWithoutUsersInput | CommentViewerCreateOrConnectWithoutUsersInput[]
    createMany?: CommentViewerCreateManyUsersInputEnvelope
    connect?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
  }

  export type PostsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<PostsCreateWithoutUsersInput, PostsUncheckedCreateWithoutUsersInput> | PostsCreateWithoutUsersInput[] | PostsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PostsCreateOrConnectWithoutUsersInput | PostsCreateOrConnectWithoutUsersInput[]
    createMany?: PostsCreateManyUsersInputEnvelope
    connect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
  }

  export type StoryUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<StoryCreateWithoutUsersInput, StoryUncheckedCreateWithoutUsersInput> | StoryCreateWithoutUsersInput[] | StoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutUsersInput | StoryCreateOrConnectWithoutUsersInput[]
    createMany?: StoryCreateManyUsersInputEnvelope
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<LikeCreateWithoutUsersInput, LikeUncheckedCreateWithoutUsersInput> | LikeCreateWithoutUsersInput[] | LikeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUsersInput | LikeCreateOrConnectWithoutUsersInput[]
    createMany?: LikeCreateManyUsersInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<CommentCreateWithoutUsersInput, CommentUncheckedCreateWithoutUsersInput> | CommentCreateWithoutUsersInput[] | CommentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUsersInput | CommentCreateOrConnectWithoutUsersInput[]
    createMany?: CommentCreateManyUsersInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type RePostsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<RePostsCreateWithoutUsersInput, RePostsUncheckedCreateWithoutUsersInput> | RePostsCreateWithoutUsersInput[] | RePostsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RePostsCreateOrConnectWithoutUsersInput | RePostsCreateOrConnectWithoutUsersInput[]
    createMany?: RePostsCreateManyUsersInputEnvelope
    connect?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<NotificationCreateWithoutUsersInput, NotificationUncheckedCreateWithoutUsersInput> | NotificationCreateWithoutUsersInput[] | NotificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUsersInput | NotificationCreateOrConnectWithoutUsersInput[]
    createMany?: NotificationCreateManyUsersInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput = {
    create?: XOR<NotificationCreateWithoutRelatedUsersInput, NotificationUncheckedCreateWithoutRelatedUsersInput> | NotificationCreateWithoutRelatedUsersInput[] | NotificationUncheckedCreateWithoutRelatedUsersInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRelatedUsersInput | NotificationCreateOrConnectWithoutRelatedUsersInput[]
    createMany?: NotificationCreateManyRelatedUsersInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type MessagesUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessagesCreateWithoutSenderInput, MessagesUncheckedCreateWithoutSenderInput> | MessagesCreateWithoutSenderInput[] | MessagesUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutSenderInput | MessagesCreateOrConnectWithoutSenderInput[]
    createMany?: MessagesCreateManySenderInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type MessagesUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessagesCreateWithoutReceiverInput, MessagesUncheckedCreateWithoutReceiverInput> | MessagesCreateWithoutReceiverInput[] | MessagesUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutReceiverInput | MessagesCreateOrConnectWithoutReceiverInput[]
    createMany?: MessagesCreateManyReceiverInputEnvelope
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
  }

  export type FriendsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<FriendsCreateWithoutUsersInput, FriendsUncheckedCreateWithoutUsersInput> | FriendsCreateWithoutUsersInput[] | FriendsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutUsersInput | FriendsCreateOrConnectWithoutUsersInput[]
    createMany?: FriendsCreateManyUsersInputEnvelope
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
  }

  export type FriendsUncheckedCreateNestedManyWithoutFriendInput = {
    create?: XOR<FriendsCreateWithoutFriendInput, FriendsUncheckedCreateWithoutFriendInput> | FriendsCreateWithoutFriendInput[] | FriendsUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutFriendInput | FriendsCreateOrConnectWithoutFriendInput[]
    createMany?: FriendsCreateManyFriendInputEnvelope
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
  }

  export type FollowersUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowersCreateWithoutFollowerInput, FollowersUncheckedCreateWithoutFollowerInput> | FollowersCreateWithoutFollowerInput[] | FollowersUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowersCreateOrConnectWithoutFollowerInput | FollowersCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowersCreateManyFollowerInputEnvelope
    connect?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
  }

  export type FollowersUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<FollowersCreateWithoutFollowingInput, FollowersUncheckedCreateWithoutFollowingInput> | FollowersCreateWithoutFollowingInput[] | FollowersUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowersCreateOrConnectWithoutFollowingInput | FollowersCreateOrConnectWithoutFollowingInput[]
    createMany?: FollowersCreateManyFollowingInputEnvelope
    connect?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
  }

  export type StoryViewerUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<StoryViewerCreateWithoutUsersInput, StoryViewerUncheckedCreateWithoutUsersInput> | StoryViewerCreateWithoutUsersInput[] | StoryViewerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: StoryViewerCreateOrConnectWithoutUsersInput | StoryViewerCreateOrConnectWithoutUsersInput[]
    createMany?: StoryViewerCreateManyUsersInputEnvelope
    connect?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
  }

  export type PostsViewerUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<PostsViewerCreateWithoutUsersInput, PostsViewerUncheckedCreateWithoutUsersInput> | PostsViewerCreateWithoutUsersInput[] | PostsViewerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PostsViewerCreateOrConnectWithoutUsersInput | PostsViewerCreateOrConnectWithoutUsersInput[]
    createMany?: PostsViewerCreateManyUsersInputEnvelope
    connect?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
  }

  export type CommentViewerUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<CommentViewerCreateWithoutUsersInput, CommentViewerUncheckedCreateWithoutUsersInput> | CommentViewerCreateWithoutUsersInput[] | CommentViewerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CommentViewerCreateOrConnectWithoutUsersInput | CommentViewerCreateOrConnectWithoutUsersInput[]
    createMany?: CommentViewerCreateManyUsersInputEnvelope
    connect?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PostsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PostsCreateWithoutUsersInput, PostsUncheckedCreateWithoutUsersInput> | PostsCreateWithoutUsersInput[] | PostsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PostsCreateOrConnectWithoutUsersInput | PostsCreateOrConnectWithoutUsersInput[]
    upsert?: PostsUpsertWithWhereUniqueWithoutUsersInput | PostsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PostsCreateManyUsersInputEnvelope
    set?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    disconnect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    delete?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    connect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    update?: PostsUpdateWithWhereUniqueWithoutUsersInput | PostsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PostsUpdateManyWithWhereWithoutUsersInput | PostsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PostsScalarWhereInput | PostsScalarWhereInput[]
  }

  export type StoryUpdateManyWithoutUsersNestedInput = {
    create?: XOR<StoryCreateWithoutUsersInput, StoryUncheckedCreateWithoutUsersInput> | StoryCreateWithoutUsersInput[] | StoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutUsersInput | StoryCreateOrConnectWithoutUsersInput[]
    upsert?: StoryUpsertWithWhereUniqueWithoutUsersInput | StoryUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: StoryCreateManyUsersInputEnvelope
    set?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    disconnect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    delete?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    update?: StoryUpdateWithWhereUniqueWithoutUsersInput | StoryUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: StoryUpdateManyWithWhereWithoutUsersInput | StoryUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: StoryScalarWhereInput | StoryScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutUsersNestedInput = {
    create?: XOR<LikeCreateWithoutUsersInput, LikeUncheckedCreateWithoutUsersInput> | LikeCreateWithoutUsersInput[] | LikeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUsersInput | LikeCreateOrConnectWithoutUsersInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutUsersInput | LikeUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: LikeCreateManyUsersInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutUsersInput | LikeUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutUsersInput | LikeUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CommentCreateWithoutUsersInput, CommentUncheckedCreateWithoutUsersInput> | CommentCreateWithoutUsersInput[] | CommentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUsersInput | CommentCreateOrConnectWithoutUsersInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUsersInput | CommentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: CommentCreateManyUsersInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUsersInput | CommentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUsersInput | CommentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type RePostsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<RePostsCreateWithoutUsersInput, RePostsUncheckedCreateWithoutUsersInput> | RePostsCreateWithoutUsersInput[] | RePostsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RePostsCreateOrConnectWithoutUsersInput | RePostsCreateOrConnectWithoutUsersInput[]
    upsert?: RePostsUpsertWithWhereUniqueWithoutUsersInput | RePostsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: RePostsCreateManyUsersInputEnvelope
    set?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
    disconnect?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
    delete?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
    connect?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
    update?: RePostsUpdateWithWhereUniqueWithoutUsersInput | RePostsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: RePostsUpdateManyWithWhereWithoutUsersInput | RePostsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: RePostsScalarWhereInput | RePostsScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUsersNestedInput = {
    create?: XOR<NotificationCreateWithoutUsersInput, NotificationUncheckedCreateWithoutUsersInput> | NotificationCreateWithoutUsersInput[] | NotificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUsersInput | NotificationCreateOrConnectWithoutUsersInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUsersInput | NotificationUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: NotificationCreateManyUsersInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUsersInput | NotificationUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUsersInput | NotificationUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutRelatedUsersNestedInput = {
    create?: XOR<NotificationCreateWithoutRelatedUsersInput, NotificationUncheckedCreateWithoutRelatedUsersInput> | NotificationCreateWithoutRelatedUsersInput[] | NotificationUncheckedCreateWithoutRelatedUsersInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRelatedUsersInput | NotificationCreateOrConnectWithoutRelatedUsersInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRelatedUsersInput | NotificationUpsertWithWhereUniqueWithoutRelatedUsersInput[]
    createMany?: NotificationCreateManyRelatedUsersInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRelatedUsersInput | NotificationUpdateWithWhereUniqueWithoutRelatedUsersInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRelatedUsersInput | NotificationUpdateManyWithWhereWithoutRelatedUsersInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type MessagesUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessagesCreateWithoutSenderInput, MessagesUncheckedCreateWithoutSenderInput> | MessagesCreateWithoutSenderInput[] | MessagesUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutSenderInput | MessagesCreateOrConnectWithoutSenderInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutSenderInput | MessagesUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessagesCreateManySenderInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutSenderInput | MessagesUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutSenderInput | MessagesUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type MessagesUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessagesCreateWithoutReceiverInput, MessagesUncheckedCreateWithoutReceiverInput> | MessagesCreateWithoutReceiverInput[] | MessagesUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutReceiverInput | MessagesCreateOrConnectWithoutReceiverInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutReceiverInput | MessagesUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessagesCreateManyReceiverInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutReceiverInput | MessagesUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutReceiverInput | MessagesUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type FriendsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<FriendsCreateWithoutUsersInput, FriendsUncheckedCreateWithoutUsersInput> | FriendsCreateWithoutUsersInput[] | FriendsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutUsersInput | FriendsCreateOrConnectWithoutUsersInput[]
    upsert?: FriendsUpsertWithWhereUniqueWithoutUsersInput | FriendsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: FriendsCreateManyUsersInputEnvelope
    set?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    disconnect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    delete?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    update?: FriendsUpdateWithWhereUniqueWithoutUsersInput | FriendsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: FriendsUpdateManyWithWhereWithoutUsersInput | FriendsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
  }

  export type FriendsUpdateManyWithoutFriendNestedInput = {
    create?: XOR<FriendsCreateWithoutFriendInput, FriendsUncheckedCreateWithoutFriendInput> | FriendsCreateWithoutFriendInput[] | FriendsUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutFriendInput | FriendsCreateOrConnectWithoutFriendInput[]
    upsert?: FriendsUpsertWithWhereUniqueWithoutFriendInput | FriendsUpsertWithWhereUniqueWithoutFriendInput[]
    createMany?: FriendsCreateManyFriendInputEnvelope
    set?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    disconnect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    delete?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    update?: FriendsUpdateWithWhereUniqueWithoutFriendInput | FriendsUpdateWithWhereUniqueWithoutFriendInput[]
    updateMany?: FriendsUpdateManyWithWhereWithoutFriendInput | FriendsUpdateManyWithWhereWithoutFriendInput[]
    deleteMany?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
  }

  export type FollowersUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowersCreateWithoutFollowerInput, FollowersUncheckedCreateWithoutFollowerInput> | FollowersCreateWithoutFollowerInput[] | FollowersUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowersCreateOrConnectWithoutFollowerInput | FollowersCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowersUpsertWithWhereUniqueWithoutFollowerInput | FollowersUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowersCreateManyFollowerInputEnvelope
    set?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
    disconnect?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
    delete?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
    connect?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
    update?: FollowersUpdateWithWhereUniqueWithoutFollowerInput | FollowersUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowersUpdateManyWithWhereWithoutFollowerInput | FollowersUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowersScalarWhereInput | FollowersScalarWhereInput[]
  }

  export type FollowersUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowersCreateWithoutFollowingInput, FollowersUncheckedCreateWithoutFollowingInput> | FollowersCreateWithoutFollowingInput[] | FollowersUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowersCreateOrConnectWithoutFollowingInput | FollowersCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowersUpsertWithWhereUniqueWithoutFollowingInput | FollowersUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowersCreateManyFollowingInputEnvelope
    set?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
    disconnect?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
    delete?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
    connect?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
    update?: FollowersUpdateWithWhereUniqueWithoutFollowingInput | FollowersUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowersUpdateManyWithWhereWithoutFollowingInput | FollowersUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowersScalarWhereInput | FollowersScalarWhereInput[]
  }

  export type StoryViewerUpdateManyWithoutUsersNestedInput = {
    create?: XOR<StoryViewerCreateWithoutUsersInput, StoryViewerUncheckedCreateWithoutUsersInput> | StoryViewerCreateWithoutUsersInput[] | StoryViewerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: StoryViewerCreateOrConnectWithoutUsersInput | StoryViewerCreateOrConnectWithoutUsersInput[]
    upsert?: StoryViewerUpsertWithWhereUniqueWithoutUsersInput | StoryViewerUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: StoryViewerCreateManyUsersInputEnvelope
    set?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
    disconnect?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
    delete?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
    connect?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
    update?: StoryViewerUpdateWithWhereUniqueWithoutUsersInput | StoryViewerUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: StoryViewerUpdateManyWithWhereWithoutUsersInput | StoryViewerUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: StoryViewerScalarWhereInput | StoryViewerScalarWhereInput[]
  }

  export type PostsViewerUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PostsViewerCreateWithoutUsersInput, PostsViewerUncheckedCreateWithoutUsersInput> | PostsViewerCreateWithoutUsersInput[] | PostsViewerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PostsViewerCreateOrConnectWithoutUsersInput | PostsViewerCreateOrConnectWithoutUsersInput[]
    upsert?: PostsViewerUpsertWithWhereUniqueWithoutUsersInput | PostsViewerUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PostsViewerCreateManyUsersInputEnvelope
    set?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
    disconnect?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
    delete?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
    connect?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
    update?: PostsViewerUpdateWithWhereUniqueWithoutUsersInput | PostsViewerUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PostsViewerUpdateManyWithWhereWithoutUsersInput | PostsViewerUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PostsViewerScalarWhereInput | PostsViewerScalarWhereInput[]
  }

  export type CommentViewerUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CommentViewerCreateWithoutUsersInput, CommentViewerUncheckedCreateWithoutUsersInput> | CommentViewerCreateWithoutUsersInput[] | CommentViewerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CommentViewerCreateOrConnectWithoutUsersInput | CommentViewerCreateOrConnectWithoutUsersInput[]
    upsert?: CommentViewerUpsertWithWhereUniqueWithoutUsersInput | CommentViewerUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: CommentViewerCreateManyUsersInputEnvelope
    set?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
    disconnect?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
    delete?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
    connect?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
    update?: CommentViewerUpdateWithWhereUniqueWithoutUsersInput | CommentViewerUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CommentViewerUpdateManyWithWhereWithoutUsersInput | CommentViewerUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CommentViewerScalarWhereInput | CommentViewerScalarWhereInput[]
  }

  export type PostsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PostsCreateWithoutUsersInput, PostsUncheckedCreateWithoutUsersInput> | PostsCreateWithoutUsersInput[] | PostsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PostsCreateOrConnectWithoutUsersInput | PostsCreateOrConnectWithoutUsersInput[]
    upsert?: PostsUpsertWithWhereUniqueWithoutUsersInput | PostsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PostsCreateManyUsersInputEnvelope
    set?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    disconnect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    delete?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    connect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    update?: PostsUpdateWithWhereUniqueWithoutUsersInput | PostsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PostsUpdateManyWithWhereWithoutUsersInput | PostsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PostsScalarWhereInput | PostsScalarWhereInput[]
  }

  export type StoryUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<StoryCreateWithoutUsersInput, StoryUncheckedCreateWithoutUsersInput> | StoryCreateWithoutUsersInput[] | StoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: StoryCreateOrConnectWithoutUsersInput | StoryCreateOrConnectWithoutUsersInput[]
    upsert?: StoryUpsertWithWhereUniqueWithoutUsersInput | StoryUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: StoryCreateManyUsersInputEnvelope
    set?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    disconnect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    delete?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    connect?: StoryWhereUniqueInput | StoryWhereUniqueInput[]
    update?: StoryUpdateWithWhereUniqueWithoutUsersInput | StoryUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: StoryUpdateManyWithWhereWithoutUsersInput | StoryUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: StoryScalarWhereInput | StoryScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<LikeCreateWithoutUsersInput, LikeUncheckedCreateWithoutUsersInput> | LikeCreateWithoutUsersInput[] | LikeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutUsersInput | LikeCreateOrConnectWithoutUsersInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutUsersInput | LikeUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: LikeCreateManyUsersInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutUsersInput | LikeUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutUsersInput | LikeUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CommentCreateWithoutUsersInput, CommentUncheckedCreateWithoutUsersInput> | CommentCreateWithoutUsersInput[] | CommentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUsersInput | CommentCreateOrConnectWithoutUsersInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUsersInput | CommentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: CommentCreateManyUsersInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUsersInput | CommentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUsersInput | CommentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type RePostsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<RePostsCreateWithoutUsersInput, RePostsUncheckedCreateWithoutUsersInput> | RePostsCreateWithoutUsersInput[] | RePostsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: RePostsCreateOrConnectWithoutUsersInput | RePostsCreateOrConnectWithoutUsersInput[]
    upsert?: RePostsUpsertWithWhereUniqueWithoutUsersInput | RePostsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: RePostsCreateManyUsersInputEnvelope
    set?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
    disconnect?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
    delete?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
    connect?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
    update?: RePostsUpdateWithWhereUniqueWithoutUsersInput | RePostsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: RePostsUpdateManyWithWhereWithoutUsersInput | RePostsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: RePostsScalarWhereInput | RePostsScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<NotificationCreateWithoutUsersInput, NotificationUncheckedCreateWithoutUsersInput> | NotificationCreateWithoutUsersInput[] | NotificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUsersInput | NotificationCreateOrConnectWithoutUsersInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUsersInput | NotificationUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: NotificationCreateManyUsersInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUsersInput | NotificationUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUsersInput | NotificationUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput = {
    create?: XOR<NotificationCreateWithoutRelatedUsersInput, NotificationUncheckedCreateWithoutRelatedUsersInput> | NotificationCreateWithoutRelatedUsersInput[] | NotificationUncheckedCreateWithoutRelatedUsersInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRelatedUsersInput | NotificationCreateOrConnectWithoutRelatedUsersInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRelatedUsersInput | NotificationUpsertWithWhereUniqueWithoutRelatedUsersInput[]
    createMany?: NotificationCreateManyRelatedUsersInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRelatedUsersInput | NotificationUpdateWithWhereUniqueWithoutRelatedUsersInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRelatedUsersInput | NotificationUpdateManyWithWhereWithoutRelatedUsersInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type MessagesUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessagesCreateWithoutSenderInput, MessagesUncheckedCreateWithoutSenderInput> | MessagesCreateWithoutSenderInput[] | MessagesUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutSenderInput | MessagesCreateOrConnectWithoutSenderInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutSenderInput | MessagesUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessagesCreateManySenderInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutSenderInput | MessagesUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutSenderInput | MessagesUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type MessagesUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessagesCreateWithoutReceiverInput, MessagesUncheckedCreateWithoutReceiverInput> | MessagesCreateWithoutReceiverInput[] | MessagesUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessagesCreateOrConnectWithoutReceiverInput | MessagesCreateOrConnectWithoutReceiverInput[]
    upsert?: MessagesUpsertWithWhereUniqueWithoutReceiverInput | MessagesUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessagesCreateManyReceiverInputEnvelope
    set?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    disconnect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    delete?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    connect?: MessagesWhereUniqueInput | MessagesWhereUniqueInput[]
    update?: MessagesUpdateWithWhereUniqueWithoutReceiverInput | MessagesUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessagesUpdateManyWithWhereWithoutReceiverInput | MessagesUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
  }

  export type FriendsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<FriendsCreateWithoutUsersInput, FriendsUncheckedCreateWithoutUsersInput> | FriendsCreateWithoutUsersInput[] | FriendsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutUsersInput | FriendsCreateOrConnectWithoutUsersInput[]
    upsert?: FriendsUpsertWithWhereUniqueWithoutUsersInput | FriendsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: FriendsCreateManyUsersInputEnvelope
    set?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    disconnect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    delete?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    update?: FriendsUpdateWithWhereUniqueWithoutUsersInput | FriendsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: FriendsUpdateManyWithWhereWithoutUsersInput | FriendsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
  }

  export type FriendsUncheckedUpdateManyWithoutFriendNestedInput = {
    create?: XOR<FriendsCreateWithoutFriendInput, FriendsUncheckedCreateWithoutFriendInput> | FriendsCreateWithoutFriendInput[] | FriendsUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutFriendInput | FriendsCreateOrConnectWithoutFriendInput[]
    upsert?: FriendsUpsertWithWhereUniqueWithoutFriendInput | FriendsUpsertWithWhereUniqueWithoutFriendInput[]
    createMany?: FriendsCreateManyFriendInputEnvelope
    set?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    disconnect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    delete?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    update?: FriendsUpdateWithWhereUniqueWithoutFriendInput | FriendsUpdateWithWhereUniqueWithoutFriendInput[]
    updateMany?: FriendsUpdateManyWithWhereWithoutFriendInput | FriendsUpdateManyWithWhereWithoutFriendInput[]
    deleteMany?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
  }

  export type FollowersUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowersCreateWithoutFollowerInput, FollowersUncheckedCreateWithoutFollowerInput> | FollowersCreateWithoutFollowerInput[] | FollowersUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowersCreateOrConnectWithoutFollowerInput | FollowersCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowersUpsertWithWhereUniqueWithoutFollowerInput | FollowersUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowersCreateManyFollowerInputEnvelope
    set?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
    disconnect?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
    delete?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
    connect?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
    update?: FollowersUpdateWithWhereUniqueWithoutFollowerInput | FollowersUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowersUpdateManyWithWhereWithoutFollowerInput | FollowersUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowersScalarWhereInput | FollowersScalarWhereInput[]
  }

  export type FollowersUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<FollowersCreateWithoutFollowingInput, FollowersUncheckedCreateWithoutFollowingInput> | FollowersCreateWithoutFollowingInput[] | FollowersUncheckedCreateWithoutFollowingInput[]
    connectOrCreate?: FollowersCreateOrConnectWithoutFollowingInput | FollowersCreateOrConnectWithoutFollowingInput[]
    upsert?: FollowersUpsertWithWhereUniqueWithoutFollowingInput | FollowersUpsertWithWhereUniqueWithoutFollowingInput[]
    createMany?: FollowersCreateManyFollowingInputEnvelope
    set?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
    disconnect?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
    delete?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
    connect?: FollowersWhereUniqueInput | FollowersWhereUniqueInput[]
    update?: FollowersUpdateWithWhereUniqueWithoutFollowingInput | FollowersUpdateWithWhereUniqueWithoutFollowingInput[]
    updateMany?: FollowersUpdateManyWithWhereWithoutFollowingInput | FollowersUpdateManyWithWhereWithoutFollowingInput[]
    deleteMany?: FollowersScalarWhereInput | FollowersScalarWhereInput[]
  }

  export type StoryViewerUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<StoryViewerCreateWithoutUsersInput, StoryViewerUncheckedCreateWithoutUsersInput> | StoryViewerCreateWithoutUsersInput[] | StoryViewerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: StoryViewerCreateOrConnectWithoutUsersInput | StoryViewerCreateOrConnectWithoutUsersInput[]
    upsert?: StoryViewerUpsertWithWhereUniqueWithoutUsersInput | StoryViewerUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: StoryViewerCreateManyUsersInputEnvelope
    set?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
    disconnect?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
    delete?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
    connect?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
    update?: StoryViewerUpdateWithWhereUniqueWithoutUsersInput | StoryViewerUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: StoryViewerUpdateManyWithWhereWithoutUsersInput | StoryViewerUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: StoryViewerScalarWhereInput | StoryViewerScalarWhereInput[]
  }

  export type PostsViewerUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PostsViewerCreateWithoutUsersInput, PostsViewerUncheckedCreateWithoutUsersInput> | PostsViewerCreateWithoutUsersInput[] | PostsViewerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PostsViewerCreateOrConnectWithoutUsersInput | PostsViewerCreateOrConnectWithoutUsersInput[]
    upsert?: PostsViewerUpsertWithWhereUniqueWithoutUsersInput | PostsViewerUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PostsViewerCreateManyUsersInputEnvelope
    set?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
    disconnect?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
    delete?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
    connect?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
    update?: PostsViewerUpdateWithWhereUniqueWithoutUsersInput | PostsViewerUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PostsViewerUpdateManyWithWhereWithoutUsersInput | PostsViewerUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PostsViewerScalarWhereInput | PostsViewerScalarWhereInput[]
  }

  export type CommentViewerUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CommentViewerCreateWithoutUsersInput, CommentViewerUncheckedCreateWithoutUsersInput> | CommentViewerCreateWithoutUsersInput[] | CommentViewerUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CommentViewerCreateOrConnectWithoutUsersInput | CommentViewerCreateOrConnectWithoutUsersInput[]
    upsert?: CommentViewerUpsertWithWhereUniqueWithoutUsersInput | CommentViewerUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: CommentViewerCreateManyUsersInputEnvelope
    set?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
    disconnect?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
    delete?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
    connect?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
    update?: CommentViewerUpdateWithWhereUniqueWithoutUsersInput | CommentViewerUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CommentViewerUpdateManyWithWhereWithoutUsersInput | CommentViewerUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CommentViewerScalarWhereInput | CommentViewerScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutPostsInput = {
    create?: XOR<UsersCreateWithoutPostsInput, UsersUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPostsInput
    connect?: UsersWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutPostsInput = {
    create?: XOR<CommentCreateWithoutPostsInput, CommentUncheckedCreateWithoutPostsInput> | CommentCreateWithoutPostsInput[] | CommentUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostsInput | CommentCreateOrConnectWithoutPostsInput[]
    createMany?: CommentCreateManyPostsInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutPostsInput = {
    create?: XOR<LikeCreateWithoutPostsInput, LikeUncheckedCreateWithoutPostsInput> | LikeCreateWithoutPostsInput[] | LikeUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostsInput | LikeCreateOrConnectWithoutPostsInput[]
    createMany?: LikeCreateManyPostsInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type RePostsCreateNestedManyWithoutOriginalPostsInput = {
    create?: XOR<RePostsCreateWithoutOriginalPostsInput, RePostsUncheckedCreateWithoutOriginalPostsInput> | RePostsCreateWithoutOriginalPostsInput[] | RePostsUncheckedCreateWithoutOriginalPostsInput[]
    connectOrCreate?: RePostsCreateOrConnectWithoutOriginalPostsInput | RePostsCreateOrConnectWithoutOriginalPostsInput[]
    createMany?: RePostsCreateManyOriginalPostsInputEnvelope
    connect?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutPostsInput = {
    create?: XOR<AttachmentCreateWithoutPostsInput, AttachmentUncheckedCreateWithoutPostsInput> | AttachmentCreateWithoutPostsInput[] | AttachmentUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutPostsInput | AttachmentCreateOrConnectWithoutPostsInput[]
    createMany?: AttachmentCreateManyPostsInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type PostsViewerCreateNestedManyWithoutPostsInput = {
    create?: XOR<PostsViewerCreateWithoutPostsInput, PostsViewerUncheckedCreateWithoutPostsInput> | PostsViewerCreateWithoutPostsInput[] | PostsViewerUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PostsViewerCreateOrConnectWithoutPostsInput | PostsViewerCreateOrConnectWithoutPostsInput[]
    createMany?: PostsViewerCreateManyPostsInputEnvelope
    connect?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutPostsInput = {
    create?: XOR<NotificationCreateWithoutPostsInput, NotificationUncheckedCreateWithoutPostsInput> | NotificationCreateWithoutPostsInput[] | NotificationUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPostsInput | NotificationCreateOrConnectWithoutPostsInput[]
    createMany?: NotificationCreateManyPostsInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<CommentCreateWithoutPostsInput, CommentUncheckedCreateWithoutPostsInput> | CommentCreateWithoutPostsInput[] | CommentUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostsInput | CommentCreateOrConnectWithoutPostsInput[]
    createMany?: CommentCreateManyPostsInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<LikeCreateWithoutPostsInput, LikeUncheckedCreateWithoutPostsInput> | LikeCreateWithoutPostsInput[] | LikeUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostsInput | LikeCreateOrConnectWithoutPostsInput[]
    createMany?: LikeCreateManyPostsInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type RePostsUncheckedCreateNestedManyWithoutOriginalPostsInput = {
    create?: XOR<RePostsCreateWithoutOriginalPostsInput, RePostsUncheckedCreateWithoutOriginalPostsInput> | RePostsCreateWithoutOriginalPostsInput[] | RePostsUncheckedCreateWithoutOriginalPostsInput[]
    connectOrCreate?: RePostsCreateOrConnectWithoutOriginalPostsInput | RePostsCreateOrConnectWithoutOriginalPostsInput[]
    createMany?: RePostsCreateManyOriginalPostsInputEnvelope
    connect?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<AttachmentCreateWithoutPostsInput, AttachmentUncheckedCreateWithoutPostsInput> | AttachmentCreateWithoutPostsInput[] | AttachmentUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutPostsInput | AttachmentCreateOrConnectWithoutPostsInput[]
    createMany?: AttachmentCreateManyPostsInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type PostsViewerUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<PostsViewerCreateWithoutPostsInput, PostsViewerUncheckedCreateWithoutPostsInput> | PostsViewerCreateWithoutPostsInput[] | PostsViewerUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PostsViewerCreateOrConnectWithoutPostsInput | PostsViewerCreateOrConnectWithoutPostsInput[]
    createMany?: PostsViewerCreateManyPostsInputEnvelope
    connect?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<NotificationCreateWithoutPostsInput, NotificationUncheckedCreateWithoutPostsInput> | NotificationCreateWithoutPostsInput[] | NotificationUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPostsInput | NotificationCreateOrConnectWithoutPostsInput[]
    createMany?: NotificationCreateManyPostsInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type UsersUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UsersCreateWithoutPostsInput, UsersUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPostsInput
    upsert?: UsersUpsertWithoutPostsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutPostsInput, UsersUpdateWithoutPostsInput>, UsersUncheckedUpdateWithoutPostsInput>
  }

  export type CommentUpdateManyWithoutPostsNestedInput = {
    create?: XOR<CommentCreateWithoutPostsInput, CommentUncheckedCreateWithoutPostsInput> | CommentCreateWithoutPostsInput[] | CommentUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostsInput | CommentCreateOrConnectWithoutPostsInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostsInput | CommentUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: CommentCreateManyPostsInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostsInput | CommentUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostsInput | CommentUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutPostsNestedInput = {
    create?: XOR<LikeCreateWithoutPostsInput, LikeUncheckedCreateWithoutPostsInput> | LikeCreateWithoutPostsInput[] | LikeUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostsInput | LikeCreateOrConnectWithoutPostsInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPostsInput | LikeUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: LikeCreateManyPostsInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPostsInput | LikeUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPostsInput | LikeUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type RePostsUpdateManyWithoutOriginalPostsNestedInput = {
    create?: XOR<RePostsCreateWithoutOriginalPostsInput, RePostsUncheckedCreateWithoutOriginalPostsInput> | RePostsCreateWithoutOriginalPostsInput[] | RePostsUncheckedCreateWithoutOriginalPostsInput[]
    connectOrCreate?: RePostsCreateOrConnectWithoutOriginalPostsInput | RePostsCreateOrConnectWithoutOriginalPostsInput[]
    upsert?: RePostsUpsertWithWhereUniqueWithoutOriginalPostsInput | RePostsUpsertWithWhereUniqueWithoutOriginalPostsInput[]
    createMany?: RePostsCreateManyOriginalPostsInputEnvelope
    set?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
    disconnect?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
    delete?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
    connect?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
    update?: RePostsUpdateWithWhereUniqueWithoutOriginalPostsInput | RePostsUpdateWithWhereUniqueWithoutOriginalPostsInput[]
    updateMany?: RePostsUpdateManyWithWhereWithoutOriginalPostsInput | RePostsUpdateManyWithWhereWithoutOriginalPostsInput[]
    deleteMany?: RePostsScalarWhereInput | RePostsScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutPostsNestedInput = {
    create?: XOR<AttachmentCreateWithoutPostsInput, AttachmentUncheckedCreateWithoutPostsInput> | AttachmentCreateWithoutPostsInput[] | AttachmentUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutPostsInput | AttachmentCreateOrConnectWithoutPostsInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutPostsInput | AttachmentUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: AttachmentCreateManyPostsInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutPostsInput | AttachmentUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutPostsInput | AttachmentUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type PostsViewerUpdateManyWithoutPostsNestedInput = {
    create?: XOR<PostsViewerCreateWithoutPostsInput, PostsViewerUncheckedCreateWithoutPostsInput> | PostsViewerCreateWithoutPostsInput[] | PostsViewerUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PostsViewerCreateOrConnectWithoutPostsInput | PostsViewerCreateOrConnectWithoutPostsInput[]
    upsert?: PostsViewerUpsertWithWhereUniqueWithoutPostsInput | PostsViewerUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: PostsViewerCreateManyPostsInputEnvelope
    set?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
    disconnect?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
    delete?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
    connect?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
    update?: PostsViewerUpdateWithWhereUniqueWithoutPostsInput | PostsViewerUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: PostsViewerUpdateManyWithWhereWithoutPostsInput | PostsViewerUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: PostsViewerScalarWhereInput | PostsViewerScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutPostsNestedInput = {
    create?: XOR<NotificationCreateWithoutPostsInput, NotificationUncheckedCreateWithoutPostsInput> | NotificationCreateWithoutPostsInput[] | NotificationUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPostsInput | NotificationCreateOrConnectWithoutPostsInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutPostsInput | NotificationUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: NotificationCreateManyPostsInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutPostsInput | NotificationUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutPostsInput | NotificationUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<CommentCreateWithoutPostsInput, CommentUncheckedCreateWithoutPostsInput> | CommentCreateWithoutPostsInput[] | CommentUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostsInput | CommentCreateOrConnectWithoutPostsInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostsInput | CommentUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: CommentCreateManyPostsInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostsInput | CommentUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostsInput | CommentUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<LikeCreateWithoutPostsInput, LikeUncheckedCreateWithoutPostsInput> | LikeCreateWithoutPostsInput[] | LikeUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutPostsInput | LikeCreateOrConnectWithoutPostsInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutPostsInput | LikeUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: LikeCreateManyPostsInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutPostsInput | LikeUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutPostsInput | LikeUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type RePostsUncheckedUpdateManyWithoutOriginalPostsNestedInput = {
    create?: XOR<RePostsCreateWithoutOriginalPostsInput, RePostsUncheckedCreateWithoutOriginalPostsInput> | RePostsCreateWithoutOriginalPostsInput[] | RePostsUncheckedCreateWithoutOriginalPostsInput[]
    connectOrCreate?: RePostsCreateOrConnectWithoutOriginalPostsInput | RePostsCreateOrConnectWithoutOriginalPostsInput[]
    upsert?: RePostsUpsertWithWhereUniqueWithoutOriginalPostsInput | RePostsUpsertWithWhereUniqueWithoutOriginalPostsInput[]
    createMany?: RePostsCreateManyOriginalPostsInputEnvelope
    set?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
    disconnect?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
    delete?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
    connect?: RePostsWhereUniqueInput | RePostsWhereUniqueInput[]
    update?: RePostsUpdateWithWhereUniqueWithoutOriginalPostsInput | RePostsUpdateWithWhereUniqueWithoutOriginalPostsInput[]
    updateMany?: RePostsUpdateManyWithWhereWithoutOriginalPostsInput | RePostsUpdateManyWithWhereWithoutOriginalPostsInput[]
    deleteMany?: RePostsScalarWhereInput | RePostsScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<AttachmentCreateWithoutPostsInput, AttachmentUncheckedCreateWithoutPostsInput> | AttachmentCreateWithoutPostsInput[] | AttachmentUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutPostsInput | AttachmentCreateOrConnectWithoutPostsInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutPostsInput | AttachmentUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: AttachmentCreateManyPostsInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutPostsInput | AttachmentUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutPostsInput | AttachmentUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type PostsViewerUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<PostsViewerCreateWithoutPostsInput, PostsViewerUncheckedCreateWithoutPostsInput> | PostsViewerCreateWithoutPostsInput[] | PostsViewerUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: PostsViewerCreateOrConnectWithoutPostsInput | PostsViewerCreateOrConnectWithoutPostsInput[]
    upsert?: PostsViewerUpsertWithWhereUniqueWithoutPostsInput | PostsViewerUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: PostsViewerCreateManyPostsInputEnvelope
    set?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
    disconnect?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
    delete?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
    connect?: PostsViewerWhereUniqueInput | PostsViewerWhereUniqueInput[]
    update?: PostsViewerUpdateWithWhereUniqueWithoutPostsInput | PostsViewerUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: PostsViewerUpdateManyWithWhereWithoutPostsInput | PostsViewerUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: PostsViewerScalarWhereInput | PostsViewerScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<NotificationCreateWithoutPostsInput, NotificationUncheckedCreateWithoutPostsInput> | NotificationCreateWithoutPostsInput[] | NotificationUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPostsInput | NotificationCreateOrConnectWithoutPostsInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutPostsInput | NotificationUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: NotificationCreateManyPostsInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutPostsInput | NotificationUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutPostsInput | NotificationUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutStoriesInput = {
    create?: XOR<UsersCreateWithoutStoriesInput, UsersUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutStoriesInput
    connect?: UsersWhereUniqueInput
  }

  export type StoryViewerCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryViewerCreateWithoutStoryInput, StoryViewerUncheckedCreateWithoutStoryInput> | StoryViewerCreateWithoutStoryInput[] | StoryViewerUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryViewerCreateOrConnectWithoutStoryInput | StoryViewerCreateOrConnectWithoutStoryInput[]
    createMany?: StoryViewerCreateManyStoryInputEnvelope
    connect?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
  }

  export type LikeCreateNestedManyWithoutStoryInput = {
    create?: XOR<LikeCreateWithoutStoryInput, LikeUncheckedCreateWithoutStoryInput> | LikeCreateWithoutStoryInput[] | LikeUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutStoryInput | LikeCreateOrConnectWithoutStoryInput[]
    createMany?: LikeCreateManyStoryInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutStoryInput = {
    create?: XOR<CommentCreateWithoutStoryInput, CommentUncheckedCreateWithoutStoryInput> | CommentCreateWithoutStoryInput[] | CommentUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutStoryInput | CommentCreateOrConnectWithoutStoryInput[]
    createMany?: CommentCreateManyStoryInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutStoryInput = {
    create?: XOR<AttachmentCreateWithoutStoryInput, AttachmentUncheckedCreateWithoutStoryInput> | AttachmentCreateWithoutStoryInput[] | AttachmentUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutStoryInput | AttachmentCreateOrConnectWithoutStoryInput[]
    createMany?: AttachmentCreateManyStoryInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutStoryInput = {
    create?: XOR<NotificationCreateWithoutStoryInput, NotificationUncheckedCreateWithoutStoryInput> | NotificationCreateWithoutStoryInput[] | NotificationUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStoryInput | NotificationCreateOrConnectWithoutStoryInput[]
    createMany?: NotificationCreateManyStoryInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StoryViewerUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<StoryViewerCreateWithoutStoryInput, StoryViewerUncheckedCreateWithoutStoryInput> | StoryViewerCreateWithoutStoryInput[] | StoryViewerUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryViewerCreateOrConnectWithoutStoryInput | StoryViewerCreateOrConnectWithoutStoryInput[]
    createMany?: StoryViewerCreateManyStoryInputEnvelope
    connect?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
  }

  export type LikeUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<LikeCreateWithoutStoryInput, LikeUncheckedCreateWithoutStoryInput> | LikeCreateWithoutStoryInput[] | LikeUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutStoryInput | LikeCreateOrConnectWithoutStoryInput[]
    createMany?: LikeCreateManyStoryInputEnvelope
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<CommentCreateWithoutStoryInput, CommentUncheckedCreateWithoutStoryInput> | CommentCreateWithoutStoryInput[] | CommentUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutStoryInput | CommentCreateOrConnectWithoutStoryInput[]
    createMany?: CommentCreateManyStoryInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<AttachmentCreateWithoutStoryInput, AttachmentUncheckedCreateWithoutStoryInput> | AttachmentCreateWithoutStoryInput[] | AttachmentUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutStoryInput | AttachmentCreateOrConnectWithoutStoryInput[]
    createMany?: AttachmentCreateManyStoryInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutStoryInput = {
    create?: XOR<NotificationCreateWithoutStoryInput, NotificationUncheckedCreateWithoutStoryInput> | NotificationCreateWithoutStoryInput[] | NotificationUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStoryInput | NotificationCreateOrConnectWithoutStoryInput[]
    createMany?: NotificationCreateManyStoryInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UsersUpdateOneRequiredWithoutStoriesNestedInput = {
    create?: XOR<UsersCreateWithoutStoriesInput, UsersUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutStoriesInput
    upsert?: UsersUpsertWithoutStoriesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutStoriesInput, UsersUpdateWithoutStoriesInput>, UsersUncheckedUpdateWithoutStoriesInput>
  }

  export type StoryViewerUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryViewerCreateWithoutStoryInput, StoryViewerUncheckedCreateWithoutStoryInput> | StoryViewerCreateWithoutStoryInput[] | StoryViewerUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryViewerCreateOrConnectWithoutStoryInput | StoryViewerCreateOrConnectWithoutStoryInput[]
    upsert?: StoryViewerUpsertWithWhereUniqueWithoutStoryInput | StoryViewerUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryViewerCreateManyStoryInputEnvelope
    set?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
    disconnect?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
    delete?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
    connect?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
    update?: StoryViewerUpdateWithWhereUniqueWithoutStoryInput | StoryViewerUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryViewerUpdateManyWithWhereWithoutStoryInput | StoryViewerUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryViewerScalarWhereInput | StoryViewerScalarWhereInput[]
  }

  export type LikeUpdateManyWithoutStoryNestedInput = {
    create?: XOR<LikeCreateWithoutStoryInput, LikeUncheckedCreateWithoutStoryInput> | LikeCreateWithoutStoryInput[] | LikeUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutStoryInput | LikeCreateOrConnectWithoutStoryInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutStoryInput | LikeUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: LikeCreateManyStoryInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutStoryInput | LikeUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutStoryInput | LikeUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutStoryNestedInput = {
    create?: XOR<CommentCreateWithoutStoryInput, CommentUncheckedCreateWithoutStoryInput> | CommentCreateWithoutStoryInput[] | CommentUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutStoryInput | CommentCreateOrConnectWithoutStoryInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutStoryInput | CommentUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: CommentCreateManyStoryInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutStoryInput | CommentUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutStoryInput | CommentUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutStoryNestedInput = {
    create?: XOR<AttachmentCreateWithoutStoryInput, AttachmentUncheckedCreateWithoutStoryInput> | AttachmentCreateWithoutStoryInput[] | AttachmentUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutStoryInput | AttachmentCreateOrConnectWithoutStoryInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutStoryInput | AttachmentUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: AttachmentCreateManyStoryInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutStoryInput | AttachmentUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutStoryInput | AttachmentUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutStoryNestedInput = {
    create?: XOR<NotificationCreateWithoutStoryInput, NotificationUncheckedCreateWithoutStoryInput> | NotificationCreateWithoutStoryInput[] | NotificationUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStoryInput | NotificationCreateOrConnectWithoutStoryInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutStoryInput | NotificationUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: NotificationCreateManyStoryInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutStoryInput | NotificationUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutStoryInput | NotificationUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type StoryViewerUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<StoryViewerCreateWithoutStoryInput, StoryViewerUncheckedCreateWithoutStoryInput> | StoryViewerCreateWithoutStoryInput[] | StoryViewerUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: StoryViewerCreateOrConnectWithoutStoryInput | StoryViewerCreateOrConnectWithoutStoryInput[]
    upsert?: StoryViewerUpsertWithWhereUniqueWithoutStoryInput | StoryViewerUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: StoryViewerCreateManyStoryInputEnvelope
    set?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
    disconnect?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
    delete?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
    connect?: StoryViewerWhereUniqueInput | StoryViewerWhereUniqueInput[]
    update?: StoryViewerUpdateWithWhereUniqueWithoutStoryInput | StoryViewerUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: StoryViewerUpdateManyWithWhereWithoutStoryInput | StoryViewerUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: StoryViewerScalarWhereInput | StoryViewerScalarWhereInput[]
  }

  export type LikeUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<LikeCreateWithoutStoryInput, LikeUncheckedCreateWithoutStoryInput> | LikeCreateWithoutStoryInput[] | LikeUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: LikeCreateOrConnectWithoutStoryInput | LikeCreateOrConnectWithoutStoryInput[]
    upsert?: LikeUpsertWithWhereUniqueWithoutStoryInput | LikeUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: LikeCreateManyStoryInputEnvelope
    set?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    disconnect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    delete?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    connect?: LikeWhereUniqueInput | LikeWhereUniqueInput[]
    update?: LikeUpdateWithWhereUniqueWithoutStoryInput | LikeUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: LikeUpdateManyWithWhereWithoutStoryInput | LikeUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: LikeScalarWhereInput | LikeScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<CommentCreateWithoutStoryInput, CommentUncheckedCreateWithoutStoryInput> | CommentCreateWithoutStoryInput[] | CommentUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutStoryInput | CommentCreateOrConnectWithoutStoryInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutStoryInput | CommentUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: CommentCreateManyStoryInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutStoryInput | CommentUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutStoryInput | CommentUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<AttachmentCreateWithoutStoryInput, AttachmentUncheckedCreateWithoutStoryInput> | AttachmentCreateWithoutStoryInput[] | AttachmentUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutStoryInput | AttachmentCreateOrConnectWithoutStoryInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutStoryInput | AttachmentUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: AttachmentCreateManyStoryInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutStoryInput | AttachmentUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutStoryInput | AttachmentUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutStoryNestedInput = {
    create?: XOR<NotificationCreateWithoutStoryInput, NotificationUncheckedCreateWithoutStoryInput> | NotificationCreateWithoutStoryInput[] | NotificationUncheckedCreateWithoutStoryInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStoryInput | NotificationCreateOrConnectWithoutStoryInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutStoryInput | NotificationUpsertWithWhereUniqueWithoutStoryInput[]
    createMany?: NotificationCreateManyStoryInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutStoryInput | NotificationUpdateWithWhereUniqueWithoutStoryInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutStoryInput | NotificationUpdateManyWithWhereWithoutStoryInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutLikesInput = {
    create?: XOR<UsersCreateWithoutLikesInput, UsersUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutLikesInput
    connect?: UsersWhereUniqueInput
  }

  export type PostsCreateNestedOneWithoutLikesInput = {
    create?: XOR<PostsCreateWithoutLikesInput, PostsUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostsCreateOrConnectWithoutLikesInput
    connect?: PostsWhereUniqueInput
  }

  export type StoryCreateNestedOneWithoutLikesInput = {
    create?: XOR<StoryCreateWithoutLikesInput, StoryUncheckedCreateWithoutLikesInput>
    connectOrCreate?: StoryCreateOrConnectWithoutLikesInput
    connect?: StoryWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<UsersCreateWithoutLikesInput, UsersUncheckedCreateWithoutLikesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutLikesInput
    upsert?: UsersUpsertWithoutLikesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutLikesInput, UsersUpdateWithoutLikesInput>, UsersUncheckedUpdateWithoutLikesInput>
  }

  export type PostsUpdateOneWithoutLikesNestedInput = {
    create?: XOR<PostsCreateWithoutLikesInput, PostsUncheckedCreateWithoutLikesInput>
    connectOrCreate?: PostsCreateOrConnectWithoutLikesInput
    upsert?: PostsUpsertWithoutLikesInput
    disconnect?: PostsWhereInput | boolean
    delete?: PostsWhereInput | boolean
    connect?: PostsWhereUniqueInput
    update?: XOR<XOR<PostsUpdateToOneWithWhereWithoutLikesInput, PostsUpdateWithoutLikesInput>, PostsUncheckedUpdateWithoutLikesInput>
  }

  export type StoryUpdateOneWithoutLikesNestedInput = {
    create?: XOR<StoryCreateWithoutLikesInput, StoryUncheckedCreateWithoutLikesInput>
    connectOrCreate?: StoryCreateOrConnectWithoutLikesInput
    upsert?: StoryUpsertWithoutLikesInput
    disconnect?: StoryWhereInput | boolean
    delete?: StoryWhereInput | boolean
    connect?: StoryWhereUniqueInput
    update?: XOR<XOR<StoryUpdateToOneWithWhereWithoutLikesInput, StoryUpdateWithoutLikesInput>, StoryUncheckedUpdateWithoutLikesInput>
  }

  export type UsersCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UsersCreateWithoutCommentsInput, UsersUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCommentsInput
    connect?: UsersWhereUniqueInput
  }

  export type PostsCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostsCreateWithoutCommentsInput, PostsUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostsCreateOrConnectWithoutCommentsInput
    connect?: PostsWhereUniqueInput
  }

  export type StoryCreateNestedOneWithoutCommentsInput = {
    create?: XOR<StoryCreateWithoutCommentsInput, StoryUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: StoryCreateOrConnectWithoutCommentsInput
    connect?: StoryWhereUniqueInput
  }

  export type CommentViewerCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentViewerCreateWithoutCommentInput, CommentViewerUncheckedCreateWithoutCommentInput> | CommentViewerCreateWithoutCommentInput[] | CommentViewerUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentViewerCreateOrConnectWithoutCommentInput | CommentViewerCreateOrConnectWithoutCommentInput[]
    createMany?: CommentViewerCreateManyCommentInputEnvelope
    connect?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutCommentInput = {
    create?: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput> | AttachmentCreateWithoutCommentInput[] | AttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCommentInput | AttachmentCreateOrConnectWithoutCommentInput[]
    createMany?: AttachmentCreateManyCommentInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutCommentInput = {
    create?: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput> | NotificationCreateWithoutCommentInput[] | NotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCommentInput | NotificationCreateOrConnectWithoutCommentInput[]
    createMany?: NotificationCreateManyCommentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CommentViewerUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentViewerCreateWithoutCommentInput, CommentViewerUncheckedCreateWithoutCommentInput> | CommentViewerCreateWithoutCommentInput[] | CommentViewerUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentViewerCreateOrConnectWithoutCommentInput | CommentViewerCreateOrConnectWithoutCommentInput[]
    createMany?: CommentViewerCreateManyCommentInputEnvelope
    connect?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput> | AttachmentCreateWithoutCommentInput[] | AttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCommentInput | AttachmentCreateOrConnectWithoutCommentInput[]
    createMany?: AttachmentCreateManyCommentInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput> | NotificationCreateWithoutCommentInput[] | NotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCommentInput | NotificationCreateOrConnectWithoutCommentInput[]
    createMany?: NotificationCreateManyCommentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UsersUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UsersCreateWithoutCommentsInput, UsersUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCommentsInput
    upsert?: UsersUpsertWithoutCommentsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutCommentsInput, UsersUpdateWithoutCommentsInput>, UsersUncheckedUpdateWithoutCommentsInput>
  }

  export type PostsUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<PostsCreateWithoutCommentsInput, PostsUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostsCreateOrConnectWithoutCommentsInput
    upsert?: PostsUpsertWithoutCommentsInput
    disconnect?: PostsWhereInput | boolean
    delete?: PostsWhereInput | boolean
    connect?: PostsWhereUniqueInput
    update?: XOR<XOR<PostsUpdateToOneWithWhereWithoutCommentsInput, PostsUpdateWithoutCommentsInput>, PostsUncheckedUpdateWithoutCommentsInput>
  }

  export type StoryUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<StoryCreateWithoutCommentsInput, StoryUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: StoryCreateOrConnectWithoutCommentsInput
    upsert?: StoryUpsertWithoutCommentsInput
    disconnect?: StoryWhereInput | boolean
    delete?: StoryWhereInput | boolean
    connect?: StoryWhereUniqueInput
    update?: XOR<XOR<StoryUpdateToOneWithWhereWithoutCommentsInput, StoryUpdateWithoutCommentsInput>, StoryUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentViewerUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentViewerCreateWithoutCommentInput, CommentViewerUncheckedCreateWithoutCommentInput> | CommentViewerCreateWithoutCommentInput[] | CommentViewerUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentViewerCreateOrConnectWithoutCommentInput | CommentViewerCreateOrConnectWithoutCommentInput[]
    upsert?: CommentViewerUpsertWithWhereUniqueWithoutCommentInput | CommentViewerUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentViewerCreateManyCommentInputEnvelope
    set?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
    disconnect?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
    delete?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
    connect?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
    update?: CommentViewerUpdateWithWhereUniqueWithoutCommentInput | CommentViewerUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentViewerUpdateManyWithWhereWithoutCommentInput | CommentViewerUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentViewerScalarWhereInput | CommentViewerScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutCommentNestedInput = {
    create?: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput> | AttachmentCreateWithoutCommentInput[] | AttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCommentInput | AttachmentCreateOrConnectWithoutCommentInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutCommentInput | AttachmentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: AttachmentCreateManyCommentInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutCommentInput | AttachmentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutCommentInput | AttachmentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutCommentNestedInput = {
    create?: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput> | NotificationCreateWithoutCommentInput[] | NotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCommentInput | NotificationCreateOrConnectWithoutCommentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCommentInput | NotificationUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: NotificationCreateManyCommentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCommentInput | NotificationUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCommentInput | NotificationUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CommentViewerUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentViewerCreateWithoutCommentInput, CommentViewerUncheckedCreateWithoutCommentInput> | CommentViewerCreateWithoutCommentInput[] | CommentViewerUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentViewerCreateOrConnectWithoutCommentInput | CommentViewerCreateOrConnectWithoutCommentInput[]
    upsert?: CommentViewerUpsertWithWhereUniqueWithoutCommentInput | CommentViewerUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentViewerCreateManyCommentInputEnvelope
    set?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
    disconnect?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
    delete?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
    connect?: CommentViewerWhereUniqueInput | CommentViewerWhereUniqueInput[]
    update?: CommentViewerUpdateWithWhereUniqueWithoutCommentInput | CommentViewerUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentViewerUpdateManyWithWhereWithoutCommentInput | CommentViewerUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentViewerScalarWhereInput | CommentViewerScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput> | AttachmentCreateWithoutCommentInput[] | AttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCommentInput | AttachmentCreateOrConnectWithoutCommentInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutCommentInput | AttachmentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: AttachmentCreateManyCommentInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutCommentInput | AttachmentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutCommentInput | AttachmentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput> | NotificationCreateWithoutCommentInput[] | NotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCommentInput | NotificationCreateOrConnectWithoutCommentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCommentInput | NotificationUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: NotificationCreateManyCommentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCommentInput | NotificationUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCommentInput | NotificationUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutRepostsInput = {
    create?: XOR<UsersCreateWithoutRepostsInput, UsersUncheckedCreateWithoutRepostsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutRepostsInput
    connect?: UsersWhereUniqueInput
  }

  export type PostsCreateNestedOneWithoutRepostsInput = {
    create?: XOR<PostsCreateWithoutRepostsInput, PostsUncheckedCreateWithoutRepostsInput>
    connectOrCreate?: PostsCreateOrConnectWithoutRepostsInput
    connect?: PostsWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutRepostsNestedInput = {
    create?: XOR<UsersCreateWithoutRepostsInput, UsersUncheckedCreateWithoutRepostsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutRepostsInput
    upsert?: UsersUpsertWithoutRepostsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutRepostsInput, UsersUpdateWithoutRepostsInput>, UsersUncheckedUpdateWithoutRepostsInput>
  }

  export type PostsUpdateOneRequiredWithoutRepostsNestedInput = {
    create?: XOR<PostsCreateWithoutRepostsInput, PostsUncheckedCreateWithoutRepostsInput>
    connectOrCreate?: PostsCreateOrConnectWithoutRepostsInput
    upsert?: PostsUpsertWithoutRepostsInput
    connect?: PostsWhereUniqueInput
    update?: XOR<XOR<PostsUpdateToOneWithWhereWithoutRepostsInput, PostsUpdateWithoutRepostsInput>, PostsUncheckedUpdateWithoutRepostsInput>
  }

  export type PostsCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<PostsCreateWithoutAttachmentsInput, PostsUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: PostsCreateOrConnectWithoutAttachmentsInput
    connect?: PostsWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<CommentCreateWithoutAttachmentsInput, CommentUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutAttachmentsInput
    connect?: CommentWhereUniqueInput
  }

  export type StoryCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<StoryCreateWithoutAttachmentsInput, StoryUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: StoryCreateOrConnectWithoutAttachmentsInput
    connect?: StoryWhereUniqueInput
  }

  export type EnumFileTypeFieldUpdateOperationsInput = {
    set?: $Enums.FileType
  }

  export type PostsUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<PostsCreateWithoutAttachmentsInput, PostsUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: PostsCreateOrConnectWithoutAttachmentsInput
    upsert?: PostsUpsertWithoutAttachmentsInput
    disconnect?: PostsWhereInput | boolean
    delete?: PostsWhereInput | boolean
    connect?: PostsWhereUniqueInput
    update?: XOR<XOR<PostsUpdateToOneWithWhereWithoutAttachmentsInput, PostsUpdateWithoutAttachmentsInput>, PostsUncheckedUpdateWithoutAttachmentsInput>
  }

  export type CommentUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<CommentCreateWithoutAttachmentsInput, CommentUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutAttachmentsInput
    upsert?: CommentUpsertWithoutAttachmentsInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutAttachmentsInput, CommentUpdateWithoutAttachmentsInput>, CommentUncheckedUpdateWithoutAttachmentsInput>
  }

  export type StoryUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<StoryCreateWithoutAttachmentsInput, StoryUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: StoryCreateOrConnectWithoutAttachmentsInput
    upsert?: StoryUpsertWithoutAttachmentsInput
    disconnect?: StoryWhereInput | boolean
    delete?: StoryWhereInput | boolean
    connect?: StoryWhereUniqueInput
    update?: XOR<XOR<StoryUpdateToOneWithWhereWithoutAttachmentsInput, StoryUpdateWithoutAttachmentsInput>, StoryUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UsersCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UsersCreateWithoutNotificationsInput, UsersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutNotificationsInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutRelatedNotificationsInput = {
    create?: XOR<UsersCreateWithoutRelatedNotificationsInput, UsersUncheckedCreateWithoutRelatedNotificationsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutRelatedNotificationsInput
    connect?: UsersWhereUniqueInput
  }

  export type PostsCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<PostsCreateWithoutNotificationsInput, PostsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PostsCreateOrConnectWithoutNotificationsInput
    connect?: PostsWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<CommentCreateWithoutNotificationsInput, CommentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutNotificationsInput
    connect?: CommentWhereUniqueInput
  }

  export type StoryCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<StoryCreateWithoutNotificationsInput, StoryUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: StoryCreateOrConnectWithoutNotificationsInput
    connect?: StoryWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UsersUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UsersCreateWithoutNotificationsInput, UsersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutNotificationsInput
    upsert?: UsersUpsertWithoutNotificationsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutNotificationsInput, UsersUpdateWithoutNotificationsInput>, UsersUncheckedUpdateWithoutNotificationsInput>
  }

  export type UsersUpdateOneWithoutRelatedNotificationsNestedInput = {
    create?: XOR<UsersCreateWithoutRelatedNotificationsInput, UsersUncheckedCreateWithoutRelatedNotificationsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutRelatedNotificationsInput
    upsert?: UsersUpsertWithoutRelatedNotificationsInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutRelatedNotificationsInput, UsersUpdateWithoutRelatedNotificationsInput>, UsersUncheckedUpdateWithoutRelatedNotificationsInput>
  }

  export type PostsUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<PostsCreateWithoutNotificationsInput, PostsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PostsCreateOrConnectWithoutNotificationsInput
    upsert?: PostsUpsertWithoutNotificationsInput
    disconnect?: PostsWhereInput | boolean
    delete?: PostsWhereInput | boolean
    connect?: PostsWhereUniqueInput
    update?: XOR<XOR<PostsUpdateToOneWithWhereWithoutNotificationsInput, PostsUpdateWithoutNotificationsInput>, PostsUncheckedUpdateWithoutNotificationsInput>
  }

  export type CommentUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<CommentCreateWithoutNotificationsInput, CommentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutNotificationsInput
    upsert?: CommentUpsertWithoutNotificationsInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutNotificationsInput, CommentUpdateWithoutNotificationsInput>, CommentUncheckedUpdateWithoutNotificationsInput>
  }

  export type StoryUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<StoryCreateWithoutNotificationsInput, StoryUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: StoryCreateOrConnectWithoutNotificationsInput
    upsert?: StoryUpsertWithoutNotificationsInput
    disconnect?: StoryWhereInput | boolean
    delete?: StoryWhereInput | boolean
    connect?: StoryWhereUniqueInput
    update?: XOR<XOR<StoryUpdateToOneWithWhereWithoutNotificationsInput, StoryUpdateWithoutNotificationsInput>, StoryUncheckedUpdateWithoutNotificationsInput>
  }

  export type UsersCreateNestedOneWithoutMessagesSentInput = {
    create?: XOR<UsersCreateWithoutMessagesSentInput, UsersUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMessagesSentInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutMessagesReceivedInput = {
    create?: XOR<UsersCreateWithoutMessagesReceivedInput, UsersUncheckedCreateWithoutMessagesReceivedInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMessagesReceivedInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutMessagesSentNestedInput = {
    create?: XOR<UsersCreateWithoutMessagesSentInput, UsersUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMessagesSentInput
    upsert?: UsersUpsertWithoutMessagesSentInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutMessagesSentInput, UsersUpdateWithoutMessagesSentInput>, UsersUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UsersUpdateOneRequiredWithoutMessagesReceivedNestedInput = {
    create?: XOR<UsersCreateWithoutMessagesReceivedInput, UsersUncheckedCreateWithoutMessagesReceivedInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMessagesReceivedInput
    upsert?: UsersUpsertWithoutMessagesReceivedInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutMessagesReceivedInput, UsersUpdateWithoutMessagesReceivedInput>, UsersUncheckedUpdateWithoutMessagesReceivedInput>
  }

  export type UsersCreateNestedOneWithoutFriendsInput = {
    create?: XOR<UsersCreateWithoutFriendsInput, UsersUncheckedCreateWithoutFriendsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFriendsInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutFriendOfInput = {
    create?: XOR<UsersCreateWithoutFriendOfInput, UsersUncheckedCreateWithoutFriendOfInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFriendOfInput
    connect?: UsersWhereUniqueInput
  }

  export type EnumFriendStatusFieldUpdateOperationsInput = {
    set?: $Enums.FriendStatus
  }

  export type UsersUpdateOneRequiredWithoutFriendsNestedInput = {
    create?: XOR<UsersCreateWithoutFriendsInput, UsersUncheckedCreateWithoutFriendsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFriendsInput
    upsert?: UsersUpsertWithoutFriendsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFriendsInput, UsersUpdateWithoutFriendsInput>, UsersUncheckedUpdateWithoutFriendsInput>
  }

  export type UsersUpdateOneRequiredWithoutFriendOfNestedInput = {
    create?: XOR<UsersCreateWithoutFriendOfInput, UsersUncheckedCreateWithoutFriendOfInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFriendOfInput
    upsert?: UsersUpsertWithoutFriendOfInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFriendOfInput, UsersUpdateWithoutFriendOfInput>, UsersUncheckedUpdateWithoutFriendOfInput>
  }

  export type UsersCreateNestedOneWithoutFollowersInput = {
    create?: XOR<UsersCreateWithoutFollowersInput, UsersUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFollowersInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutFollowingInput = {
    create?: XOR<UsersCreateWithoutFollowingInput, UsersUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFollowingInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<UsersCreateWithoutFollowersInput, UsersUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFollowersInput
    upsert?: UsersUpsertWithoutFollowersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFollowersInput, UsersUpdateWithoutFollowersInput>, UsersUncheckedUpdateWithoutFollowersInput>
  }

  export type UsersUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<UsersCreateWithoutFollowingInput, UsersUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFollowingInput
    upsert?: UsersUpsertWithoutFollowingInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFollowingInput, UsersUpdateWithoutFollowingInput>, UsersUncheckedUpdateWithoutFollowingInput>
  }

  export type StoryCreateNestedOneWithoutViewersInput = {
    create?: XOR<StoryCreateWithoutViewersInput, StoryUncheckedCreateWithoutViewersInput>
    connectOrCreate?: StoryCreateOrConnectWithoutViewersInput
    connect?: StoryWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutStoryViewersInput = {
    create?: XOR<UsersCreateWithoutStoryViewersInput, UsersUncheckedCreateWithoutStoryViewersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutStoryViewersInput
    connect?: UsersWhereUniqueInput
  }

  export type StoryUpdateOneRequiredWithoutViewersNestedInput = {
    create?: XOR<StoryCreateWithoutViewersInput, StoryUncheckedCreateWithoutViewersInput>
    connectOrCreate?: StoryCreateOrConnectWithoutViewersInput
    upsert?: StoryUpsertWithoutViewersInput
    connect?: StoryWhereUniqueInput
    update?: XOR<XOR<StoryUpdateToOneWithWhereWithoutViewersInput, StoryUpdateWithoutViewersInput>, StoryUncheckedUpdateWithoutViewersInput>
  }

  export type UsersUpdateOneRequiredWithoutStoryViewersNestedInput = {
    create?: XOR<UsersCreateWithoutStoryViewersInput, UsersUncheckedCreateWithoutStoryViewersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutStoryViewersInput
    upsert?: UsersUpsertWithoutStoryViewersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutStoryViewersInput, UsersUpdateWithoutStoryViewersInput>, UsersUncheckedUpdateWithoutStoryViewersInput>
  }

  export type PostsCreateNestedOneWithoutViewersInput = {
    create?: XOR<PostsCreateWithoutViewersInput, PostsUncheckedCreateWithoutViewersInput>
    connectOrCreate?: PostsCreateOrConnectWithoutViewersInput
    connect?: PostsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutPostViewersInput = {
    create?: XOR<UsersCreateWithoutPostViewersInput, UsersUncheckedCreateWithoutPostViewersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPostViewersInput
    connect?: UsersWhereUniqueInput
  }

  export type PostsUpdateOneRequiredWithoutViewersNestedInput = {
    create?: XOR<PostsCreateWithoutViewersInput, PostsUncheckedCreateWithoutViewersInput>
    connectOrCreate?: PostsCreateOrConnectWithoutViewersInput
    upsert?: PostsUpsertWithoutViewersInput
    connect?: PostsWhereUniqueInput
    update?: XOR<XOR<PostsUpdateToOneWithWhereWithoutViewersInput, PostsUpdateWithoutViewersInput>, PostsUncheckedUpdateWithoutViewersInput>
  }

  export type UsersUpdateOneRequiredWithoutPostViewersNestedInput = {
    create?: XOR<UsersCreateWithoutPostViewersInput, UsersUncheckedCreateWithoutPostViewersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPostViewersInput
    upsert?: UsersUpsertWithoutPostViewersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutPostViewersInput, UsersUpdateWithoutPostViewersInput>, UsersUncheckedUpdateWithoutPostViewersInput>
  }

  export type CommentCreateNestedOneWithoutViewersInput = {
    create?: XOR<CommentCreateWithoutViewersInput, CommentUncheckedCreateWithoutViewersInput>
    connectOrCreate?: CommentCreateOrConnectWithoutViewersInput
    connect?: CommentWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutCommentViewersInput = {
    create?: XOR<UsersCreateWithoutCommentViewersInput, UsersUncheckedCreateWithoutCommentViewersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCommentViewersInput
    connect?: UsersWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutViewersNestedInput = {
    create?: XOR<CommentCreateWithoutViewersInput, CommentUncheckedCreateWithoutViewersInput>
    connectOrCreate?: CommentCreateOrConnectWithoutViewersInput
    upsert?: CommentUpsertWithoutViewersInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutViewersInput, CommentUpdateWithoutViewersInput>, CommentUncheckedUpdateWithoutViewersInput>
  }

  export type UsersUpdateOneRequiredWithoutCommentViewersNestedInput = {
    create?: XOR<UsersCreateWithoutCommentViewersInput, UsersUncheckedCreateWithoutCommentViewersInput>
    connectOrCreate?: UsersCreateOrConnectWithoutCommentViewersInput
    upsert?: UsersUpsertWithoutCommentViewersInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutCommentViewersInput, UsersUpdateWithoutCommentViewersInput>, UsersUncheckedUpdateWithoutCommentViewersInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedEnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type NestedEnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumFriendStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendStatus | EnumFriendStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendStatus[] | ListEnumFriendStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendStatus[] | ListEnumFriendStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendStatusFilter<$PrismaModel> | $Enums.FriendStatus
  }

  export type NestedEnumFriendStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendStatus | EnumFriendStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendStatus[] | ListEnumFriendStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendStatus[] | ListEnumFriendStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendStatusFilter<$PrismaModel>
  }

  export type PostsCreateWithoutUsersInput = {
    id?: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPostsInput
    likes?: LikeCreateNestedManyWithoutPostsInput
    reposts?: RePostsCreateNestedManyWithoutOriginalPostsInput
    attachments?: AttachmentCreateNestedManyWithoutPostsInput
    viewers?: PostsViewerCreateNestedManyWithoutPostsInput
    notifications?: NotificationCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateWithoutUsersInput = {
    id?: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostsInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostsInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutOriginalPostsInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutPostsInput
    viewers?: PostsViewerUncheckedCreateNestedManyWithoutPostsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsCreateOrConnectWithoutUsersInput = {
    where: PostsWhereUniqueInput
    create: XOR<PostsCreateWithoutUsersInput, PostsUncheckedCreateWithoutUsersInput>
  }

  export type PostsCreateManyUsersInputEnvelope = {
    data: PostsCreateManyUsersInput | PostsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type StoryCreateWithoutUsersInput = {
    id?: string
    contentText?: string | null
    contentMedia?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    expirationTime: Date | string
    viewers?: StoryViewerCreateNestedManyWithoutStoryInput
    likes?: LikeCreateNestedManyWithoutStoryInput
    comments?: CommentCreateNestedManyWithoutStoryInput
    attachments?: AttachmentCreateNestedManyWithoutStoryInput
    notifications?: NotificationCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutUsersInput = {
    id?: string
    contentText?: string | null
    contentMedia?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    expirationTime: Date | string
    viewers?: StoryViewerUncheckedCreateNestedManyWithoutStoryInput
    likes?: LikeUncheckedCreateNestedManyWithoutStoryInput
    comments?: CommentUncheckedCreateNestedManyWithoutStoryInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutStoryInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutUsersInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutUsersInput, StoryUncheckedCreateWithoutUsersInput>
  }

  export type StoryCreateManyUsersInputEnvelope = {
    data: StoryCreateManyUsersInput | StoryCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string
    posts?: PostsCreateNestedOneWithoutLikesInput
    story?: StoryCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutUsersInput = {
    id?: string
    postsId?: string | null
    storyId?: string | null
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutUsersInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutUsersInput, LikeUncheckedCreateWithoutUsersInput>
  }

  export type LikeCreateManyUsersInputEnvelope = {
    data: LikeCreateManyUsersInput | LikeCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUsersInput = {
    id?: string
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedOneWithoutCommentsInput
    story?: StoryCreateNestedOneWithoutCommentsInput
    viewers?: CommentViewerCreateNestedManyWithoutCommentInput
    attachments?: AttachmentCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutUsersInput = {
    id?: string
    postsId?: string | null
    storyId?: string | null
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    viewers?: CommentViewerUncheckedCreateNestedManyWithoutCommentInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutUsersInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUsersInput, CommentUncheckedCreateWithoutUsersInput>
  }

  export type CommentCreateManyUsersInputEnvelope = {
    data: CommentCreateManyUsersInput | CommentCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type RePostsCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string
    originalPosts: PostsCreateNestedOneWithoutRepostsInput
  }

  export type RePostsUncheckedCreateWithoutUsersInput = {
    id?: string
    originalPostsId: string
    createdAt?: Date | string
  }

  export type RePostsCreateOrConnectWithoutUsersInput = {
    where: RePostsWhereUniqueInput
    create: XOR<RePostsCreateWithoutUsersInput, RePostsUncheckedCreateWithoutUsersInput>
  }

  export type RePostsCreateManyUsersInputEnvelope = {
    data: RePostsCreateManyUsersInput | RePostsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUsersInput = {
    id?: string
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
    relatedUsers?: UsersCreateNestedOneWithoutRelatedNotificationsInput
    posts?: PostsCreateNestedOneWithoutNotificationsInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    story?: StoryCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUsersInput = {
    id?: string
    relatedUsersId?: string | null
    postsId?: string | null
    commentId?: string | null
    storyId?: string | null
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUsersInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUsersInput, NotificationUncheckedCreateWithoutUsersInput>
  }

  export type NotificationCreateManyUsersInputEnvelope = {
    data: NotificationCreateManyUsersInput | NotificationCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutRelatedUsersInput = {
    id?: string
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
    users: UsersCreateNestedOneWithoutNotificationsInput
    posts?: PostsCreateNestedOneWithoutNotificationsInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    story?: StoryCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutRelatedUsersInput = {
    id?: string
    usersId: string
    postsId?: string | null
    commentId?: string | null
    storyId?: string | null
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutRelatedUsersInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRelatedUsersInput, NotificationUncheckedCreateWithoutRelatedUsersInput>
  }

  export type NotificationCreateManyRelatedUsersInputEnvelope = {
    data: NotificationCreateManyRelatedUsersInput | NotificationCreateManyRelatedUsersInput[]
    skipDuplicates?: boolean
  }

  export type MessagesCreateWithoutSenderInput = {
    id?: string
    contentText?: string | null
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    readStatus?: boolean
    createdAt?: Date | string
    receiver: UsersCreateNestedOneWithoutMessagesReceivedInput
  }

  export type MessagesUncheckedCreateWithoutSenderInput = {
    id?: string
    receiverId: string
    contentText?: string | null
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type MessagesCreateOrConnectWithoutSenderInput = {
    where: MessagesWhereUniqueInput
    create: XOR<MessagesCreateWithoutSenderInput, MessagesUncheckedCreateWithoutSenderInput>
  }

  export type MessagesCreateManySenderInputEnvelope = {
    data: MessagesCreateManySenderInput | MessagesCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessagesCreateWithoutReceiverInput = {
    id?: string
    contentText?: string | null
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    readStatus?: boolean
    createdAt?: Date | string
    sender: UsersCreateNestedOneWithoutMessagesSentInput
  }

  export type MessagesUncheckedCreateWithoutReceiverInput = {
    id?: string
    senderId: string
    contentText?: string | null
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type MessagesCreateOrConnectWithoutReceiverInput = {
    where: MessagesWhereUniqueInput
    create: XOR<MessagesCreateWithoutReceiverInput, MessagesUncheckedCreateWithoutReceiverInput>
  }

  export type MessagesCreateManyReceiverInputEnvelope = {
    data: MessagesCreateManyReceiverInput | MessagesCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type FriendsCreateWithoutUsersInput = {
    id?: string
    friendStatus: $Enums.FriendStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    friend: UsersCreateNestedOneWithoutFriendOfInput
  }

  export type FriendsUncheckedCreateWithoutUsersInput = {
    id?: string
    friendId: string
    friendStatus: $Enums.FriendStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FriendsCreateOrConnectWithoutUsersInput = {
    where: FriendsWhereUniqueInput
    create: XOR<FriendsCreateWithoutUsersInput, FriendsUncheckedCreateWithoutUsersInput>
  }

  export type FriendsCreateManyUsersInputEnvelope = {
    data: FriendsCreateManyUsersInput | FriendsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type FriendsCreateWithoutFriendInput = {
    id?: string
    friendStatus: $Enums.FriendStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutFriendsInput
  }

  export type FriendsUncheckedCreateWithoutFriendInput = {
    id?: string
    usersId: string
    friendStatus: $Enums.FriendStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FriendsCreateOrConnectWithoutFriendInput = {
    where: FriendsWhereUniqueInput
    create: XOR<FriendsCreateWithoutFriendInput, FriendsUncheckedCreateWithoutFriendInput>
  }

  export type FriendsCreateManyFriendInputEnvelope = {
    data: FriendsCreateManyFriendInput | FriendsCreateManyFriendInput[]
    skipDuplicates?: boolean
  }

  export type FollowersCreateWithoutFollowerInput = {
    id?: string
    createdAt?: Date | string
    following: UsersCreateNestedOneWithoutFollowingInput
  }

  export type FollowersUncheckedCreateWithoutFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowersCreateOrConnectWithoutFollowerInput = {
    where: FollowersWhereUniqueInput
    create: XOR<FollowersCreateWithoutFollowerInput, FollowersUncheckedCreateWithoutFollowerInput>
  }

  export type FollowersCreateManyFollowerInputEnvelope = {
    data: FollowersCreateManyFollowerInput | FollowersCreateManyFollowerInput[]
    skipDuplicates?: boolean
  }

  export type FollowersCreateWithoutFollowingInput = {
    id?: string
    createdAt?: Date | string
    follower: UsersCreateNestedOneWithoutFollowersInput
  }

  export type FollowersUncheckedCreateWithoutFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type FollowersCreateOrConnectWithoutFollowingInput = {
    where: FollowersWhereUniqueInput
    create: XOR<FollowersCreateWithoutFollowingInput, FollowersUncheckedCreateWithoutFollowingInput>
  }

  export type FollowersCreateManyFollowingInputEnvelope = {
    data: FollowersCreateManyFollowingInput | FollowersCreateManyFollowingInput[]
    skipDuplicates?: boolean
  }

  export type StoryViewerCreateWithoutUsersInput = {
    id?: string
    readAt?: Date | string
    story: StoryCreateNestedOneWithoutViewersInput
  }

  export type StoryViewerUncheckedCreateWithoutUsersInput = {
    id?: string
    storyId: string
    readAt?: Date | string
  }

  export type StoryViewerCreateOrConnectWithoutUsersInput = {
    where: StoryViewerWhereUniqueInput
    create: XOR<StoryViewerCreateWithoutUsersInput, StoryViewerUncheckedCreateWithoutUsersInput>
  }

  export type StoryViewerCreateManyUsersInputEnvelope = {
    data: StoryViewerCreateManyUsersInput | StoryViewerCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type PostsViewerCreateWithoutUsersInput = {
    id?: string
    viewedAt?: Date | string
    posts: PostsCreateNestedOneWithoutViewersInput
  }

  export type PostsViewerUncheckedCreateWithoutUsersInput = {
    id?: string
    postsId: string
    viewedAt?: Date | string
  }

  export type PostsViewerCreateOrConnectWithoutUsersInput = {
    where: PostsViewerWhereUniqueInput
    create: XOR<PostsViewerCreateWithoutUsersInput, PostsViewerUncheckedCreateWithoutUsersInput>
  }

  export type PostsViewerCreateManyUsersInputEnvelope = {
    data: PostsViewerCreateManyUsersInput | PostsViewerCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type CommentViewerCreateWithoutUsersInput = {
    id?: string
    readAt?: Date | string
    comment: CommentCreateNestedOneWithoutViewersInput
  }

  export type CommentViewerUncheckedCreateWithoutUsersInput = {
    id?: string
    commentId: string
    readAt?: Date | string
  }

  export type CommentViewerCreateOrConnectWithoutUsersInput = {
    where: CommentViewerWhereUniqueInput
    create: XOR<CommentViewerCreateWithoutUsersInput, CommentViewerUncheckedCreateWithoutUsersInput>
  }

  export type CommentViewerCreateManyUsersInputEnvelope = {
    data: CommentViewerCreateManyUsersInput | CommentViewerCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type PostsUpsertWithWhereUniqueWithoutUsersInput = {
    where: PostsWhereUniqueInput
    update: XOR<PostsUpdateWithoutUsersInput, PostsUncheckedUpdateWithoutUsersInput>
    create: XOR<PostsCreateWithoutUsersInput, PostsUncheckedCreateWithoutUsersInput>
  }

  export type PostsUpdateWithWhereUniqueWithoutUsersInput = {
    where: PostsWhereUniqueInput
    data: XOR<PostsUpdateWithoutUsersInput, PostsUncheckedUpdateWithoutUsersInput>
  }

  export type PostsUpdateManyWithWhereWithoutUsersInput = {
    where: PostsScalarWhereInput
    data: XOR<PostsUpdateManyMutationInput, PostsUncheckedUpdateManyWithoutUsersInput>
  }

  export type PostsScalarWhereInput = {
    AND?: PostsScalarWhereInput | PostsScalarWhereInput[]
    OR?: PostsScalarWhereInput[]
    NOT?: PostsScalarWhereInput | PostsScalarWhereInput[]
    id?: StringFilter<"Posts"> | string
    usersId?: StringFilter<"Posts"> | string
    contentText?: StringNullableFilter<"Posts"> | string | null
    contentImage?: StringNullableFilter<"Posts"> | string | null
    mediaType?: EnumMediaTypeFilter<"Posts"> | $Enums.MediaType
    createdAt?: DateTimeFilter<"Posts"> | Date | string
    updatedAt?: DateTimeFilter<"Posts"> | Date | string
  }

  export type StoryUpsertWithWhereUniqueWithoutUsersInput = {
    where: StoryWhereUniqueInput
    update: XOR<StoryUpdateWithoutUsersInput, StoryUncheckedUpdateWithoutUsersInput>
    create: XOR<StoryCreateWithoutUsersInput, StoryUncheckedCreateWithoutUsersInput>
  }

  export type StoryUpdateWithWhereUniqueWithoutUsersInput = {
    where: StoryWhereUniqueInput
    data: XOR<StoryUpdateWithoutUsersInput, StoryUncheckedUpdateWithoutUsersInput>
  }

  export type StoryUpdateManyWithWhereWithoutUsersInput = {
    where: StoryScalarWhereInput
    data: XOR<StoryUpdateManyMutationInput, StoryUncheckedUpdateManyWithoutUsersInput>
  }

  export type StoryScalarWhereInput = {
    AND?: StoryScalarWhereInput | StoryScalarWhereInput[]
    OR?: StoryScalarWhereInput[]
    NOT?: StoryScalarWhereInput | StoryScalarWhereInput[]
    id?: StringFilter<"Story"> | string
    usersId?: StringFilter<"Story"> | string
    contentText?: StringNullableFilter<"Story"> | string | null
    contentMedia?: StringNullableFilter<"Story"> | string | null
    mediaType?: EnumMediaTypeFilter<"Story"> | $Enums.MediaType
    createdAt?: DateTimeFilter<"Story"> | Date | string
    expirationTime?: DateTimeFilter<"Story"> | Date | string
  }

  export type LikeUpsertWithWhereUniqueWithoutUsersInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutUsersInput, LikeUncheckedUpdateWithoutUsersInput>
    create: XOR<LikeCreateWithoutUsersInput, LikeUncheckedCreateWithoutUsersInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutUsersInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutUsersInput, LikeUncheckedUpdateWithoutUsersInput>
  }

  export type LikeUpdateManyWithWhereWithoutUsersInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutUsersInput>
  }

  export type LikeScalarWhereInput = {
    AND?: LikeScalarWhereInput | LikeScalarWhereInput[]
    OR?: LikeScalarWhereInput[]
    NOT?: LikeScalarWhereInput | LikeScalarWhereInput[]
    id?: StringFilter<"Like"> | string
    usersId?: StringFilter<"Like"> | string
    postsId?: StringNullableFilter<"Like"> | string | null
    storyId?: StringNullableFilter<"Like"> | string | null
    createdAt?: DateTimeFilter<"Like"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUsersInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUsersInput, CommentUncheckedUpdateWithoutUsersInput>
    create: XOR<CommentCreateWithoutUsersInput, CommentUncheckedCreateWithoutUsersInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUsersInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUsersInput, CommentUncheckedUpdateWithoutUsersInput>
  }

  export type CommentUpdateManyWithWhereWithoutUsersInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUsersInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    usersId?: StringFilter<"Comment"> | string
    postsId?: StringNullableFilter<"Comment"> | string | null
    storyId?: StringNullableFilter<"Comment"> | string | null
    content?: StringFilter<"Comment"> | string
    mediaUrl?: StringNullableFilter<"Comment"> | string | null
    mediaType?: EnumMediaTypeFilter<"Comment"> | $Enums.MediaType
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type RePostsUpsertWithWhereUniqueWithoutUsersInput = {
    where: RePostsWhereUniqueInput
    update: XOR<RePostsUpdateWithoutUsersInput, RePostsUncheckedUpdateWithoutUsersInput>
    create: XOR<RePostsCreateWithoutUsersInput, RePostsUncheckedCreateWithoutUsersInput>
  }

  export type RePostsUpdateWithWhereUniqueWithoutUsersInput = {
    where: RePostsWhereUniqueInput
    data: XOR<RePostsUpdateWithoutUsersInput, RePostsUncheckedUpdateWithoutUsersInput>
  }

  export type RePostsUpdateManyWithWhereWithoutUsersInput = {
    where: RePostsScalarWhereInput
    data: XOR<RePostsUpdateManyMutationInput, RePostsUncheckedUpdateManyWithoutUsersInput>
  }

  export type RePostsScalarWhereInput = {
    AND?: RePostsScalarWhereInput | RePostsScalarWhereInput[]
    OR?: RePostsScalarWhereInput[]
    NOT?: RePostsScalarWhereInput | RePostsScalarWhereInput[]
    id?: StringFilter<"RePosts"> | string
    usersId?: StringFilter<"RePosts"> | string
    originalPostsId?: StringFilter<"RePosts"> | string
    createdAt?: DateTimeFilter<"RePosts"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUsersInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUsersInput, NotificationUncheckedUpdateWithoutUsersInput>
    create: XOR<NotificationCreateWithoutUsersInput, NotificationUncheckedCreateWithoutUsersInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUsersInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUsersInput, NotificationUncheckedUpdateWithoutUsersInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUsersInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUsersInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    usersId?: StringFilter<"Notification"> | string
    relatedUsersId?: StringNullableFilter<"Notification"> | string | null
    postsId?: StringNullableFilter<"Notification"> | string | null
    commentId?: StringNullableFilter<"Notification"> | string | null
    storyId?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    readStatus?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutRelatedUsersInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRelatedUsersInput, NotificationUncheckedUpdateWithoutRelatedUsersInput>
    create: XOR<NotificationCreateWithoutRelatedUsersInput, NotificationUncheckedCreateWithoutRelatedUsersInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRelatedUsersInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRelatedUsersInput, NotificationUncheckedUpdateWithoutRelatedUsersInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRelatedUsersInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRelatedUsersInput>
  }

  export type MessagesUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessagesWhereUniqueInput
    update: XOR<MessagesUpdateWithoutSenderInput, MessagesUncheckedUpdateWithoutSenderInput>
    create: XOR<MessagesCreateWithoutSenderInput, MessagesUncheckedCreateWithoutSenderInput>
  }

  export type MessagesUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessagesWhereUniqueInput
    data: XOR<MessagesUpdateWithoutSenderInput, MessagesUncheckedUpdateWithoutSenderInput>
  }

  export type MessagesUpdateManyWithWhereWithoutSenderInput = {
    where: MessagesScalarWhereInput
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessagesScalarWhereInput = {
    AND?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
    OR?: MessagesScalarWhereInput[]
    NOT?: MessagesScalarWhereInput | MessagesScalarWhereInput[]
    id?: StringFilter<"Messages"> | string
    senderId?: StringFilter<"Messages"> | string
    receiverId?: StringFilter<"Messages"> | string
    contentText?: StringNullableFilter<"Messages"> | string | null
    mediaUrl?: StringNullableFilter<"Messages"> | string | null
    mediaType?: EnumMediaTypeFilter<"Messages"> | $Enums.MediaType
    readStatus?: BoolFilter<"Messages"> | boolean
    createdAt?: DateTimeFilter<"Messages"> | Date | string
  }

  export type MessagesUpsertWithWhereUniqueWithoutReceiverInput = {
    where: MessagesWhereUniqueInput
    update: XOR<MessagesUpdateWithoutReceiverInput, MessagesUncheckedUpdateWithoutReceiverInput>
    create: XOR<MessagesCreateWithoutReceiverInput, MessagesUncheckedCreateWithoutReceiverInput>
  }

  export type MessagesUpdateWithWhereUniqueWithoutReceiverInput = {
    where: MessagesWhereUniqueInput
    data: XOR<MessagesUpdateWithoutReceiverInput, MessagesUncheckedUpdateWithoutReceiverInput>
  }

  export type MessagesUpdateManyWithWhereWithoutReceiverInput = {
    where: MessagesScalarWhereInput
    data: XOR<MessagesUpdateManyMutationInput, MessagesUncheckedUpdateManyWithoutReceiverInput>
  }

  export type FriendsUpsertWithWhereUniqueWithoutUsersInput = {
    where: FriendsWhereUniqueInput
    update: XOR<FriendsUpdateWithoutUsersInput, FriendsUncheckedUpdateWithoutUsersInput>
    create: XOR<FriendsCreateWithoutUsersInput, FriendsUncheckedCreateWithoutUsersInput>
  }

  export type FriendsUpdateWithWhereUniqueWithoutUsersInput = {
    where: FriendsWhereUniqueInput
    data: XOR<FriendsUpdateWithoutUsersInput, FriendsUncheckedUpdateWithoutUsersInput>
  }

  export type FriendsUpdateManyWithWhereWithoutUsersInput = {
    where: FriendsScalarWhereInput
    data: XOR<FriendsUpdateManyMutationInput, FriendsUncheckedUpdateManyWithoutUsersInput>
  }

  export type FriendsScalarWhereInput = {
    AND?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
    OR?: FriendsScalarWhereInput[]
    NOT?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
    id?: StringFilter<"Friends"> | string
    usersId?: StringFilter<"Friends"> | string
    friendId?: StringFilter<"Friends"> | string
    friendStatus?: EnumFriendStatusFilter<"Friends"> | $Enums.FriendStatus
    createdAt?: DateTimeFilter<"Friends"> | Date | string
    updatedAt?: DateTimeFilter<"Friends"> | Date | string
  }

  export type FriendsUpsertWithWhereUniqueWithoutFriendInput = {
    where: FriendsWhereUniqueInput
    update: XOR<FriendsUpdateWithoutFriendInput, FriendsUncheckedUpdateWithoutFriendInput>
    create: XOR<FriendsCreateWithoutFriendInput, FriendsUncheckedCreateWithoutFriendInput>
  }

  export type FriendsUpdateWithWhereUniqueWithoutFriendInput = {
    where: FriendsWhereUniqueInput
    data: XOR<FriendsUpdateWithoutFriendInput, FriendsUncheckedUpdateWithoutFriendInput>
  }

  export type FriendsUpdateManyWithWhereWithoutFriendInput = {
    where: FriendsScalarWhereInput
    data: XOR<FriendsUpdateManyMutationInput, FriendsUncheckedUpdateManyWithoutFriendInput>
  }

  export type FollowersUpsertWithWhereUniqueWithoutFollowerInput = {
    where: FollowersWhereUniqueInput
    update: XOR<FollowersUpdateWithoutFollowerInput, FollowersUncheckedUpdateWithoutFollowerInput>
    create: XOR<FollowersCreateWithoutFollowerInput, FollowersUncheckedCreateWithoutFollowerInput>
  }

  export type FollowersUpdateWithWhereUniqueWithoutFollowerInput = {
    where: FollowersWhereUniqueInput
    data: XOR<FollowersUpdateWithoutFollowerInput, FollowersUncheckedUpdateWithoutFollowerInput>
  }

  export type FollowersUpdateManyWithWhereWithoutFollowerInput = {
    where: FollowersScalarWhereInput
    data: XOR<FollowersUpdateManyMutationInput, FollowersUncheckedUpdateManyWithoutFollowerInput>
  }

  export type FollowersScalarWhereInput = {
    AND?: FollowersScalarWhereInput | FollowersScalarWhereInput[]
    OR?: FollowersScalarWhereInput[]
    NOT?: FollowersScalarWhereInput | FollowersScalarWhereInput[]
    id?: StringFilter<"Followers"> | string
    followerId?: StringFilter<"Followers"> | string
    followingId?: StringFilter<"Followers"> | string
    createdAt?: DateTimeFilter<"Followers"> | Date | string
  }

  export type FollowersUpsertWithWhereUniqueWithoutFollowingInput = {
    where: FollowersWhereUniqueInput
    update: XOR<FollowersUpdateWithoutFollowingInput, FollowersUncheckedUpdateWithoutFollowingInput>
    create: XOR<FollowersCreateWithoutFollowingInput, FollowersUncheckedCreateWithoutFollowingInput>
  }

  export type FollowersUpdateWithWhereUniqueWithoutFollowingInput = {
    where: FollowersWhereUniqueInput
    data: XOR<FollowersUpdateWithoutFollowingInput, FollowersUncheckedUpdateWithoutFollowingInput>
  }

  export type FollowersUpdateManyWithWhereWithoutFollowingInput = {
    where: FollowersScalarWhereInput
    data: XOR<FollowersUpdateManyMutationInput, FollowersUncheckedUpdateManyWithoutFollowingInput>
  }

  export type StoryViewerUpsertWithWhereUniqueWithoutUsersInput = {
    where: StoryViewerWhereUniqueInput
    update: XOR<StoryViewerUpdateWithoutUsersInput, StoryViewerUncheckedUpdateWithoutUsersInput>
    create: XOR<StoryViewerCreateWithoutUsersInput, StoryViewerUncheckedCreateWithoutUsersInput>
  }

  export type StoryViewerUpdateWithWhereUniqueWithoutUsersInput = {
    where: StoryViewerWhereUniqueInput
    data: XOR<StoryViewerUpdateWithoutUsersInput, StoryViewerUncheckedUpdateWithoutUsersInput>
  }

  export type StoryViewerUpdateManyWithWhereWithoutUsersInput = {
    where: StoryViewerScalarWhereInput
    data: XOR<StoryViewerUpdateManyMutationInput, StoryViewerUncheckedUpdateManyWithoutUsersInput>
  }

  export type StoryViewerScalarWhereInput = {
    AND?: StoryViewerScalarWhereInput | StoryViewerScalarWhereInput[]
    OR?: StoryViewerScalarWhereInput[]
    NOT?: StoryViewerScalarWhereInput | StoryViewerScalarWhereInput[]
    id?: StringFilter<"StoryViewer"> | string
    storyId?: StringFilter<"StoryViewer"> | string
    usersId?: StringFilter<"StoryViewer"> | string
    readAt?: DateTimeFilter<"StoryViewer"> | Date | string
  }

  export type PostsViewerUpsertWithWhereUniqueWithoutUsersInput = {
    where: PostsViewerWhereUniqueInput
    update: XOR<PostsViewerUpdateWithoutUsersInput, PostsViewerUncheckedUpdateWithoutUsersInput>
    create: XOR<PostsViewerCreateWithoutUsersInput, PostsViewerUncheckedCreateWithoutUsersInput>
  }

  export type PostsViewerUpdateWithWhereUniqueWithoutUsersInput = {
    where: PostsViewerWhereUniqueInput
    data: XOR<PostsViewerUpdateWithoutUsersInput, PostsViewerUncheckedUpdateWithoutUsersInput>
  }

  export type PostsViewerUpdateManyWithWhereWithoutUsersInput = {
    where: PostsViewerScalarWhereInput
    data: XOR<PostsViewerUpdateManyMutationInput, PostsViewerUncheckedUpdateManyWithoutUsersInput>
  }

  export type PostsViewerScalarWhereInput = {
    AND?: PostsViewerScalarWhereInput | PostsViewerScalarWhereInput[]
    OR?: PostsViewerScalarWhereInput[]
    NOT?: PostsViewerScalarWhereInput | PostsViewerScalarWhereInput[]
    id?: StringFilter<"PostsViewer"> | string
    postsId?: StringFilter<"PostsViewer"> | string
    usersId?: StringFilter<"PostsViewer"> | string
    viewedAt?: DateTimeFilter<"PostsViewer"> | Date | string
  }

  export type CommentViewerUpsertWithWhereUniqueWithoutUsersInput = {
    where: CommentViewerWhereUniqueInput
    update: XOR<CommentViewerUpdateWithoutUsersInput, CommentViewerUncheckedUpdateWithoutUsersInput>
    create: XOR<CommentViewerCreateWithoutUsersInput, CommentViewerUncheckedCreateWithoutUsersInput>
  }

  export type CommentViewerUpdateWithWhereUniqueWithoutUsersInput = {
    where: CommentViewerWhereUniqueInput
    data: XOR<CommentViewerUpdateWithoutUsersInput, CommentViewerUncheckedUpdateWithoutUsersInput>
  }

  export type CommentViewerUpdateManyWithWhereWithoutUsersInput = {
    where: CommentViewerScalarWhereInput
    data: XOR<CommentViewerUpdateManyMutationInput, CommentViewerUncheckedUpdateManyWithoutUsersInput>
  }

  export type CommentViewerScalarWhereInput = {
    AND?: CommentViewerScalarWhereInput | CommentViewerScalarWhereInput[]
    OR?: CommentViewerScalarWhereInput[]
    NOT?: CommentViewerScalarWhereInput | CommentViewerScalarWhereInput[]
    id?: StringFilter<"CommentViewer"> | string
    commentId?: StringFilter<"CommentViewer"> | string
    usersId?: StringFilter<"CommentViewer"> | string
    readAt?: DateTimeFilter<"CommentViewer"> | Date | string
  }

  export type UsersCreateWithoutPostsInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stories?: StoryCreateNestedManyWithoutUsersInput
    likes?: LikeCreateNestedManyWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUsersInput
    reposts?: RePostsCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUsersInput
    friendOf?: FriendsCreateNestedManyWithoutFriendInput
    followers?: FollowersCreateNestedManyWithoutFollowerInput
    following?: FollowersCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutPostsInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stories?: StoryUncheckedCreateNestedManyWithoutUsersInput
    likes?: LikeUncheckedCreateNestedManyWithoutUsersInput
    comments?: CommentUncheckedCreateNestedManyWithoutUsersInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUsersInput
    friendOf?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    followers?: FollowersUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowersUncheckedCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerUncheckedCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerUncheckedCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutPostsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutPostsInput, UsersUncheckedCreateWithoutPostsInput>
  }

  export type CommentCreateWithoutPostsInput = {
    id?: string
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutCommentsInput
    story?: StoryCreateNestedOneWithoutCommentsInput
    viewers?: CommentViewerCreateNestedManyWithoutCommentInput
    attachments?: AttachmentCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutPostsInput = {
    id?: string
    usersId: string
    storyId?: string | null
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    viewers?: CommentViewerUncheckedCreateNestedManyWithoutCommentInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutPostsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostsInput, CommentUncheckedCreateWithoutPostsInput>
  }

  export type CommentCreateManyPostsInputEnvelope = {
    data: CommentCreateManyPostsInput | CommentCreateManyPostsInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutPostsInput = {
    id?: string
    createdAt?: Date | string
    users: UsersCreateNestedOneWithoutLikesInput
    story?: StoryCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutPostsInput = {
    id?: string
    usersId: string
    storyId?: string | null
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutPostsInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutPostsInput, LikeUncheckedCreateWithoutPostsInput>
  }

  export type LikeCreateManyPostsInputEnvelope = {
    data: LikeCreateManyPostsInput | LikeCreateManyPostsInput[]
    skipDuplicates?: boolean
  }

  export type RePostsCreateWithoutOriginalPostsInput = {
    id?: string
    createdAt?: Date | string
    users: UsersCreateNestedOneWithoutRepostsInput
  }

  export type RePostsUncheckedCreateWithoutOriginalPostsInput = {
    id?: string
    usersId: string
    createdAt?: Date | string
  }

  export type RePostsCreateOrConnectWithoutOriginalPostsInput = {
    where: RePostsWhereUniqueInput
    create: XOR<RePostsCreateWithoutOriginalPostsInput, RePostsUncheckedCreateWithoutOriginalPostsInput>
  }

  export type RePostsCreateManyOriginalPostsInputEnvelope = {
    data: RePostsCreateManyOriginalPostsInput | RePostsCreateManyOriginalPostsInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutPostsInput = {
    id?: string
    filePath: string
    fileType: $Enums.FileType
    createdAt?: Date | string
    comment?: CommentCreateNestedOneWithoutAttachmentsInput
    story?: StoryCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutPostsInput = {
    id?: string
    commentId?: string | null
    storyId?: string | null
    filePath: string
    fileType: $Enums.FileType
    createdAt?: Date | string
  }

  export type AttachmentCreateOrConnectWithoutPostsInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutPostsInput, AttachmentUncheckedCreateWithoutPostsInput>
  }

  export type AttachmentCreateManyPostsInputEnvelope = {
    data: AttachmentCreateManyPostsInput | AttachmentCreateManyPostsInput[]
    skipDuplicates?: boolean
  }

  export type PostsViewerCreateWithoutPostsInput = {
    id?: string
    viewedAt?: Date | string
    users: UsersCreateNestedOneWithoutPostViewersInput
  }

  export type PostsViewerUncheckedCreateWithoutPostsInput = {
    id?: string
    usersId: string
    viewedAt?: Date | string
  }

  export type PostsViewerCreateOrConnectWithoutPostsInput = {
    where: PostsViewerWhereUniqueInput
    create: XOR<PostsViewerCreateWithoutPostsInput, PostsViewerUncheckedCreateWithoutPostsInput>
  }

  export type PostsViewerCreateManyPostsInputEnvelope = {
    data: PostsViewerCreateManyPostsInput | PostsViewerCreateManyPostsInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutPostsInput = {
    id?: string
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
    users: UsersCreateNestedOneWithoutNotificationsInput
    relatedUsers?: UsersCreateNestedOneWithoutRelatedNotificationsInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    story?: StoryCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutPostsInput = {
    id?: string
    usersId: string
    relatedUsersId?: string | null
    commentId?: string | null
    storyId?: string | null
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutPostsInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutPostsInput, NotificationUncheckedCreateWithoutPostsInput>
  }

  export type NotificationCreateManyPostsInputEnvelope = {
    data: NotificationCreateManyPostsInput | NotificationCreateManyPostsInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutPostsInput = {
    update: XOR<UsersUpdateWithoutPostsInput, UsersUncheckedUpdateWithoutPostsInput>
    create: XOR<UsersCreateWithoutPostsInput, UsersUncheckedCreateWithoutPostsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutPostsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutPostsInput, UsersUncheckedUpdateWithoutPostsInput>
  }

  export type UsersUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUpdateManyWithoutUsersNestedInput
    likes?: LikeUpdateManyWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUpdateManyWithoutFriendNestedInput
    followers?: FollowersUpdateManyWithoutFollowerNestedInput
    following?: FollowersUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stories?: StoryUncheckedUpdateManyWithoutUsersNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUsersNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    followers?: FollowersUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowersUncheckedUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUncheckedUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUncheckedUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutPostsInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostsInput, CommentUncheckedUpdateWithoutPostsInput>
    create: XOR<CommentCreateWithoutPostsInput, CommentUncheckedCreateWithoutPostsInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostsInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostsInput, CommentUncheckedUpdateWithoutPostsInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostsInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostsInput>
  }

  export type LikeUpsertWithWhereUniqueWithoutPostsInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutPostsInput, LikeUncheckedUpdateWithoutPostsInput>
    create: XOR<LikeCreateWithoutPostsInput, LikeUncheckedCreateWithoutPostsInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutPostsInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutPostsInput, LikeUncheckedUpdateWithoutPostsInput>
  }

  export type LikeUpdateManyWithWhereWithoutPostsInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutPostsInput>
  }

  export type RePostsUpsertWithWhereUniqueWithoutOriginalPostsInput = {
    where: RePostsWhereUniqueInput
    update: XOR<RePostsUpdateWithoutOriginalPostsInput, RePostsUncheckedUpdateWithoutOriginalPostsInput>
    create: XOR<RePostsCreateWithoutOriginalPostsInput, RePostsUncheckedCreateWithoutOriginalPostsInput>
  }

  export type RePostsUpdateWithWhereUniqueWithoutOriginalPostsInput = {
    where: RePostsWhereUniqueInput
    data: XOR<RePostsUpdateWithoutOriginalPostsInput, RePostsUncheckedUpdateWithoutOriginalPostsInput>
  }

  export type RePostsUpdateManyWithWhereWithoutOriginalPostsInput = {
    where: RePostsScalarWhereInput
    data: XOR<RePostsUpdateManyMutationInput, RePostsUncheckedUpdateManyWithoutOriginalPostsInput>
  }

  export type AttachmentUpsertWithWhereUniqueWithoutPostsInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutPostsInput, AttachmentUncheckedUpdateWithoutPostsInput>
    create: XOR<AttachmentCreateWithoutPostsInput, AttachmentUncheckedCreateWithoutPostsInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutPostsInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutPostsInput, AttachmentUncheckedUpdateWithoutPostsInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutPostsInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutPostsInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: StringFilter<"Attachment"> | string
    postsId?: StringNullableFilter<"Attachment"> | string | null
    commentId?: StringNullableFilter<"Attachment"> | string | null
    storyId?: StringNullableFilter<"Attachment"> | string | null
    filePath?: StringFilter<"Attachment"> | string
    fileType?: EnumFileTypeFilter<"Attachment"> | $Enums.FileType
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
  }

  export type PostsViewerUpsertWithWhereUniqueWithoutPostsInput = {
    where: PostsViewerWhereUniqueInput
    update: XOR<PostsViewerUpdateWithoutPostsInput, PostsViewerUncheckedUpdateWithoutPostsInput>
    create: XOR<PostsViewerCreateWithoutPostsInput, PostsViewerUncheckedCreateWithoutPostsInput>
  }

  export type PostsViewerUpdateWithWhereUniqueWithoutPostsInput = {
    where: PostsViewerWhereUniqueInput
    data: XOR<PostsViewerUpdateWithoutPostsInput, PostsViewerUncheckedUpdateWithoutPostsInput>
  }

  export type PostsViewerUpdateManyWithWhereWithoutPostsInput = {
    where: PostsViewerScalarWhereInput
    data: XOR<PostsViewerUpdateManyMutationInput, PostsViewerUncheckedUpdateManyWithoutPostsInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutPostsInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutPostsInput, NotificationUncheckedUpdateWithoutPostsInput>
    create: XOR<NotificationCreateWithoutPostsInput, NotificationUncheckedCreateWithoutPostsInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutPostsInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutPostsInput, NotificationUncheckedUpdateWithoutPostsInput>
  }

  export type NotificationUpdateManyWithWhereWithoutPostsInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutPostsInput>
  }

  export type UsersCreateWithoutStoriesInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedManyWithoutUsersInput
    likes?: LikeCreateNestedManyWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUsersInput
    reposts?: RePostsCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUsersInput
    friendOf?: FriendsCreateNestedManyWithoutFriendInput
    followers?: FollowersCreateNestedManyWithoutFollowerInput
    following?: FollowersCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutStoriesInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUsersInput
    likes?: LikeUncheckedCreateNestedManyWithoutUsersInput
    comments?: CommentUncheckedCreateNestedManyWithoutUsersInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUsersInput
    friendOf?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    followers?: FollowersUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowersUncheckedCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerUncheckedCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerUncheckedCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutStoriesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutStoriesInput, UsersUncheckedCreateWithoutStoriesInput>
  }

  export type StoryViewerCreateWithoutStoryInput = {
    id?: string
    readAt?: Date | string
    users: UsersCreateNestedOneWithoutStoryViewersInput
  }

  export type StoryViewerUncheckedCreateWithoutStoryInput = {
    id?: string
    usersId: string
    readAt?: Date | string
  }

  export type StoryViewerCreateOrConnectWithoutStoryInput = {
    where: StoryViewerWhereUniqueInput
    create: XOR<StoryViewerCreateWithoutStoryInput, StoryViewerUncheckedCreateWithoutStoryInput>
  }

  export type StoryViewerCreateManyStoryInputEnvelope = {
    data: StoryViewerCreateManyStoryInput | StoryViewerCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutStoryInput = {
    id?: string
    createdAt?: Date | string
    users: UsersCreateNestedOneWithoutLikesInput
    posts?: PostsCreateNestedOneWithoutLikesInput
  }

  export type LikeUncheckedCreateWithoutStoryInput = {
    id?: string
    usersId: string
    postsId?: string | null
    createdAt?: Date | string
  }

  export type LikeCreateOrConnectWithoutStoryInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutStoryInput, LikeUncheckedCreateWithoutStoryInput>
  }

  export type LikeCreateManyStoryInputEnvelope = {
    data: LikeCreateManyStoryInput | LikeCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutStoryInput = {
    id?: string
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutCommentsInput
    posts?: PostsCreateNestedOneWithoutCommentsInput
    viewers?: CommentViewerCreateNestedManyWithoutCommentInput
    attachments?: AttachmentCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutStoryInput = {
    id?: string
    usersId: string
    postsId?: string | null
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    viewers?: CommentViewerUncheckedCreateNestedManyWithoutCommentInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutStoryInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutStoryInput, CommentUncheckedCreateWithoutStoryInput>
  }

  export type CommentCreateManyStoryInputEnvelope = {
    data: CommentCreateManyStoryInput | CommentCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutStoryInput = {
    id?: string
    filePath: string
    fileType: $Enums.FileType
    createdAt?: Date | string
    posts?: PostsCreateNestedOneWithoutAttachmentsInput
    comment?: CommentCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutStoryInput = {
    id?: string
    postsId?: string | null
    commentId?: string | null
    filePath: string
    fileType: $Enums.FileType
    createdAt?: Date | string
  }

  export type AttachmentCreateOrConnectWithoutStoryInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutStoryInput, AttachmentUncheckedCreateWithoutStoryInput>
  }

  export type AttachmentCreateManyStoryInputEnvelope = {
    data: AttachmentCreateManyStoryInput | AttachmentCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutStoryInput = {
    id?: string
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
    users: UsersCreateNestedOneWithoutNotificationsInput
    relatedUsers?: UsersCreateNestedOneWithoutRelatedNotificationsInput
    posts?: PostsCreateNestedOneWithoutNotificationsInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutStoryInput = {
    id?: string
    usersId: string
    relatedUsersId?: string | null
    postsId?: string | null
    commentId?: string | null
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutStoryInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutStoryInput, NotificationUncheckedCreateWithoutStoryInput>
  }

  export type NotificationCreateManyStoryInputEnvelope = {
    data: NotificationCreateManyStoryInput | NotificationCreateManyStoryInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutStoriesInput = {
    update: XOR<UsersUpdateWithoutStoriesInput, UsersUncheckedUpdateWithoutStoriesInput>
    create: XOR<UsersCreateWithoutStoriesInput, UsersUncheckedCreateWithoutStoriesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutStoriesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutStoriesInput, UsersUncheckedUpdateWithoutStoriesInput>
  }

  export type UsersUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUsersNestedInput
    likes?: LikeUpdateManyWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUpdateManyWithoutFriendNestedInput
    followers?: FollowersUpdateManyWithoutFollowerNestedInput
    following?: FollowersUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUsersNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUsersNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    followers?: FollowersUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowersUncheckedUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUncheckedUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUncheckedUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type StoryViewerUpsertWithWhereUniqueWithoutStoryInput = {
    where: StoryViewerWhereUniqueInput
    update: XOR<StoryViewerUpdateWithoutStoryInput, StoryViewerUncheckedUpdateWithoutStoryInput>
    create: XOR<StoryViewerCreateWithoutStoryInput, StoryViewerUncheckedCreateWithoutStoryInput>
  }

  export type StoryViewerUpdateWithWhereUniqueWithoutStoryInput = {
    where: StoryViewerWhereUniqueInput
    data: XOR<StoryViewerUpdateWithoutStoryInput, StoryViewerUncheckedUpdateWithoutStoryInput>
  }

  export type StoryViewerUpdateManyWithWhereWithoutStoryInput = {
    where: StoryViewerScalarWhereInput
    data: XOR<StoryViewerUpdateManyMutationInput, StoryViewerUncheckedUpdateManyWithoutStoryInput>
  }

  export type LikeUpsertWithWhereUniqueWithoutStoryInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutStoryInput, LikeUncheckedUpdateWithoutStoryInput>
    create: XOR<LikeCreateWithoutStoryInput, LikeUncheckedCreateWithoutStoryInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutStoryInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutStoryInput, LikeUncheckedUpdateWithoutStoryInput>
  }

  export type LikeUpdateManyWithWhereWithoutStoryInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutStoryInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutStoryInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutStoryInput, CommentUncheckedUpdateWithoutStoryInput>
    create: XOR<CommentCreateWithoutStoryInput, CommentUncheckedCreateWithoutStoryInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutStoryInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutStoryInput, CommentUncheckedUpdateWithoutStoryInput>
  }

  export type CommentUpdateManyWithWhereWithoutStoryInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutStoryInput>
  }

  export type AttachmentUpsertWithWhereUniqueWithoutStoryInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutStoryInput, AttachmentUncheckedUpdateWithoutStoryInput>
    create: XOR<AttachmentCreateWithoutStoryInput, AttachmentUncheckedCreateWithoutStoryInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutStoryInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutStoryInput, AttachmentUncheckedUpdateWithoutStoryInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutStoryInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutStoryInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutStoryInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutStoryInput, NotificationUncheckedUpdateWithoutStoryInput>
    create: XOR<NotificationCreateWithoutStoryInput, NotificationUncheckedCreateWithoutStoryInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutStoryInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutStoryInput, NotificationUncheckedUpdateWithoutStoryInput>
  }

  export type NotificationUpdateManyWithWhereWithoutStoryInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutStoryInput>
  }

  export type UsersCreateWithoutLikesInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedManyWithoutUsersInput
    stories?: StoryCreateNestedManyWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUsersInput
    reposts?: RePostsCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUsersInput
    friendOf?: FriendsCreateNestedManyWithoutFriendInput
    followers?: FollowersCreateNestedManyWithoutFollowerInput
    following?: FollowersCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutLikesInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUsersInput
    stories?: StoryUncheckedCreateNestedManyWithoutUsersInput
    comments?: CommentUncheckedCreateNestedManyWithoutUsersInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUsersInput
    friendOf?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    followers?: FollowersUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowersUncheckedCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerUncheckedCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerUncheckedCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutLikesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutLikesInput, UsersUncheckedCreateWithoutLikesInput>
  }

  export type PostsCreateWithoutLikesInput = {
    id?: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostsInput
    reposts?: RePostsCreateNestedManyWithoutOriginalPostsInput
    attachments?: AttachmentCreateNestedManyWithoutPostsInput
    viewers?: PostsViewerCreateNestedManyWithoutPostsInput
    notifications?: NotificationCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateWithoutLikesInput = {
    id?: string
    usersId: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostsInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutOriginalPostsInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutPostsInput
    viewers?: PostsViewerUncheckedCreateNestedManyWithoutPostsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsCreateOrConnectWithoutLikesInput = {
    where: PostsWhereUniqueInput
    create: XOR<PostsCreateWithoutLikesInput, PostsUncheckedCreateWithoutLikesInput>
  }

  export type StoryCreateWithoutLikesInput = {
    id?: string
    contentText?: string | null
    contentMedia?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    expirationTime: Date | string
    users: UsersCreateNestedOneWithoutStoriesInput
    viewers?: StoryViewerCreateNestedManyWithoutStoryInput
    comments?: CommentCreateNestedManyWithoutStoryInput
    attachments?: AttachmentCreateNestedManyWithoutStoryInput
    notifications?: NotificationCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutLikesInput = {
    id?: string
    usersId: string
    contentText?: string | null
    contentMedia?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    expirationTime: Date | string
    viewers?: StoryViewerUncheckedCreateNestedManyWithoutStoryInput
    comments?: CommentUncheckedCreateNestedManyWithoutStoryInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutStoryInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutLikesInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutLikesInput, StoryUncheckedCreateWithoutLikesInput>
  }

  export type UsersUpsertWithoutLikesInput = {
    update: XOR<UsersUpdateWithoutLikesInput, UsersUncheckedUpdateWithoutLikesInput>
    create: XOR<UsersCreateWithoutLikesInput, UsersUncheckedCreateWithoutLikesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutLikesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutLikesInput, UsersUncheckedUpdateWithoutLikesInput>
  }

  export type UsersUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUsersNestedInput
    stories?: StoryUpdateManyWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUpdateManyWithoutFriendNestedInput
    followers?: FollowersUpdateManyWithoutFollowerNestedInput
    following?: FollowersUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUsersNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUsersNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    followers?: FollowersUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowersUncheckedUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUncheckedUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUncheckedUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type PostsUpsertWithoutLikesInput = {
    update: XOR<PostsUpdateWithoutLikesInput, PostsUncheckedUpdateWithoutLikesInput>
    create: XOR<PostsCreateWithoutLikesInput, PostsUncheckedCreateWithoutLikesInput>
    where?: PostsWhereInput
  }

  export type PostsUpdateToOneWithWhereWithoutLikesInput = {
    where?: PostsWhereInput
    data: XOR<PostsUpdateWithoutLikesInput, PostsUncheckedUpdateWithoutLikesInput>
  }

  export type PostsUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostsNestedInput
    reposts?: RePostsUpdateManyWithoutOriginalPostsNestedInput
    attachments?: AttachmentUpdateManyWithoutPostsNestedInput
    viewers?: PostsViewerUpdateManyWithoutPostsNestedInput
    notifications?: NotificationUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostsNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutOriginalPostsNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutPostsNestedInput
    viewers?: PostsViewerUncheckedUpdateManyWithoutPostsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type StoryUpsertWithoutLikesInput = {
    update: XOR<StoryUpdateWithoutLikesInput, StoryUncheckedUpdateWithoutLikesInput>
    create: XOR<StoryCreateWithoutLikesInput, StoryUncheckedCreateWithoutLikesInput>
    where?: StoryWhereInput
  }

  export type StoryUpdateToOneWithWhereWithoutLikesInput = {
    where?: StoryWhereInput
    data: XOR<StoryUpdateWithoutLikesInput, StoryUncheckedUpdateWithoutLikesInput>
  }

  export type StoryUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutStoriesNestedInput
    viewers?: StoryViewerUpdateManyWithoutStoryNestedInput
    comments?: CommentUpdateManyWithoutStoryNestedInput
    attachments?: AttachmentUpdateManyWithoutStoryNestedInput
    notifications?: NotificationUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: StoryViewerUncheckedUpdateManyWithoutStoryNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStoryNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutStoryNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type UsersCreateWithoutCommentsInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedManyWithoutUsersInput
    stories?: StoryCreateNestedManyWithoutUsersInput
    likes?: LikeCreateNestedManyWithoutUsersInput
    reposts?: RePostsCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUsersInput
    friendOf?: FriendsCreateNestedManyWithoutFriendInput
    followers?: FollowersCreateNestedManyWithoutFollowerInput
    following?: FollowersCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutCommentsInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUsersInput
    stories?: StoryUncheckedCreateNestedManyWithoutUsersInput
    likes?: LikeUncheckedCreateNestedManyWithoutUsersInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUsersInput
    friendOf?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    followers?: FollowersUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowersUncheckedCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerUncheckedCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerUncheckedCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutCommentsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutCommentsInput, UsersUncheckedCreateWithoutCommentsInput>
  }

  export type PostsCreateWithoutCommentsInput = {
    id?: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutPostsInput
    likes?: LikeCreateNestedManyWithoutPostsInput
    reposts?: RePostsCreateNestedManyWithoutOriginalPostsInput
    attachments?: AttachmentCreateNestedManyWithoutPostsInput
    viewers?: PostsViewerCreateNestedManyWithoutPostsInput
    notifications?: NotificationCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateWithoutCommentsInput = {
    id?: string
    usersId: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: LikeUncheckedCreateNestedManyWithoutPostsInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutOriginalPostsInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutPostsInput
    viewers?: PostsViewerUncheckedCreateNestedManyWithoutPostsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsCreateOrConnectWithoutCommentsInput = {
    where: PostsWhereUniqueInput
    create: XOR<PostsCreateWithoutCommentsInput, PostsUncheckedCreateWithoutCommentsInput>
  }

  export type StoryCreateWithoutCommentsInput = {
    id?: string
    contentText?: string | null
    contentMedia?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    expirationTime: Date | string
    users: UsersCreateNestedOneWithoutStoriesInput
    viewers?: StoryViewerCreateNestedManyWithoutStoryInput
    likes?: LikeCreateNestedManyWithoutStoryInput
    attachments?: AttachmentCreateNestedManyWithoutStoryInput
    notifications?: NotificationCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutCommentsInput = {
    id?: string
    usersId: string
    contentText?: string | null
    contentMedia?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    expirationTime: Date | string
    viewers?: StoryViewerUncheckedCreateNestedManyWithoutStoryInput
    likes?: LikeUncheckedCreateNestedManyWithoutStoryInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutStoryInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutCommentsInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutCommentsInput, StoryUncheckedCreateWithoutCommentsInput>
  }

  export type CommentViewerCreateWithoutCommentInput = {
    id?: string
    readAt?: Date | string
    users: UsersCreateNestedOneWithoutCommentViewersInput
  }

  export type CommentViewerUncheckedCreateWithoutCommentInput = {
    id?: string
    usersId: string
    readAt?: Date | string
  }

  export type CommentViewerCreateOrConnectWithoutCommentInput = {
    where: CommentViewerWhereUniqueInput
    create: XOR<CommentViewerCreateWithoutCommentInput, CommentViewerUncheckedCreateWithoutCommentInput>
  }

  export type CommentViewerCreateManyCommentInputEnvelope = {
    data: CommentViewerCreateManyCommentInput | CommentViewerCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutCommentInput = {
    id?: string
    filePath: string
    fileType: $Enums.FileType
    createdAt?: Date | string
    posts?: PostsCreateNestedOneWithoutAttachmentsInput
    story?: StoryCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutCommentInput = {
    id?: string
    postsId?: string | null
    storyId?: string | null
    filePath: string
    fileType: $Enums.FileType
    createdAt?: Date | string
  }

  export type AttachmentCreateOrConnectWithoutCommentInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput>
  }

  export type AttachmentCreateManyCommentInputEnvelope = {
    data: AttachmentCreateManyCommentInput | AttachmentCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutCommentInput = {
    id?: string
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
    users: UsersCreateNestedOneWithoutNotificationsInput
    relatedUsers?: UsersCreateNestedOneWithoutRelatedNotificationsInput
    posts?: PostsCreateNestedOneWithoutNotificationsInput
    story?: StoryCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutCommentInput = {
    id?: string
    usersId: string
    relatedUsersId?: string | null
    postsId?: string | null
    storyId?: string | null
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutCommentInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput>
  }

  export type NotificationCreateManyCommentInputEnvelope = {
    data: NotificationCreateManyCommentInput | NotificationCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithoutCommentsInput = {
    update: XOR<UsersUpdateWithoutCommentsInput, UsersUncheckedUpdateWithoutCommentsInput>
    create: XOR<UsersCreateWithoutCommentsInput, UsersUncheckedCreateWithoutCommentsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutCommentsInput, UsersUncheckedUpdateWithoutCommentsInput>
  }

  export type UsersUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUsersNestedInput
    stories?: StoryUpdateManyWithoutUsersNestedInput
    likes?: LikeUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUpdateManyWithoutFriendNestedInput
    followers?: FollowersUpdateManyWithoutFollowerNestedInput
    following?: FollowersUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUsersNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUsersNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    followers?: FollowersUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowersUncheckedUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUncheckedUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUncheckedUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type PostsUpsertWithoutCommentsInput = {
    update: XOR<PostsUpdateWithoutCommentsInput, PostsUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostsCreateWithoutCommentsInput, PostsUncheckedCreateWithoutCommentsInput>
    where?: PostsWhereInput
  }

  export type PostsUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostsWhereInput
    data: XOR<PostsUpdateWithoutCommentsInput, PostsUncheckedUpdateWithoutCommentsInput>
  }

  export type PostsUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutPostsNestedInput
    likes?: LikeUpdateManyWithoutPostsNestedInput
    reposts?: RePostsUpdateManyWithoutOriginalPostsNestedInput
    attachments?: AttachmentUpdateManyWithoutPostsNestedInput
    viewers?: PostsViewerUpdateManyWithoutPostsNestedInput
    notifications?: NotificationUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUncheckedUpdateManyWithoutPostsNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutOriginalPostsNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutPostsNestedInput
    viewers?: PostsViewerUncheckedUpdateManyWithoutPostsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type StoryUpsertWithoutCommentsInput = {
    update: XOR<StoryUpdateWithoutCommentsInput, StoryUncheckedUpdateWithoutCommentsInput>
    create: XOR<StoryCreateWithoutCommentsInput, StoryUncheckedCreateWithoutCommentsInput>
    where?: StoryWhereInput
  }

  export type StoryUpdateToOneWithWhereWithoutCommentsInput = {
    where?: StoryWhereInput
    data: XOR<StoryUpdateWithoutCommentsInput, StoryUncheckedUpdateWithoutCommentsInput>
  }

  export type StoryUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutStoriesNestedInput
    viewers?: StoryViewerUpdateManyWithoutStoryNestedInput
    likes?: LikeUpdateManyWithoutStoryNestedInput
    attachments?: AttachmentUpdateManyWithoutStoryNestedInput
    notifications?: NotificationUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: StoryViewerUncheckedUpdateManyWithoutStoryNestedInput
    likes?: LikeUncheckedUpdateManyWithoutStoryNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutStoryNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type CommentViewerUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentViewerWhereUniqueInput
    update: XOR<CommentViewerUpdateWithoutCommentInput, CommentViewerUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentViewerCreateWithoutCommentInput, CommentViewerUncheckedCreateWithoutCommentInput>
  }

  export type CommentViewerUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentViewerWhereUniqueInput
    data: XOR<CommentViewerUpdateWithoutCommentInput, CommentViewerUncheckedUpdateWithoutCommentInput>
  }

  export type CommentViewerUpdateManyWithWhereWithoutCommentInput = {
    where: CommentViewerScalarWhereInput
    data: XOR<CommentViewerUpdateManyMutationInput, CommentViewerUncheckedUpdateManyWithoutCommentInput>
  }

  export type AttachmentUpsertWithWhereUniqueWithoutCommentInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutCommentInput, AttachmentUncheckedUpdateWithoutCommentInput>
    create: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutCommentInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutCommentInput, AttachmentUncheckedUpdateWithoutCommentInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutCommentInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutCommentInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutCommentInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutCommentInput, NotificationUncheckedUpdateWithoutCommentInput>
    create: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutCommentInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutCommentInput, NotificationUncheckedUpdateWithoutCommentInput>
  }

  export type NotificationUpdateManyWithWhereWithoutCommentInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutCommentInput>
  }

  export type UsersCreateWithoutRepostsInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedManyWithoutUsersInput
    stories?: StoryCreateNestedManyWithoutUsersInput
    likes?: LikeCreateNestedManyWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUsersInput
    friendOf?: FriendsCreateNestedManyWithoutFriendInput
    followers?: FollowersCreateNestedManyWithoutFollowerInput
    following?: FollowersCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutRepostsInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUsersInput
    stories?: StoryUncheckedCreateNestedManyWithoutUsersInput
    likes?: LikeUncheckedCreateNestedManyWithoutUsersInput
    comments?: CommentUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUsersInput
    friendOf?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    followers?: FollowersUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowersUncheckedCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerUncheckedCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerUncheckedCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutRepostsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutRepostsInput, UsersUncheckedCreateWithoutRepostsInput>
  }

  export type PostsCreateWithoutRepostsInput = {
    id?: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostsInput
    likes?: LikeCreateNestedManyWithoutPostsInput
    attachments?: AttachmentCreateNestedManyWithoutPostsInput
    viewers?: PostsViewerCreateNestedManyWithoutPostsInput
    notifications?: NotificationCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateWithoutRepostsInput = {
    id?: string
    usersId: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostsInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostsInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutPostsInput
    viewers?: PostsViewerUncheckedCreateNestedManyWithoutPostsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsCreateOrConnectWithoutRepostsInput = {
    where: PostsWhereUniqueInput
    create: XOR<PostsCreateWithoutRepostsInput, PostsUncheckedCreateWithoutRepostsInput>
  }

  export type UsersUpsertWithoutRepostsInput = {
    update: XOR<UsersUpdateWithoutRepostsInput, UsersUncheckedUpdateWithoutRepostsInput>
    create: XOR<UsersCreateWithoutRepostsInput, UsersUncheckedCreateWithoutRepostsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutRepostsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutRepostsInput, UsersUncheckedUpdateWithoutRepostsInput>
  }

  export type UsersUpdateWithoutRepostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUsersNestedInput
    stories?: StoryUpdateManyWithoutUsersNestedInput
    likes?: LikeUpdateManyWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUpdateManyWithoutFriendNestedInput
    followers?: FollowersUpdateManyWithoutFollowerNestedInput
    following?: FollowersUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutRepostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUsersNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUsersNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUsersNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    followers?: FollowersUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowersUncheckedUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUncheckedUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUncheckedUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type PostsUpsertWithoutRepostsInput = {
    update: XOR<PostsUpdateWithoutRepostsInput, PostsUncheckedUpdateWithoutRepostsInput>
    create: XOR<PostsCreateWithoutRepostsInput, PostsUncheckedCreateWithoutRepostsInput>
    where?: PostsWhereInput
  }

  export type PostsUpdateToOneWithWhereWithoutRepostsInput = {
    where?: PostsWhereInput
    data: XOR<PostsUpdateWithoutRepostsInput, PostsUncheckedUpdateWithoutRepostsInput>
  }

  export type PostsUpdateWithoutRepostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostsNestedInput
    likes?: LikeUpdateManyWithoutPostsNestedInput
    attachments?: AttachmentUpdateManyWithoutPostsNestedInput
    viewers?: PostsViewerUpdateManyWithoutPostsNestedInput
    notifications?: NotificationUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateWithoutRepostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostsNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostsNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutPostsNestedInput
    viewers?: PostsViewerUncheckedUpdateManyWithoutPostsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostsCreateWithoutAttachmentsInput = {
    id?: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostsInput
    likes?: LikeCreateNestedManyWithoutPostsInput
    reposts?: RePostsCreateNestedManyWithoutOriginalPostsInput
    viewers?: PostsViewerCreateNestedManyWithoutPostsInput
    notifications?: NotificationCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    usersId: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostsInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostsInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutOriginalPostsInput
    viewers?: PostsViewerUncheckedCreateNestedManyWithoutPostsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsCreateOrConnectWithoutAttachmentsInput = {
    where: PostsWhereUniqueInput
    create: XOR<PostsCreateWithoutAttachmentsInput, PostsUncheckedCreateWithoutAttachmentsInput>
  }

  export type CommentCreateWithoutAttachmentsInput = {
    id?: string
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutCommentsInput
    posts?: PostsCreateNestedOneWithoutCommentsInput
    story?: StoryCreateNestedOneWithoutCommentsInput
    viewers?: CommentViewerCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    usersId: string
    postsId?: string | null
    storyId?: string | null
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    viewers?: CommentViewerUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutAttachmentsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAttachmentsInput, CommentUncheckedCreateWithoutAttachmentsInput>
  }

  export type StoryCreateWithoutAttachmentsInput = {
    id?: string
    contentText?: string | null
    contentMedia?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    expirationTime: Date | string
    users: UsersCreateNestedOneWithoutStoriesInput
    viewers?: StoryViewerCreateNestedManyWithoutStoryInput
    likes?: LikeCreateNestedManyWithoutStoryInput
    comments?: CommentCreateNestedManyWithoutStoryInput
    notifications?: NotificationCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    usersId: string
    contentText?: string | null
    contentMedia?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    expirationTime: Date | string
    viewers?: StoryViewerUncheckedCreateNestedManyWithoutStoryInput
    likes?: LikeUncheckedCreateNestedManyWithoutStoryInput
    comments?: CommentUncheckedCreateNestedManyWithoutStoryInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutAttachmentsInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutAttachmentsInput, StoryUncheckedCreateWithoutAttachmentsInput>
  }

  export type PostsUpsertWithoutAttachmentsInput = {
    update: XOR<PostsUpdateWithoutAttachmentsInput, PostsUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<PostsCreateWithoutAttachmentsInput, PostsUncheckedCreateWithoutAttachmentsInput>
    where?: PostsWhereInput
  }

  export type PostsUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: PostsWhereInput
    data: XOR<PostsUpdateWithoutAttachmentsInput, PostsUncheckedUpdateWithoutAttachmentsInput>
  }

  export type PostsUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostsNestedInput
    likes?: LikeUpdateManyWithoutPostsNestedInput
    reposts?: RePostsUpdateManyWithoutOriginalPostsNestedInput
    viewers?: PostsViewerUpdateManyWithoutPostsNestedInput
    notifications?: NotificationUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostsNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostsNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutOriginalPostsNestedInput
    viewers?: PostsViewerUncheckedUpdateManyWithoutPostsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type CommentUpsertWithoutAttachmentsInput = {
    update: XOR<CommentUpdateWithoutAttachmentsInput, CommentUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<CommentCreateWithoutAttachmentsInput, CommentUncheckedCreateWithoutAttachmentsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutAttachmentsInput, CommentUncheckedUpdateWithoutAttachmentsInput>
  }

  export type CommentUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutCommentsNestedInput
    posts?: PostsUpdateOneWithoutCommentsNestedInput
    story?: StoryUpdateOneWithoutCommentsNestedInput
    viewers?: CommentViewerUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: CommentViewerUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type StoryUpsertWithoutAttachmentsInput = {
    update: XOR<StoryUpdateWithoutAttachmentsInput, StoryUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<StoryCreateWithoutAttachmentsInput, StoryUncheckedCreateWithoutAttachmentsInput>
    where?: StoryWhereInput
  }

  export type StoryUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: StoryWhereInput
    data: XOR<StoryUpdateWithoutAttachmentsInput, StoryUncheckedUpdateWithoutAttachmentsInput>
  }

  export type StoryUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutStoriesNestedInput
    viewers?: StoryViewerUpdateManyWithoutStoryNestedInput
    likes?: LikeUpdateManyWithoutStoryNestedInput
    comments?: CommentUpdateManyWithoutStoryNestedInput
    notifications?: NotificationUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: StoryViewerUncheckedUpdateManyWithoutStoryNestedInput
    likes?: LikeUncheckedUpdateManyWithoutStoryNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStoryNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type UsersCreateWithoutNotificationsInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedManyWithoutUsersInput
    stories?: StoryCreateNestedManyWithoutUsersInput
    likes?: LikeCreateNestedManyWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUsersInput
    reposts?: RePostsCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUsersInput
    friendOf?: FriendsCreateNestedManyWithoutFriendInput
    followers?: FollowersCreateNestedManyWithoutFollowerInput
    following?: FollowersCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutNotificationsInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUsersInput
    stories?: StoryUncheckedCreateNestedManyWithoutUsersInput
    likes?: LikeUncheckedCreateNestedManyWithoutUsersInput
    comments?: CommentUncheckedCreateNestedManyWithoutUsersInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUsersInput
    friendOf?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    followers?: FollowersUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowersUncheckedCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerUncheckedCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerUncheckedCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutNotificationsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutNotificationsInput, UsersUncheckedCreateWithoutNotificationsInput>
  }

  export type UsersCreateWithoutRelatedNotificationsInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedManyWithoutUsersInput
    stories?: StoryCreateNestedManyWithoutUsersInput
    likes?: LikeCreateNestedManyWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUsersInput
    reposts?: RePostsCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
    messagesSent?: MessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUsersInput
    friendOf?: FriendsCreateNestedManyWithoutFriendInput
    followers?: FollowersCreateNestedManyWithoutFollowerInput
    following?: FollowersCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutRelatedNotificationsInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUsersInput
    stories?: StoryUncheckedCreateNestedManyWithoutUsersInput
    likes?: LikeUncheckedCreateNestedManyWithoutUsersInput
    comments?: CommentUncheckedCreateNestedManyWithoutUsersInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
    messagesSent?: MessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUsersInput
    friendOf?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    followers?: FollowersUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowersUncheckedCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerUncheckedCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerUncheckedCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutRelatedNotificationsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutRelatedNotificationsInput, UsersUncheckedCreateWithoutRelatedNotificationsInput>
  }

  export type PostsCreateWithoutNotificationsInput = {
    id?: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostsInput
    likes?: LikeCreateNestedManyWithoutPostsInput
    reposts?: RePostsCreateNestedManyWithoutOriginalPostsInput
    attachments?: AttachmentCreateNestedManyWithoutPostsInput
    viewers?: PostsViewerCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateWithoutNotificationsInput = {
    id?: string
    usersId: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostsInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostsInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutOriginalPostsInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutPostsInput
    viewers?: PostsViewerUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsCreateOrConnectWithoutNotificationsInput = {
    where: PostsWhereUniqueInput
    create: XOR<PostsCreateWithoutNotificationsInput, PostsUncheckedCreateWithoutNotificationsInput>
  }

  export type CommentCreateWithoutNotificationsInput = {
    id?: string
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutCommentsInput
    posts?: PostsCreateNestedOneWithoutCommentsInput
    story?: StoryCreateNestedOneWithoutCommentsInput
    viewers?: CommentViewerCreateNestedManyWithoutCommentInput
    attachments?: AttachmentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutNotificationsInput = {
    id?: string
    usersId: string
    postsId?: string | null
    storyId?: string | null
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    viewers?: CommentViewerUncheckedCreateNestedManyWithoutCommentInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutNotificationsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutNotificationsInput, CommentUncheckedCreateWithoutNotificationsInput>
  }

  export type StoryCreateWithoutNotificationsInput = {
    id?: string
    contentText?: string | null
    contentMedia?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    expirationTime: Date | string
    users: UsersCreateNestedOneWithoutStoriesInput
    viewers?: StoryViewerCreateNestedManyWithoutStoryInput
    likes?: LikeCreateNestedManyWithoutStoryInput
    comments?: CommentCreateNestedManyWithoutStoryInput
    attachments?: AttachmentCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutNotificationsInput = {
    id?: string
    usersId: string
    contentText?: string | null
    contentMedia?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    expirationTime: Date | string
    viewers?: StoryViewerUncheckedCreateNestedManyWithoutStoryInput
    likes?: LikeUncheckedCreateNestedManyWithoutStoryInput
    comments?: CommentUncheckedCreateNestedManyWithoutStoryInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutNotificationsInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutNotificationsInput, StoryUncheckedCreateWithoutNotificationsInput>
  }

  export type UsersUpsertWithoutNotificationsInput = {
    update: XOR<UsersUpdateWithoutNotificationsInput, UsersUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UsersCreateWithoutNotificationsInput, UsersUncheckedCreateWithoutNotificationsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutNotificationsInput, UsersUncheckedUpdateWithoutNotificationsInput>
  }

  export type UsersUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUsersNestedInput
    stories?: StoryUpdateManyWithoutUsersNestedInput
    likes?: LikeUpdateManyWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUpdateManyWithoutFriendNestedInput
    followers?: FollowersUpdateManyWithoutFollowerNestedInput
    following?: FollowersUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUsersNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUsersNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUsersNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    followers?: FollowersUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowersUncheckedUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUncheckedUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUncheckedUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersUpsertWithoutRelatedNotificationsInput = {
    update: XOR<UsersUpdateWithoutRelatedNotificationsInput, UsersUncheckedUpdateWithoutRelatedNotificationsInput>
    create: XOR<UsersCreateWithoutRelatedNotificationsInput, UsersUncheckedCreateWithoutRelatedNotificationsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutRelatedNotificationsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutRelatedNotificationsInput, UsersUncheckedUpdateWithoutRelatedNotificationsInput>
  }

  export type UsersUpdateWithoutRelatedNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUsersNestedInput
    stories?: StoryUpdateManyWithoutUsersNestedInput
    likes?: LikeUpdateManyWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
    messagesSent?: MessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUpdateManyWithoutFriendNestedInput
    followers?: FollowersUpdateManyWithoutFollowerNestedInput
    following?: FollowersUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutRelatedNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUsersNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUsersNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUsersNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
    messagesSent?: MessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    followers?: FollowersUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowersUncheckedUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUncheckedUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUncheckedUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type PostsUpsertWithoutNotificationsInput = {
    update: XOR<PostsUpdateWithoutNotificationsInput, PostsUncheckedUpdateWithoutNotificationsInput>
    create: XOR<PostsCreateWithoutNotificationsInput, PostsUncheckedCreateWithoutNotificationsInput>
    where?: PostsWhereInput
  }

  export type PostsUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: PostsWhereInput
    data: XOR<PostsUpdateWithoutNotificationsInput, PostsUncheckedUpdateWithoutNotificationsInput>
  }

  export type PostsUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostsNestedInput
    likes?: LikeUpdateManyWithoutPostsNestedInput
    reposts?: RePostsUpdateManyWithoutOriginalPostsNestedInput
    attachments?: AttachmentUpdateManyWithoutPostsNestedInput
    viewers?: PostsViewerUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostsNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostsNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutOriginalPostsNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutPostsNestedInput
    viewers?: PostsViewerUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type CommentUpsertWithoutNotificationsInput = {
    update: XOR<CommentUpdateWithoutNotificationsInput, CommentUncheckedUpdateWithoutNotificationsInput>
    create: XOR<CommentCreateWithoutNotificationsInput, CommentUncheckedCreateWithoutNotificationsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutNotificationsInput, CommentUncheckedUpdateWithoutNotificationsInput>
  }

  export type CommentUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutCommentsNestedInput
    posts?: PostsUpdateOneWithoutCommentsNestedInput
    story?: StoryUpdateOneWithoutCommentsNestedInput
    viewers?: CommentViewerUpdateManyWithoutCommentNestedInput
    attachments?: AttachmentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: CommentViewerUncheckedUpdateManyWithoutCommentNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type StoryUpsertWithoutNotificationsInput = {
    update: XOR<StoryUpdateWithoutNotificationsInput, StoryUncheckedUpdateWithoutNotificationsInput>
    create: XOR<StoryCreateWithoutNotificationsInput, StoryUncheckedCreateWithoutNotificationsInput>
    where?: StoryWhereInput
  }

  export type StoryUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: StoryWhereInput
    data: XOR<StoryUpdateWithoutNotificationsInput, StoryUncheckedUpdateWithoutNotificationsInput>
  }

  export type StoryUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutStoriesNestedInput
    viewers?: StoryViewerUpdateManyWithoutStoryNestedInput
    likes?: LikeUpdateManyWithoutStoryNestedInput
    comments?: CommentUpdateManyWithoutStoryNestedInput
    attachments?: AttachmentUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: StoryViewerUncheckedUpdateManyWithoutStoryNestedInput
    likes?: LikeUncheckedUpdateManyWithoutStoryNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStoryNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type UsersCreateWithoutMessagesSentInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedManyWithoutUsersInput
    stories?: StoryCreateNestedManyWithoutUsersInput
    likes?: LikeCreateNestedManyWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUsersInput
    reposts?: RePostsCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationCreateNestedManyWithoutRelatedUsersInput
    messagesReceived?: MessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUsersInput
    friendOf?: FriendsCreateNestedManyWithoutFriendInput
    followers?: FollowersCreateNestedManyWithoutFollowerInput
    following?: FollowersCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutMessagesSentInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUsersInput
    stories?: StoryUncheckedCreateNestedManyWithoutUsersInput
    likes?: LikeUncheckedCreateNestedManyWithoutUsersInput
    comments?: CommentUncheckedCreateNestedManyWithoutUsersInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput
    messagesReceived?: MessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUsersInput
    friendOf?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    followers?: FollowersUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowersUncheckedCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerUncheckedCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerUncheckedCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutMessagesSentInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMessagesSentInput, UsersUncheckedCreateWithoutMessagesSentInput>
  }

  export type UsersCreateWithoutMessagesReceivedInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedManyWithoutUsersInput
    stories?: StoryCreateNestedManyWithoutUsersInput
    likes?: LikeCreateNestedManyWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUsersInput
    reposts?: RePostsCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesCreateNestedManyWithoutSenderInput
    friends?: FriendsCreateNestedManyWithoutUsersInput
    friendOf?: FriendsCreateNestedManyWithoutFriendInput
    followers?: FollowersCreateNestedManyWithoutFollowerInput
    following?: FollowersCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutMessagesReceivedInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUsersInput
    stories?: StoryUncheckedCreateNestedManyWithoutUsersInput
    likes?: LikeUncheckedCreateNestedManyWithoutUsersInput
    comments?: CommentUncheckedCreateNestedManyWithoutUsersInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesUncheckedCreateNestedManyWithoutSenderInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUsersInput
    friendOf?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    followers?: FollowersUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowersUncheckedCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerUncheckedCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerUncheckedCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutMessagesReceivedInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMessagesReceivedInput, UsersUncheckedCreateWithoutMessagesReceivedInput>
  }

  export type UsersUpsertWithoutMessagesSentInput = {
    update: XOR<UsersUpdateWithoutMessagesSentInput, UsersUncheckedUpdateWithoutMessagesSentInput>
    create: XOR<UsersCreateWithoutMessagesSentInput, UsersUncheckedCreateWithoutMessagesSentInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutMessagesSentInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutMessagesSentInput, UsersUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UsersUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUsersNestedInput
    stories?: StoryUpdateManyWithoutUsersNestedInput
    likes?: LikeUpdateManyWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUpdateManyWithoutRelatedUsersNestedInput
    messagesReceived?: MessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUpdateManyWithoutFriendNestedInput
    followers?: FollowersUpdateManyWithoutFollowerNestedInput
    following?: FollowersUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutMessagesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUsersNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUsersNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUsersNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput
    messagesReceived?: MessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    followers?: FollowersUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowersUncheckedUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUncheckedUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUncheckedUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersUpsertWithoutMessagesReceivedInput = {
    update: XOR<UsersUpdateWithoutMessagesReceivedInput, UsersUncheckedUpdateWithoutMessagesReceivedInput>
    create: XOR<UsersCreateWithoutMessagesReceivedInput, UsersUncheckedCreateWithoutMessagesReceivedInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutMessagesReceivedInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutMessagesReceivedInput, UsersUncheckedUpdateWithoutMessagesReceivedInput>
  }

  export type UsersUpdateWithoutMessagesReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUsersNestedInput
    stories?: StoryUpdateManyWithoutUsersNestedInput
    likes?: LikeUpdateManyWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUpdateManyWithoutSenderNestedInput
    friends?: FriendsUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUpdateManyWithoutFriendNestedInput
    followers?: FollowersUpdateManyWithoutFollowerNestedInput
    following?: FollowersUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutMessagesReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUsersNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUsersNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUsersNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUncheckedUpdateManyWithoutSenderNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    followers?: FollowersUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowersUncheckedUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUncheckedUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUncheckedUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateWithoutFriendsInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedManyWithoutUsersInput
    stories?: StoryCreateNestedManyWithoutUsersInput
    likes?: LikeCreateNestedManyWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUsersInput
    reposts?: RePostsCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesCreateNestedManyWithoutReceiverInput
    friendOf?: FriendsCreateNestedManyWithoutFriendInput
    followers?: FollowersCreateNestedManyWithoutFollowerInput
    following?: FollowersCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutFriendsInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUsersInput
    stories?: StoryUncheckedCreateNestedManyWithoutUsersInput
    likes?: LikeUncheckedCreateNestedManyWithoutUsersInput
    comments?: CommentUncheckedCreateNestedManyWithoutUsersInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesUncheckedCreateNestedManyWithoutReceiverInput
    friendOf?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    followers?: FollowersUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowersUncheckedCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerUncheckedCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerUncheckedCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutFriendsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFriendsInput, UsersUncheckedCreateWithoutFriendsInput>
  }

  export type UsersCreateWithoutFriendOfInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedManyWithoutUsersInput
    stories?: StoryCreateNestedManyWithoutUsersInput
    likes?: LikeCreateNestedManyWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUsersInput
    reposts?: RePostsCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUsersInput
    followers?: FollowersCreateNestedManyWithoutFollowerInput
    following?: FollowersCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutFriendOfInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUsersInput
    stories?: StoryUncheckedCreateNestedManyWithoutUsersInput
    likes?: LikeUncheckedCreateNestedManyWithoutUsersInput
    comments?: CommentUncheckedCreateNestedManyWithoutUsersInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUsersInput
    followers?: FollowersUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowersUncheckedCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerUncheckedCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerUncheckedCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutFriendOfInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFriendOfInput, UsersUncheckedCreateWithoutFriendOfInput>
  }

  export type UsersUpsertWithoutFriendsInput = {
    update: XOR<UsersUpdateWithoutFriendsInput, UsersUncheckedUpdateWithoutFriendsInput>
    create: XOR<UsersCreateWithoutFriendsInput, UsersUncheckedCreateWithoutFriendsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFriendsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFriendsInput, UsersUncheckedUpdateWithoutFriendsInput>
  }

  export type UsersUpdateWithoutFriendsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUsersNestedInput
    stories?: StoryUpdateManyWithoutUsersNestedInput
    likes?: LikeUpdateManyWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUpdateManyWithoutReceiverNestedInput
    friendOf?: FriendsUpdateManyWithoutFriendNestedInput
    followers?: FollowersUpdateManyWithoutFollowerNestedInput
    following?: FollowersUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutFriendsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUsersNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUsersNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUsersNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friendOf?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    followers?: FollowersUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowersUncheckedUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUncheckedUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUncheckedUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersUpsertWithoutFriendOfInput = {
    update: XOR<UsersUpdateWithoutFriendOfInput, UsersUncheckedUpdateWithoutFriendOfInput>
    create: XOR<UsersCreateWithoutFriendOfInput, UsersUncheckedCreateWithoutFriendOfInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFriendOfInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFriendOfInput, UsersUncheckedUpdateWithoutFriendOfInput>
  }

  export type UsersUpdateWithoutFriendOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUsersNestedInput
    stories?: StoryUpdateManyWithoutUsersNestedInput
    likes?: LikeUpdateManyWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUsersNestedInput
    followers?: FollowersUpdateManyWithoutFollowerNestedInput
    following?: FollowersUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutFriendOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUsersNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUsersNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUsersNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUsersNestedInput
    followers?: FollowersUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowersUncheckedUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUncheckedUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUncheckedUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateWithoutFollowersInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedManyWithoutUsersInput
    stories?: StoryCreateNestedManyWithoutUsersInput
    likes?: LikeCreateNestedManyWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUsersInput
    reposts?: RePostsCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUsersInput
    friendOf?: FriendsCreateNestedManyWithoutFriendInput
    following?: FollowersCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutFollowersInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUsersInput
    stories?: StoryUncheckedCreateNestedManyWithoutUsersInput
    likes?: LikeUncheckedCreateNestedManyWithoutUsersInput
    comments?: CommentUncheckedCreateNestedManyWithoutUsersInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUsersInput
    friendOf?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    following?: FollowersUncheckedCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerUncheckedCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerUncheckedCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutFollowersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFollowersInput, UsersUncheckedCreateWithoutFollowersInput>
  }

  export type UsersCreateWithoutFollowingInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedManyWithoutUsersInput
    stories?: StoryCreateNestedManyWithoutUsersInput
    likes?: LikeCreateNestedManyWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUsersInput
    reposts?: RePostsCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUsersInput
    friendOf?: FriendsCreateNestedManyWithoutFriendInput
    followers?: FollowersCreateNestedManyWithoutFollowerInput
    storyViewers?: StoryViewerCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutFollowingInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUsersInput
    stories?: StoryUncheckedCreateNestedManyWithoutUsersInput
    likes?: LikeUncheckedCreateNestedManyWithoutUsersInput
    comments?: CommentUncheckedCreateNestedManyWithoutUsersInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUsersInput
    friendOf?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    followers?: FollowersUncheckedCreateNestedManyWithoutFollowerInput
    storyViewers?: StoryViewerUncheckedCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerUncheckedCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutFollowingInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFollowingInput, UsersUncheckedCreateWithoutFollowingInput>
  }

  export type UsersUpsertWithoutFollowersInput = {
    update: XOR<UsersUpdateWithoutFollowersInput, UsersUncheckedUpdateWithoutFollowersInput>
    create: XOR<UsersCreateWithoutFollowersInput, UsersUncheckedCreateWithoutFollowersInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFollowersInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFollowersInput, UsersUncheckedUpdateWithoutFollowersInput>
  }

  export type UsersUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUsersNestedInput
    stories?: StoryUpdateManyWithoutUsersNestedInput
    likes?: LikeUpdateManyWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUpdateManyWithoutFriendNestedInput
    following?: FollowersUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUsersNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUsersNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUsersNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    following?: FollowersUncheckedUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUncheckedUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUncheckedUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersUpsertWithoutFollowingInput = {
    update: XOR<UsersUpdateWithoutFollowingInput, UsersUncheckedUpdateWithoutFollowingInput>
    create: XOR<UsersCreateWithoutFollowingInput, UsersUncheckedCreateWithoutFollowingInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFollowingInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFollowingInput, UsersUncheckedUpdateWithoutFollowingInput>
  }

  export type UsersUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUsersNestedInput
    stories?: StoryUpdateManyWithoutUsersNestedInput
    likes?: LikeUpdateManyWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUpdateManyWithoutFriendNestedInput
    followers?: FollowersUpdateManyWithoutFollowerNestedInput
    storyViewers?: StoryViewerUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUsersNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUsersNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUsersNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    followers?: FollowersUncheckedUpdateManyWithoutFollowerNestedInput
    storyViewers?: StoryViewerUncheckedUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUncheckedUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type StoryCreateWithoutViewersInput = {
    id?: string
    contentText?: string | null
    contentMedia?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    expirationTime: Date | string
    users: UsersCreateNestedOneWithoutStoriesInput
    likes?: LikeCreateNestedManyWithoutStoryInput
    comments?: CommentCreateNestedManyWithoutStoryInput
    attachments?: AttachmentCreateNestedManyWithoutStoryInput
    notifications?: NotificationCreateNestedManyWithoutStoryInput
  }

  export type StoryUncheckedCreateWithoutViewersInput = {
    id?: string
    usersId: string
    contentText?: string | null
    contentMedia?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    expirationTime: Date | string
    likes?: LikeUncheckedCreateNestedManyWithoutStoryInput
    comments?: CommentUncheckedCreateNestedManyWithoutStoryInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutStoryInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStoryInput
  }

  export type StoryCreateOrConnectWithoutViewersInput = {
    where: StoryWhereUniqueInput
    create: XOR<StoryCreateWithoutViewersInput, StoryUncheckedCreateWithoutViewersInput>
  }

  export type UsersCreateWithoutStoryViewersInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedManyWithoutUsersInput
    stories?: StoryCreateNestedManyWithoutUsersInput
    likes?: LikeCreateNestedManyWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUsersInput
    reposts?: RePostsCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUsersInput
    friendOf?: FriendsCreateNestedManyWithoutFriendInput
    followers?: FollowersCreateNestedManyWithoutFollowerInput
    following?: FollowersCreateNestedManyWithoutFollowingInput
    postViewers?: PostsViewerCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutStoryViewersInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUsersInput
    stories?: StoryUncheckedCreateNestedManyWithoutUsersInput
    likes?: LikeUncheckedCreateNestedManyWithoutUsersInput
    comments?: CommentUncheckedCreateNestedManyWithoutUsersInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUsersInput
    friendOf?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    followers?: FollowersUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowersUncheckedCreateNestedManyWithoutFollowingInput
    postViewers?: PostsViewerUncheckedCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutStoryViewersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutStoryViewersInput, UsersUncheckedCreateWithoutStoryViewersInput>
  }

  export type StoryUpsertWithoutViewersInput = {
    update: XOR<StoryUpdateWithoutViewersInput, StoryUncheckedUpdateWithoutViewersInput>
    create: XOR<StoryCreateWithoutViewersInput, StoryUncheckedCreateWithoutViewersInput>
    where?: StoryWhereInput
  }

  export type StoryUpdateToOneWithWhereWithoutViewersInput = {
    where?: StoryWhereInput
    data: XOR<StoryUpdateWithoutViewersInput, StoryUncheckedUpdateWithoutViewersInput>
  }

  export type StoryUpdateWithoutViewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutStoriesNestedInput
    likes?: LikeUpdateManyWithoutStoryNestedInput
    comments?: CommentUpdateManyWithoutStoryNestedInput
    attachments?: AttachmentUpdateManyWithoutStoryNestedInput
    notifications?: NotificationUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutViewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: LikeUncheckedUpdateManyWithoutStoryNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStoryNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutStoryNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type UsersUpsertWithoutStoryViewersInput = {
    update: XOR<UsersUpdateWithoutStoryViewersInput, UsersUncheckedUpdateWithoutStoryViewersInput>
    create: XOR<UsersCreateWithoutStoryViewersInput, UsersUncheckedCreateWithoutStoryViewersInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutStoryViewersInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutStoryViewersInput, UsersUncheckedUpdateWithoutStoryViewersInput>
  }

  export type UsersUpdateWithoutStoryViewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUsersNestedInput
    stories?: StoryUpdateManyWithoutUsersNestedInput
    likes?: LikeUpdateManyWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUpdateManyWithoutFriendNestedInput
    followers?: FollowersUpdateManyWithoutFollowerNestedInput
    following?: FollowersUpdateManyWithoutFollowingNestedInput
    postViewers?: PostsViewerUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutStoryViewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUsersNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUsersNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUsersNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    followers?: FollowersUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowersUncheckedUpdateManyWithoutFollowingNestedInput
    postViewers?: PostsViewerUncheckedUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type PostsCreateWithoutViewersInput = {
    id?: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostsInput
    likes?: LikeCreateNestedManyWithoutPostsInput
    reposts?: RePostsCreateNestedManyWithoutOriginalPostsInput
    attachments?: AttachmentCreateNestedManyWithoutPostsInput
    notifications?: NotificationCreateNestedManyWithoutPostsInput
  }

  export type PostsUncheckedCreateWithoutViewersInput = {
    id?: string
    usersId: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostsInput
    likes?: LikeUncheckedCreateNestedManyWithoutPostsInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutOriginalPostsInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutPostsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostsCreateOrConnectWithoutViewersInput = {
    where: PostsWhereUniqueInput
    create: XOR<PostsCreateWithoutViewersInput, PostsUncheckedCreateWithoutViewersInput>
  }

  export type UsersCreateWithoutPostViewersInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedManyWithoutUsersInput
    stories?: StoryCreateNestedManyWithoutUsersInput
    likes?: LikeCreateNestedManyWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUsersInput
    reposts?: RePostsCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUsersInput
    friendOf?: FriendsCreateNestedManyWithoutFriendInput
    followers?: FollowersCreateNestedManyWithoutFollowerInput
    following?: FollowersCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutPostViewersInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUsersInput
    stories?: StoryUncheckedCreateNestedManyWithoutUsersInput
    likes?: LikeUncheckedCreateNestedManyWithoutUsersInput
    comments?: CommentUncheckedCreateNestedManyWithoutUsersInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUsersInput
    friendOf?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    followers?: FollowersUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowersUncheckedCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerUncheckedCreateNestedManyWithoutUsersInput
    commentViewers?: CommentViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutPostViewersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutPostViewersInput, UsersUncheckedCreateWithoutPostViewersInput>
  }

  export type PostsUpsertWithoutViewersInput = {
    update: XOR<PostsUpdateWithoutViewersInput, PostsUncheckedUpdateWithoutViewersInput>
    create: XOR<PostsCreateWithoutViewersInput, PostsUncheckedCreateWithoutViewersInput>
    where?: PostsWhereInput
  }

  export type PostsUpdateToOneWithWhereWithoutViewersInput = {
    where?: PostsWhereInput
    data: XOR<PostsUpdateWithoutViewersInput, PostsUncheckedUpdateWithoutViewersInput>
  }

  export type PostsUpdateWithoutViewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostsNestedInput
    likes?: LikeUpdateManyWithoutPostsNestedInput
    reposts?: RePostsUpdateManyWithoutOriginalPostsNestedInput
    attachments?: AttachmentUpdateManyWithoutPostsNestedInput
    notifications?: NotificationUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateWithoutViewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostsNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostsNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutOriginalPostsNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutPostsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type UsersUpsertWithoutPostViewersInput = {
    update: XOR<UsersUpdateWithoutPostViewersInput, UsersUncheckedUpdateWithoutPostViewersInput>
    create: XOR<UsersCreateWithoutPostViewersInput, UsersUncheckedCreateWithoutPostViewersInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutPostViewersInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutPostViewersInput, UsersUncheckedUpdateWithoutPostViewersInput>
  }

  export type UsersUpdateWithoutPostViewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUsersNestedInput
    stories?: StoryUpdateManyWithoutUsersNestedInput
    likes?: LikeUpdateManyWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUpdateManyWithoutFriendNestedInput
    followers?: FollowersUpdateManyWithoutFollowerNestedInput
    following?: FollowersUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutPostViewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUsersNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUsersNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUsersNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    followers?: FollowersUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowersUncheckedUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUncheckedUpdateManyWithoutUsersNestedInput
    commentViewers?: CommentViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type CommentCreateWithoutViewersInput = {
    id?: string
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    users: UsersCreateNestedOneWithoutCommentsInput
    posts?: PostsCreateNestedOneWithoutCommentsInput
    story?: StoryCreateNestedOneWithoutCommentsInput
    attachments?: AttachmentCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutViewersInput = {
    id?: string
    usersId: string
    postsId?: string | null
    storyId?: string | null
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutViewersInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutViewersInput, CommentUncheckedCreateWithoutViewersInput>
  }

  export type UsersCreateWithoutCommentViewersInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsCreateNestedManyWithoutUsersInput
    stories?: StoryCreateNestedManyWithoutUsersInput
    likes?: LikeCreateNestedManyWithoutUsersInput
    comments?: CommentCreateNestedManyWithoutUsersInput
    reposts?: RePostsCreateNestedManyWithoutUsersInput
    notifications?: NotificationCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesCreateNestedManyWithoutReceiverInput
    friends?: FriendsCreateNestedManyWithoutUsersInput
    friendOf?: FriendsCreateNestedManyWithoutFriendInput
    followers?: FollowersCreateNestedManyWithoutFollowerInput
    following?: FollowersCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutCommentViewersInput = {
    id?: string
    username: string
    fullname: string
    email: string
    password: string
    profile_image?: string | null
    banner?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostsUncheckedCreateNestedManyWithoutUsersInput
    stories?: StoryUncheckedCreateNestedManyWithoutUsersInput
    likes?: LikeUncheckedCreateNestedManyWithoutUsersInput
    comments?: CommentUncheckedCreateNestedManyWithoutUsersInput
    reposts?: RePostsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUsersInput
    relatedNotifications?: NotificationUncheckedCreateNestedManyWithoutRelatedUsersInput
    messagesSent?: MessagesUncheckedCreateNestedManyWithoutSenderInput
    messagesReceived?: MessagesUncheckedCreateNestedManyWithoutReceiverInput
    friends?: FriendsUncheckedCreateNestedManyWithoutUsersInput
    friendOf?: FriendsUncheckedCreateNestedManyWithoutFriendInput
    followers?: FollowersUncheckedCreateNestedManyWithoutFollowerInput
    following?: FollowersUncheckedCreateNestedManyWithoutFollowingInput
    storyViewers?: StoryViewerUncheckedCreateNestedManyWithoutUsersInput
    postViewers?: PostsViewerUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutCommentViewersInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutCommentViewersInput, UsersUncheckedCreateWithoutCommentViewersInput>
  }

  export type CommentUpsertWithoutViewersInput = {
    update: XOR<CommentUpdateWithoutViewersInput, CommentUncheckedUpdateWithoutViewersInput>
    create: XOR<CommentCreateWithoutViewersInput, CommentUncheckedCreateWithoutViewersInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutViewersInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutViewersInput, CommentUncheckedUpdateWithoutViewersInput>
  }

  export type CommentUpdateWithoutViewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutCommentsNestedInput
    posts?: PostsUpdateOneWithoutCommentsNestedInput
    story?: StoryUpdateOneWithoutCommentsNestedInput
    attachments?: AttachmentUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutViewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type UsersUpsertWithoutCommentViewersInput = {
    update: XOR<UsersUpdateWithoutCommentViewersInput, UsersUncheckedUpdateWithoutCommentViewersInput>
    create: XOR<UsersCreateWithoutCommentViewersInput, UsersUncheckedCreateWithoutCommentViewersInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutCommentViewersInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutCommentViewersInput, UsersUncheckedUpdateWithoutCommentViewersInput>
  }

  export type UsersUpdateWithoutCommentViewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateManyWithoutUsersNestedInput
    stories?: StoryUpdateManyWithoutUsersNestedInput
    likes?: LikeUpdateManyWithoutUsersNestedInput
    comments?: CommentUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUpdateManyWithoutFriendNestedInput
    followers?: FollowersUpdateManyWithoutFollowerNestedInput
    following?: FollowersUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutCommentViewersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUncheckedUpdateManyWithoutUsersNestedInput
    stories?: StoryUncheckedUpdateManyWithoutUsersNestedInput
    likes?: LikeUncheckedUpdateManyWithoutUsersNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUsersNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUsersNestedInput
    relatedNotifications?: NotificationUncheckedUpdateManyWithoutRelatedUsersNestedInput
    messagesSent?: MessagesUncheckedUpdateManyWithoutSenderNestedInput
    messagesReceived?: MessagesUncheckedUpdateManyWithoutReceiverNestedInput
    friends?: FriendsUncheckedUpdateManyWithoutUsersNestedInput
    friendOf?: FriendsUncheckedUpdateManyWithoutFriendNestedInput
    followers?: FollowersUncheckedUpdateManyWithoutFollowerNestedInput
    following?: FollowersUncheckedUpdateManyWithoutFollowingNestedInput
    storyViewers?: StoryViewerUncheckedUpdateManyWithoutUsersNestedInput
    postViewers?: PostsViewerUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type PostsCreateManyUsersInput = {
    id?: string
    contentText?: string | null
    contentImage?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoryCreateManyUsersInput = {
    id?: string
    contentText?: string | null
    contentMedia?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    expirationTime: Date | string
  }

  export type LikeCreateManyUsersInput = {
    id?: string
    postsId?: string | null
    storyId?: string | null
    createdAt?: Date | string
  }

  export type CommentCreateManyUsersInput = {
    id?: string
    postsId?: string | null
    storyId?: string | null
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RePostsCreateManyUsersInput = {
    id?: string
    originalPostsId: string
    createdAt?: Date | string
  }

  export type NotificationCreateManyUsersInput = {
    id?: string
    relatedUsersId?: string | null
    postsId?: string | null
    commentId?: string | null
    storyId?: string | null
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateManyRelatedUsersInput = {
    id?: string
    usersId: string
    postsId?: string | null
    commentId?: string | null
    storyId?: string | null
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type MessagesCreateManySenderInput = {
    id?: string
    receiverId: string
    contentText?: string | null
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type MessagesCreateManyReceiverInput = {
    id?: string
    senderId: string
    contentText?: string | null
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type FriendsCreateManyUsersInput = {
    id?: string
    friendId: string
    friendStatus: $Enums.FriendStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FriendsCreateManyFriendInput = {
    id?: string
    usersId: string
    friendStatus: $Enums.FriendStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowersCreateManyFollowerInput = {
    id?: string
    followingId: string
    createdAt?: Date | string
  }

  export type FollowersCreateManyFollowingInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type StoryViewerCreateManyUsersInput = {
    id?: string
    storyId: string
    readAt?: Date | string
  }

  export type PostsViewerCreateManyUsersInput = {
    id?: string
    postsId: string
    viewedAt?: Date | string
  }

  export type CommentViewerCreateManyUsersInput = {
    id?: string
    commentId: string
    readAt?: Date | string
  }

  export type PostsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPostsNestedInput
    likes?: LikeUpdateManyWithoutPostsNestedInput
    reposts?: RePostsUpdateManyWithoutOriginalPostsNestedInput
    attachments?: AttachmentUpdateManyWithoutPostsNestedInput
    viewers?: PostsViewerUpdateManyWithoutPostsNestedInput
    notifications?: NotificationUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostsNestedInput
    likes?: LikeUncheckedUpdateManyWithoutPostsNestedInput
    reposts?: RePostsUncheckedUpdateManyWithoutOriginalPostsNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutPostsNestedInput
    viewers?: PostsViewerUncheckedUpdateManyWithoutPostsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentImage?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: StoryViewerUpdateManyWithoutStoryNestedInput
    likes?: LikeUpdateManyWithoutStoryNestedInput
    comments?: CommentUpdateManyWithoutStoryNestedInput
    attachments?: AttachmentUpdateManyWithoutStoryNestedInput
    notifications?: NotificationUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: StoryViewerUncheckedUpdateManyWithoutStoryNestedInput
    likes?: LikeUncheckedUpdateManyWithoutStoryNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStoryNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutStoryNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStoryNestedInput
  }

  export type StoryUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    contentMedia?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateOneWithoutLikesNestedInput
    story?: StoryUpdateOneWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateOneWithoutCommentsNestedInput
    story?: StoryUpdateOneWithoutCommentsNestedInput
    viewers?: CommentViewerUpdateManyWithoutCommentNestedInput
    attachments?: AttachmentUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: CommentViewerUncheckedUpdateManyWithoutCommentNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RePostsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalPosts?: PostsUpdateOneRequiredWithoutRepostsNestedInput
  }

  export type RePostsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RePostsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPostsId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedUsers?: UsersUpdateOneWithoutRelatedNotificationsNestedInput
    posts?: PostsUpdateOneWithoutNotificationsNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    story?: StoryUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    relatedUsersId?: NullableStringFieldUpdateOperationsInput | string | null
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    relatedUsersId?: NullableStringFieldUpdateOperationsInput | string | null
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutRelatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutNotificationsNestedInput
    posts?: PostsUpdateOneWithoutNotificationsNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    story?: StoryUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutRelatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutRelatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessagesUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UsersUpdateOneRequiredWithoutMessagesReceivedNestedInput
  }

  export type MessagesUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessagesUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessagesUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UsersUpdateOneRequiredWithoutMessagesSentNestedInput
  }

  export type MessagesUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessagesUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    contentText?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendStatus?: EnumFriendStatusFieldUpdateOperationsInput | $Enums.FriendStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friend?: UsersUpdateOneRequiredWithoutFriendOfNestedInput
  }

  export type FriendsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
    friendStatus?: EnumFriendStatusFieldUpdateOperationsInput | $Enums.FriendStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
    friendStatus?: EnumFriendStatusFieldUpdateOperationsInput | $Enums.FriendStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendsUpdateWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendStatus?: EnumFriendStatusFieldUpdateOperationsInput | $Enums.FriendStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutFriendsNestedInput
  }

  export type FriendsUncheckedUpdateWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    friendStatus?: EnumFriendStatusFieldUpdateOperationsInput | $Enums.FriendStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendsUncheckedUpdateManyWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    friendStatus?: EnumFriendStatusFieldUpdateOperationsInput | $Enums.FriendStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowersUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    following?: UsersUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowersUncheckedUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowersUncheckedUpdateManyWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowersUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: UsersUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowersUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowersUncheckedUpdateManyWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryViewerUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    story?: StoryUpdateOneRequiredWithoutViewersNestedInput
  }

  export type StoryViewerUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryViewerUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    storyId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsViewerUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateOneRequiredWithoutViewersNestedInput
  }

  export type PostsViewerUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    postsId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsViewerUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    postsId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentViewerUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutViewersNestedInput
  }

  export type CommentViewerUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentViewerUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyPostsInput = {
    id?: string
    usersId: string
    storyId?: string | null
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LikeCreateManyPostsInput = {
    id?: string
    usersId: string
    storyId?: string | null
    createdAt?: Date | string
  }

  export type RePostsCreateManyOriginalPostsInput = {
    id?: string
    usersId: string
    createdAt?: Date | string
  }

  export type AttachmentCreateManyPostsInput = {
    id?: string
    commentId?: string | null
    storyId?: string | null
    filePath: string
    fileType: $Enums.FileType
    createdAt?: Date | string
  }

  export type PostsViewerCreateManyPostsInput = {
    id?: string
    usersId: string
    viewedAt?: Date | string
  }

  export type NotificationCreateManyPostsInput = {
    id?: string
    usersId: string
    relatedUsersId?: string | null
    commentId?: string | null
    storyId?: string | null
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type CommentUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutCommentsNestedInput
    story?: StoryUpdateOneWithoutCommentsNestedInput
    viewers?: CommentViewerUpdateManyWithoutCommentNestedInput
    attachments?: AttachmentUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: CommentViewerUncheckedUpdateManyWithoutCommentNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutLikesNestedInput
    story?: StoryUpdateOneWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RePostsUpdateWithoutOriginalPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutRepostsNestedInput
  }

  export type RePostsUncheckedUpdateWithoutOriginalPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RePostsUncheckedUpdateManyWithoutOriginalPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneWithoutAttachmentsNestedInput
    story?: StoryUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsViewerUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutPostViewersNestedInput
  }

  export type PostsViewerUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsViewerUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutNotificationsNestedInput
    relatedUsers?: UsersUpdateOneWithoutRelatedNotificationsNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    story?: StoryUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    relatedUsersId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    relatedUsersId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryViewerCreateManyStoryInput = {
    id?: string
    usersId: string
    readAt?: Date | string
  }

  export type LikeCreateManyStoryInput = {
    id?: string
    usersId: string
    postsId?: string | null
    createdAt?: Date | string
  }

  export type CommentCreateManyStoryInput = {
    id?: string
    usersId: string
    postsId?: string | null
    content: string
    mediaUrl?: string | null
    mediaType: $Enums.MediaType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentCreateManyStoryInput = {
    id?: string
    postsId?: string | null
    commentId?: string | null
    filePath: string
    fileType: $Enums.FileType
    createdAt?: Date | string
  }

  export type NotificationCreateManyStoryInput = {
    id?: string
    usersId: string
    relatedUsersId?: string | null
    postsId?: string | null
    commentId?: string | null
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type StoryViewerUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutStoryViewersNestedInput
  }

  export type StoryViewerUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoryViewerUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutLikesNestedInput
    posts?: PostsUpdateOneWithoutLikesNestedInput
  }

  export type LikeUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutCommentsNestedInput
    posts?: PostsUpdateOneWithoutCommentsNestedInput
    viewers?: CommentViewerUpdateManyWithoutCommentNestedInput
    attachments?: AttachmentUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewers?: CommentViewerUncheckedUpdateManyWithoutCommentNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateOneWithoutAttachmentsNestedInput
    comment?: CommentUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutNotificationsNestedInput
    relatedUsers?: UsersUpdateOneWithoutRelatedNotificationsNestedInput
    posts?: PostsUpdateOneWithoutNotificationsNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    relatedUsersId?: NullableStringFieldUpdateOperationsInput | string | null
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutStoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    relatedUsersId?: NullableStringFieldUpdateOperationsInput | string | null
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentViewerCreateManyCommentInput = {
    id?: string
    usersId: string
    readAt?: Date | string
  }

  export type AttachmentCreateManyCommentInput = {
    id?: string
    postsId?: string | null
    storyId?: string | null
    filePath: string
    fileType: $Enums.FileType
    createdAt?: Date | string
  }

  export type NotificationCreateManyCommentInput = {
    id?: string
    usersId: string
    relatedUsersId?: string | null
    postsId?: string | null
    storyId?: string | null
    type: $Enums.NotificationType
    readStatus?: boolean
    createdAt?: Date | string
  }

  export type CommentViewerUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutCommentViewersNestedInput
  }

  export type CommentViewerUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentViewerUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostsUpdateOneWithoutAttachmentsNestedInput
    story?: StoryUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersUpdateOneRequiredWithoutNotificationsNestedInput
    relatedUsers?: UsersUpdateOneWithoutRelatedNotificationsNestedInput
    posts?: PostsUpdateOneWithoutNotificationsNestedInput
    story?: StoryUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    relatedUsersId?: NullableStringFieldUpdateOperationsInput | string | null
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    usersId?: StringFieldUpdateOperationsInput | string
    relatedUsersId?: NullableStringFieldUpdateOperationsInput | string | null
    postsId?: NullableStringFieldUpdateOperationsInput | string | null
    storyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}